## 设计模式学习笔记
<p>笔记几乎都是大话设计模式上的 只是帮助记忆

###  UML类图
#### 类之间的关系
<img src="https://s2.ax1x.com/2019/11/18/McUw6I.jpg" alt="McUw6I.jpg" border="0" />
<p> 类与类一共有如下几种关系：泛化（Generalization）、实现（Realization）、依赖（Dependence）、关联（Association）、聚合（Aggregation）、组合（Composition）
<p>1.泛化关系--泛化关系在Java中也叫作继承关系，在UML中我们用带空心三角形的直线来表示
<p>2.实现关系--这里的实现关系就是Java中类与接口的实现关系，在UML中我们用带空心三角形的虚线表示
<p>3.依赖关系--依赖关系是一种很弱的关系，一般是指一个类使用另一个类,用带箭头的虚线表示，箭头指向被依赖对象
<p>4.关联关系--关联关系是一种比较强的关系，他们的关系是比较持久的，稳定,单向关联我们用带箭头的实线表示，箭头指向被引用或者被包含的类
<p>5.聚合关系--聚合关系是一种特殊的关联关系，聚合关系强调的是整体和部分的关系,聚合用带空心菱形的直线表示，其中菱形指向整体
<p>6.组合关系--组合关系也是一种特殊的关联关系，它与聚合关系很像，也是强调整体与部分的关系，不同的是部分无法脱离整体存在,用带实心的菱形直线表示，其中菱形指向整体

### 设计模式六大原则
####  一、开-闭原则：
<p>  1、开闭原则顾名思义就是对修改关闭，对扩展开放；
<p>  2、开闭原则是六大原则的核心，即我们之后做的任何改变都不需要修改原有的代码，只需要加入一些新的实现即可达到目的；
<p>  3、开闭原则也是任何一个系统设计期望达到的理想境界。

#### 二、单一职责原则：
<p>    单一职责即每个类都只负责单一的功能，莫要太贪心，除此之外尽量把一个类的功能完善到极致，可以用final来修饰的程度

#### 三、里氏替换原则：
<p>      里氏替换原则具体指的是一个子类可以在替换掉其父类后正常工作，也就是自类不应该重写父类的方法，其主要作用是规范继承是子类的一些书写规则，主要目的是保持父类方法不被覆盖。
<p>      1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法(要不重新写给类算了，干嘛要继承)；
<p>      2、子类中可以增加自己特有的方法；
<p>      3、当子类覆盖或实现父类方法时，方法的前置条件(方法的形参)要比其父类方法的输入参数更宽松(如：fun(ArrayLIst, list) VS fun(List, list) )；
<p>     4、当子类的方法实现父类的抽象方法时，方法的后置条件(方法的返回值)要比其父类更严格。

#### 四、接口隔离原则：
<p>     接口隔离原则也叫做接口最小化原则，指的是一个接口拥有的行为应该尽可能的最小

#### 五、依赖倒置原则：
<p>      这个原则描述的是高层模块不该依赖于低层模块，两个模块都应该依赖依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。因为实现都是易变的，只有抽象是稳定的，所以当我们依赖于抽象是，实现的变化就不会影响客户端的调用

#### 六、迪米特原则：
 <p>    迪米特原则也称最小知道原则，就是一个类尽量不应该知道(包括)其他类太多的东西，不要和其他类有太多的交集。该原则的制定的终极目的就是解耦，即将细节全部高内聚于类的内部，其他的类只需知道这个类主要提供的功能就OK了，减少不必要的依赖，高聚合低耦合

###三大类总纲设计模式分别有那些具体的设计模式？

####A：创建型模式

<p>创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
<p>它包括以下几种具体的设计模式：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式

####B：结构型模式

<p>结构型模式设计，它关注类和对象的组合。继承这一概念被用来组合接口和定义组合对象获得新功能的方式。
<p>它包括以下几种具体的设计模式：适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式

####C：行为型模式

<p>行为型模式设计，更关注对象与对象之间的通信。它包括以下几种具体的设计模式：
<p>责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、空对象模式、策略模式、模板模式、访问者模式


### 设计模式

#### 1 策略模式
<p> 用于处理不同情况 不同的应变处理 
<p> 举例: 线程池的拒绝策略 是应用了策略模式, 不同策略不同处理
<p> 可以和工厂模式一起 使用，解决多层if else的情况

#### 2 工厂模式 
<p>2.1 简单工厂模式
<p>根据传入的参数，动态决定应该创建哪一个产品类
<p>举例: Spring中的BeanFactory就是简单 工厂的应用

<p>2.2 工厂方法模式
<p> 创建对象的接口 让子类自己决定实例化哪一个类
<p> 在大话设计模式中 例子雷锋工厂 通过调用方自己去实例相应实例

#### 3 代理模式
<p> 用途: 某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。
<p> 作用:起到了隔离作用 增强了开闭原则
<p> 举例： spring的aop 
<p> 3.1 静态代理
<p> 通过生成代理类和 共同父类 关联关系 实现 静态代理
<p> 3.2 动态代理
<p> java中的动态代理一般有jdk和cglib   代码如下:
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/proxy">  code</a>     
<p> 他们主要区别在 jdk的需要提供接口  cglib 不需要提供接口    
<p> 他们实现原理都是通过字节码生成一个新的 代理类  不同的是jdk 生成的 类会 implements 传入的接口 所以jdk方式需要接口
<p> 而cglib 通过asm 也是生成一个新的代理类 但实现的传过来的类 修改子类的代码来实现的

#### 4 装饰模式   
<p>装饰器模式是继承的一种替代模式，其优点是可以动态扩展一个实现类的功能。这种设计模式下不仅可以扩展一个类的功能，
<p>也可以动态增加功能，动态撤销。但缺点就是多层装饰使用起来相对比较复杂。本质是将具体功能职责划分（例如区分核心组件以及附加属性职责）减少子类直接继承父类的耦合性
<p>增加附加功能 如加密解密, 多个装饰之间 最好独立 没有关系
                           
#### 5 原型模式
<p> 最直接的理解就是 复制原型对象的方法来创建对象的新实例
<p> java中的 克隆
<p> 1 实现 Cloneable 接口  这是个标记接口 没有实际方法  但要标记该对象能clone
<p> 2 重写clone 方法  object.clone() 是protected的
<p> java 中的浅克隆和深克隆
<p>  浅拷贝：被复制对象的所有值属性都含有与原来对象的相同，而所有的对象引用属性仍然指向原来的对象。
<p>  深拷贝：在浅拷贝的基础上，所有引用其他对象的变量也进行了clone，并指向被复制过的新对象。
<p> java 中克隆对象的其他实现
<p> 1 序列化 2 BeanUtils （commons和spring 都有） 3 cglib (默认是浅克隆 但能扩展) 4 其他框架


#### 6 模板方法模式
<p>  模板方法模式，定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
<p> 1）模板方法模式的优点
<p> ①模板方法模式通过把不变的行为搬移到父类，去除了子类中的重复代码。 
<p> ②子类实现算法的某些细节，有助于算法的扩展。 
<p> ③通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。
<p> （2）模板方法模式的缺点
<p> 按照设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类负责完成具体的事务属性和方法，但是模板方式正好相反，子类执行的结果影响了父类的结果，会增加代码阅读的难度。
<p> （3）模板方法模式适合的场景
<p> ①多个子类有共有的方法，并且逻辑基本相同。 
<p> ②重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 
<p> ③重构时，模板方法是一个经常使用的方法，把相同的代码抽取到父类中，然后通过构造函数约束其行为。


#### 7 外观模式
<p>为子系统中的一组接口提供一个一致的界面，用来访问子系统中的一群接口
<p> 优点：
<p>    　　1、实现了子系统与客户端之间的松耦合关系；
<p>    　　2、客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。
<p>缺点：
<p>    　　1、不符合开闭原则，如果要修改某一个子系统的功能，通常外观类也要一起修改；
<p>    　　2、没有办法直接阻止外部不通过外观类访问子系统的功能，因为子系统类中的功能必须是公开的（根据需要决定是否使用internal访问级别可解决这个缺点，但外观类需要和子系统类在同一个程序集内）


#### 8 建造者模式
<p> 建造者模式又被称呼为生成器模式，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
<p>    使用多个简单的对象一步一步构建成一个复杂的对象，有点像造房子一样一步步从地基做起到万丈高楼
<p>1、定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
<p>2、主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。
<p>3、如何使用：用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）
<p>4、解决的问题：
<p>（1）、方便用户创建复杂的对象（不需要知道实现过程）
<p>（2）、代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）
<p>5、注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，一般用来创建更为复杂的对象

#### 9 观察者模式
<p>   观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，
<p> 让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己

<p>（1）推模型： 主题对象向观察者推送主题的详细信息，不管是否需要。
<p>（2）拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取。

#### 10  状态模式
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类，(State Pattern)是设计模式的一种，属于行为模式。
<p>(源于Design Pattern)：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
<p>  状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
<p>  模式中的角色
<p>  　　1 上下文环境（Context）：它定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的Concrete State对象来处理。
<p>  　　2 抽象状态（State）：定义一个接口以封装使用上下文环境的的一个特定状态相关的行为。
<p>  　　3 具体状态（Concrete State）：实现抽象状态定义的接口。
<p> 本质是通过修改上下文 来完成具体现实的切换

#### 11 适配器模式
<p> <a href="https://www.jianshu.com/p/c7f19e5310f9">参考<a/>
<p>   适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够在一起工作。
<p> 理解：把多个无关的类匹配同一个接口，客户端实例化接口，使形成一个公共常用的的类结构。  有点类似mvc 架构 service常做的事
 
#### 12 备忘录模式
<p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保护这个状态，这样以后就可以将该对象恢复到原先保存的状态
<p>备忘录模式场景
<p>场景一：需要保存对象在某一时刻的状态或者部分状态
<p>场景二：如果用一个接口（协议）来让其他对象得到这些状态，将暴露对象的实现细节并且破坏对象的封装性，一个对象不希望外界直接访问其内部状态，
<p>通过中间对象可以间接访问其封装状态，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态

<p>备忘录模式角色划分

<p>角色一：（Originator）：负责创建一个备忘录，可以记录或者恢复内部状态
<p>角色二：（Memento）：备忘录角色，用于存储角色一的内部状态，并且可以防止角色一以外的对象访问角色二
<p>角色三：（Caretaker）：负责存储备忘录，不能够向外暴露对备忘录内容进行操作


#### 13 组合模式
<p>  也称为 整体-部分（Part-Whole）模式，它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示，使得客户对单个对象和组合对象的使用具有一致性。
<p>   当子系统与其内各个对象层次呈现树形结构时，可以使用 组合模式 让该子系统内各个对象层次的行为操作具备一致性。客户端使用该子系统内任意一个层次对象时，无须进行区分，直接使用通用操作即可，为客户端的使用带来了便捷

#### 优点
<p>    组合模式 屏蔽了对象系统的层次差异性（树节点和叶子节点为不同类型），将客户代码与复杂的容器对象解耦，使得客户端可以忽略层次间的差异，使用一致的行为控制不同层次。
<p>    在 组合模式 可以很方便地增加 树枝节点 和 叶子节点 对象，并对现有类库无侵入，符合 开闭原则；

####    缺点
<p>    如果类系统（树形结构）过于庞大，虽然对不同层次都提供一致性操作，但客户端仍需花费时间理清类之间的层次关系；
<p>    组合模式 在具体实现上违背了设计模式 接口隔离原则 或 依赖倒置原则；

<p>三种角色：
<p>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性；
<p>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构；
<p>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位；

<p>透明组合模式 把所有公共方法都定义在 Component 中，这样做的好处是客户端无需分辨是叶子节点（Leaf）和树枝节点（Composite），它们具备完全一致的接口；缺点是叶子节点（Leaf）会继承得到一些它所不需要（管理子类操作的方法）的方法，这与设计模式 接口隔离原则 相违背。
<p>安全模式：统一行为（Component）只规定系统各个层次的最基础的一致行为，而把组合（树节点）本身的方法（管理子类对象的添加，删除等）放到自身当中

#### 14 迭代器模式
<p>  迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，而又无需暴露该对象的内部实现，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据
<p>具体实现就是集合的迭代器
<p> 角色:
<p> 抽象容器角色（Aggregate）：负责提供创建具体迭代器角色的接口，一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。
<p>    具体容器角色（ConcreteAggregate）：就是实现抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkedList,Set接口的哈希列表的实现HashSet等。
<p>    抽象迭代器角色（Iterator）：负责定义访问和遍历元素的接口。
<p>    具体迭代器角色（ConcreteIterator）：实现迭代器接口，并要记录遍历中的当前位置。

#### 15 单例模式
<p> 所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。
<p> 特点
<li> 类构造器私有
<li>   持有自己类型的属性
<li>   对外提供获取实例的静态方法
<p> <a href="https://www.jb51.net/article/158589.htm">单例的多种写法</a>
<p>  懒汉式（线程不安全）
<p>  懒汉式（线程安全，同步方法，不推荐使用）
<p>  饿汉式（线程安全）
<p>  静态内部类加载（线程安全）
<p>  枚举（线程安全）
<p>  懒汉式双重校验锁法（通常线程安全，不可保证完全安全）
<p>  懒汉式双重检查终极版
<p>  使用 ThreadLocal 实现（线程安全）
<p>  使用CAS 锁实现（线程安全）

#### 16 桥接模式
<p> 将抽象部分与它的实现部分分离，使它们都可以独立地变化
<p> 具体场景参考 大话设计模式  n个手机厂商 和每种手机内置小游戏
<img src="https://s2.ax1x.com/2019/12/09/Qd0RKA.jpg" alt="Qd0RKA.jpg" border="0" />
<p> 组合比继承优点： 不是强耦合 ,而是松耦合 提高了复用性(DP)


####  17 命令模式
<p> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
<li>Command：
<p>定义命令的接口，声明执行的方法。
<li>ConcreteCommand：
<p>命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
<li>Receiver：
<p>接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
<li>Invoker：
<p>要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
<li>Client：
<p>创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。

<p>命令模式的优缺点
<p>1 更松散的耦合
<p>2 更动态的控制
<p>3 能很自然的复合命令
<p>4 更好的扩展性

<p>命令模式的本质

<p>命令模式的本质是：封装请求。  通过参数确认操作
<p>何时选用

<li>1 如果需要抽象出需要执行的动作，并参数化这些对象，可以选用命令模式，把这些需要执行的动作抽象成为命令，然后实现命令的参数化配置

<li>2 如果需要在不同的时刻指定、排列和执行请求，可以选用命令模式，把这些请求封装成为命令对象，然后实现把请求队列化

<li>3 如果需要支持取消操作，可以选用命令模式，通过管理命令对象，能很容易的实现命令的恢复和重做的功能

<li>4 如果需要支持当系统崩溃时，能把对系统的操作功能重新执行一遍，可以选用命令模式，把这些操作功能的请求封装成命令对象，然后实现日志命令，就可以在系统恢复回来后，通过日志获取命令列表，从而重新执行一遍功能

<li>5 在需要事务的系统中，可以选用命令模式，命令模式提供了对事务进行建模的方法，命令模式有一个别名就是Transaction


### 18 职责链模式
<p>  避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
<p> 职责链模式相关角色
    
<li> Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。
    
 <li>ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。
 
<p>       1) 纯的职责链模式
       
<li>       一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的职责链模式。
       
<p>       2)不纯的职责链模式
       
<li>       在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收
<p> 1).优点

<li>职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。
<li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。
<li>在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。
<li>在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。
<p>2). 缺点

<li>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。
<li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。
<li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环。
<p>3). 适用场景

<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。

#### 19 享元模式
<p> 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。

<p> 角色：

<li>Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。
<li>ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。
<li>UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。
<li>FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。
<p> 单纯享元模式

<li>在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。它的UML类图如下：

<p> 复合享元模式

<li>在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。而还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。它的UML类图如下：

<p>优点

<p>享元模式的主要优点如下：

<li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。
<p>缺点

<p>享元模式的主要缺点如下：

<li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
<li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。
