## 设计模式学习笔记
<p>笔记几乎都是大话设计模式上的 只是帮助记忆

###  UML类图
#### 类之间的关系
<img src="https://s2.ax1x.com/2019/11/18/McUw6I.jpg" alt="McUw6I.jpg" border="0" />
<p> 类与类一共有如下几种关系：泛化（Generalization）、实现（Realization）、依赖（Dependence）、关联（Association）、聚合（Aggregation）、组合（Composition）
<p>1.泛化关系--泛化关系在Java中也叫作继承关系，在UML中我们用带空心三角形的直线来表示
<p>2.实现关系--这里的实现关系就是Java中类与接口的实现关系，在UML中我们用带空心三角形的虚线表示
<p>3.依赖关系--依赖关系是一种很弱的关系，一般是指一个类使用另一个类,用带箭头的虚线表示，箭头指向被依赖对象
<p>4.关联关系--关联关系是一种比较强的关系，他们的关系是比较持久的，稳定,单向关联我们用带箭头的实线表示，箭头指向被引用或者被包含的类
<p>5.聚合关系--聚合关系是一种特殊的关联关系，聚合关系强调的是整体和部分的关系,聚合用带空心菱形的直线表示，其中菱形指向整体
<p>6.组合关系--组合关系也是一种特殊的关联关系，它与聚合关系很像，也是强调整体与部分的关系，不同的是部分无法脱离整体存在,用带实心的菱形直线表示，其中菱形指向整体

### 设计模式六大原则
####  一、开-闭原则：
<p>  1、开闭原则顾名思义就是对修改关闭，对扩展开放；
<p>  2、开闭原则是六大原则的核心，即我们之后做的任何改变都不需要修改原有的代码，只需要加入一些新的实现即可达到目的；
<p>  3、开闭原则也是任何一个系统设计期望达到的理想境界。

#### 二、单一职责原则：
<p>    单一职责即每个类都只负责单一的功能，莫要太贪心，除此之外尽量把一个类的功能完善到极致，可以用final来修饰的程度

#### 三、里氏替换原则：
<p>      里氏替换原则具体指的是一个子类可以在替换掉其父类后正常工作，也就是自类不应该重写父类的方法，其主要作用是规范继承是子类的一些书写规则，主要目的是保持父类方法不被覆盖。
<p>      1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法(要不重新写给类算了，干嘛要继承)；
<p>      2、子类中可以增加自己特有的方法；
<p>      3、当子类覆盖或实现父类方法时，方法的前置条件(方法的形参)要比其父类方法的输入参数更宽松(如：fun(ArrayLIst, list) VS fun(List, list) )；
<p>     4、当子类的方法实现父类的抽象方法时，方法的后置条件(方法的返回值)要比其父类更严格。

#### 四、接口隔离原则：
<p>     接口隔离原则也叫做接口最小化原则，指的是一个接口拥有的行为应该尽可能的最小

#### 五、依赖倒置原则：
<p>      这个原则描述的是高层模块不该依赖于低层模块，两个模块都应该依赖依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。因为实现都是易变的，只有抽象是稳定的，所以当我们依赖于抽象是，实现的变化就不会影响客户端的调用

#### 六、迪米特原则：
 <p>    迪米特原则也称最小知道原则，就是一个类尽量不应该知道(包括)其他类太多的东西，不要和其他类有太多的交集。该原则的制定的终极目的就是解耦，即将细节全部高内聚于类的内部，其他的类只需知道这个类主要提供的功能就OK了，减少不必要的依赖，高聚合低耦合

###三大类总纲设计模式分别有那些具体的设计模式？

####A：创建型模式

<p>创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
<p>它包括以下几种具体的设计模式：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式

####B：结构型模式

<p>结构型模式设计，它关注类和对象的组合。继承这一概念被用来组合接口和定义组合对象获得新功能的方式。
<p>它包括以下几种具体的设计模式：适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式

####C：行为型模式

<p>行为型模式设计，更关注对象与对象之间的通信。它包括以下几种具体的设计模式：
<p>责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、空对象模式、策略模式、模板模式、访问者模式


### 设计模式

#### 1 策略模式
<p> 用于处理不同情况 不同的应变处理 
<p> 举例: 线程池的拒绝策略 是应用了策略模式, 不同策略不同处理
<p> 可以和工厂模式一起 使用，解决多层if else的情况

#### 2 工厂模式 
<p>2.1 简单工厂模式
<p>根据传入的参数，动态决定应该创建哪一个产品类
<p>举例: Spring中的BeanFactory就是简单 工厂的应用

<p>2.2 工厂方法模式
<p> 创建对象的接口 让子类自己决定实例化哪一个类
<p> 在大话设计模式中 例子雷锋工厂 通过调用方自己去实例相应实例

#### 3 代理模式
<p> 用途: 某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。
<p> 作用:起到了隔离作用 增强了开闭原则
<p> 举例： spring的aop 
<p> 3.1 静态代理
<p> 通过生成代理类和 共同父类 关联关系 实现 静态代理
<p> 3.2 动态代理
<p> java中的动态代理一般有jdk和cglib   代码如下:
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/proxy">  code</a>     
<p> 他们主要区别在 jdk的需要提供接口  cglib 不需要提供接口    
<p> 他们实现原理都是通过字节码生成一个新的 代理类  不同的是jdk 生成的 类会 implements 传入的接口 所以jdk方式需要接口
<p> 而cglib 通过asm 也是生成一个新的代理类 但实现的传过来的类 修改子类的代码来实现的

#### 4 装饰模式   
<p>装饰器模式是继承的一种替代模式，其优点是可以动态扩展一个实现类的功能。这种设计模式下不仅可以扩展一个类的功能，
<p>也可以动态增加功能，动态撤销。但缺点就是多层装饰使用起来相对比较复杂。本质是将具体功能职责划分（例如区分核心组件以及附加属性职责）减少子类直接继承父类的耦合性
<p>增加附加功能 如加密解密, 多个装饰之间 最好独立 没有关系
                           
#### 5 原型模式
<p> 最直接的理解就是 复制原型对象的方法来创建对象的新实例
<p> java中的 克隆
<p> 1 实现 Cloneable 接口  这是个标记接口 没有实际方法  但要标记该对象能clone
<p> 2 重写clone 方法  object.clone() 是protected的
<p> java 中的浅克隆和深克隆
<p>  浅拷贝：被复制对象的所有值属性都含有与原来对象的相同，而所有的对象引用属性仍然指向原来的对象。
<p>  深拷贝：在浅拷贝的基础上，所有引用其他对象的变量也进行了clone，并指向被复制过的新对象。
<p> java 中克隆对象的其他实现
<p> 1 序列化 2 BeanUtils （commons和spring 都有） 3 cglib (默认是浅克隆 但能扩展) 4 其他框架


#### 6 模板方法模式
<p>  模板方法模式，定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
<p> 1）模板方法模式的优点
<p> ①模板方法模式通过把不变的行为搬移到父类，去除了子类中的重复代码。 
<p> ②子类实现算法的某些细节，有助于算法的扩展。 
<p> ③通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。
<p> （2）模板方法模式的缺点
<p> 按照设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类负责完成具体的事务属性和方法，但是模板方式正好相反，子类执行的结果影响了父类的结果，会增加代码阅读的难度。
<p> （3）模板方法模式适合的场景
<p> ①多个子类有共有的方法，并且逻辑基本相同。 
<p> ②重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 
<p> ③重构时，模板方法是一个经常使用的方法，把相同的代码抽取到父类中，然后通过构造函数约束其行为。


#### 7 外观模式
<p>为子系统中的一组接口提供一个一致的界面，用来访问子系统中的一群接口
<p> 优点：
<p>    　　1、实现了子系统与客户端之间的松耦合关系；
<p>    　　2、客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。
<p>缺点：
<p>    　　1、不符合开闭原则，如果要修改某一个子系统的功能，通常外观类也要一起修改；
<p>    　　2、没有办法直接阻止外部不通过外观类访问子系统的功能，因为子系统类中的功能必须是公开的（根据需要决定是否使用internal访问级别可解决这个缺点，但外观类需要和子系统类在同一个程序集内）


#### 8 建造者模式
<p> 建造者模式又被称呼为生成器模式，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
<p>    使用多个简单的对象一步一步构建成一个复杂的对象，有点像造房子一样一步步从地基做起到万丈高楼
<p>1、定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
<p>2、主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。
<p>3、如何使用：用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）
<p>4、解决的问题：
<p>（1）、方便用户创建复杂的对象（不需要知道实现过程）
<p>（2）、代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）
<p>5、注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，一般用来创建更为复杂的对象

#### 9 观察者模式
<p>   观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，
<p> 让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己

<p>（1）推模型： 主题对象向观察者推送主题的详细信息，不管是否需要。
<p>（2）拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取。

#### 10  状态模式
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类，(State Pattern)是设计模式的一种，属于行为模式。
<p>(源于Design Pattern)：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
<p>  状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
<p>  模式中的角色
<p>  　　1 上下文环境（Context）：它定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的Concrete State对象来处理。
<p>  　　2 抽象状态（State）：定义一个接口以封装使用上下文环境的的一个特定状态相关的行为。
<p>  　　3 具体状态（Concrete State）：实现抽象状态定义的接口。
<p> 本质是通过修改上下文 来完成具体现实的切换

#### 11 适配器模式
<p> <a href="https://www.jianshu.com/p/c7f19e5310f9">参考<a/>
<p>   适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够在一起工作。
<p> 理解：把多个无关的类匹配同一个接口，客户端实例化接口，使形成一个公共常用的的类结构。  有点类似mvc 架构 service常做的事
 
#### 12 备忘录模式
<p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保护这个状态，这样以后就可以将该对象恢复到原先保存的状态
<p>备忘录模式场景
<p>场景一：需要保存对象在某一时刻的状态或者部分状态
<p>场景二：如果用一个接口（协议）来让其他对象得到这些状态，将暴露对象的实现细节并且破坏对象的封装性，一个对象不希望外界直接访问其内部状态，
<p>通过中间对象可以间接访问其封装状态，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态

<p>备忘录模式角色划分

<p>角色一：（Originator）：负责创建一个备忘录，可以记录或者恢复内部状态
<p>角色二：（Memento）：备忘录角色，用于存储角色一的内部状态，并且可以防止角色一以外的对象访问角色二
<p>角色三：（Caretaker）：负责存储备忘录，不能够向外暴露对备忘录内容进行操作


#### 13 组合模式
<p>  也称为 整体-部分（Part-Whole）模式，它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示，使得客户对单个对象和组合对象的使用具有一致性。
<p>   当子系统与其内各个对象层次呈现树形结构时，可以使用 组合模式 让该子系统内各个对象层次的行为操作具备一致性。客户端使用该子系统内任意一个层次对象时，无须进行区分，直接使用通用操作即可，为客户端的使用带来了便捷

#### 优点
<p>    组合模式 屏蔽了对象系统的层次差异性（树节点和叶子节点为不同类型），将客户代码与复杂的容器对象解耦，使得客户端可以忽略层次间的差异，使用一致的行为控制不同层次。
<p>    在 组合模式 可以很方便地增加 树枝节点 和 叶子节点 对象，并对现有类库无侵入，符合 开闭原则；

####    缺点
<p>    如果类系统（树形结构）过于庞大，虽然对不同层次都提供一致性操作，但客户端仍需花费时间理清类之间的层次关系；
<p>    组合模式 在具体实现上违背了设计模式 接口隔离原则 或 依赖倒置原则；

<p>三种角色：
<p>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性；
<p>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构；
<p>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位；

<p>透明组合模式 把所有公共方法都定义在 Component 中，这样做的好处是客户端无需分辨是叶子节点（Leaf）和树枝节点（Composite），它们具备完全一致的接口；缺点是叶子节点（Leaf）会继承得到一些它所不需要（管理子类操作的方法）的方法，这与设计模式 接口隔离原则 相违背。
<p>安全模式：统一行为（Component）只规定系统各个层次的最基础的一致行为，而把组合（树节点）本身的方法（管理子类对象的添加，删除等）放到自身当中

#### 14 迭代器模式
<p>  迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，而又无需暴露该对象的内部实现，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据
<p>具体实现就是集合的迭代器
<p> 角色:
<p> 抽象容器角色（Aggregate）：负责提供创建具体迭代器角色的接口，一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。
<p>    具体容器角色（ConcreteAggregate）：就是实现抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkedList,Set接口的哈希列表的实现HashSet等。
<p>    抽象迭代器角色（Iterator）：负责定义访问和遍历元素的接口。
<p>    具体迭代器角色（ConcreteIterator）：实现迭代器接口，并要记录遍历中的当前位置。

#### 15 单例模式
<p> 所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。
<p> 特点
<li> 类构造器私有
<li>   持有自己类型的属性
<li>   对外提供获取实例的静态方法
<p> <a href="https://www.jb51.net/article/158589.htm">单例的多种写法</a>
<p>  懒汉式（线程不安全）
<p>  懒汉式（线程安全，同步方法，不推荐使用）
<p>  饿汉式（线程安全）
<p>  静态内部类加载（线程安全）
<p>  枚举（线程安全）
<p>  懒汉式双重校验锁法（通常线程安全，不可保证完全安全）
<p>  懒汉式双重检查终极版
<p>  使用 ThreadLocal 实现（线程安全）
<p>  使用CAS 锁实现（线程安全）