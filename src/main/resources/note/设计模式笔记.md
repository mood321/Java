## 设计模式学习笔记
<p>笔记几乎都是大话设计模式上的 只是帮助记忆

###  UML类图
#### 类之间的关系
<img src="https://s2.ax1x.com/2019/11/18/McUw6I.jpg" alt="McUw6I.jpg" border="0" />
<p> 类与类一共有如下几种关系：泛化（Generalization）、实现（Realization）、依赖（Dependence）、关联（Association）、聚合（Aggregation）、组合（Composition）
<p>1.泛化关系--泛化关系在Java中也叫作继承关系，在UML中我们用带空心三角形的直线来表示
<p>2.实现关系--这里的实现关系就是Java中类与接口的实现关系，在UML中我们用带空心三角形的虚线表示
<p>3.依赖关系--依赖关系是一种很弱的关系，一般是指一个类使用另一个类,用带箭头的虚线表示，箭头指向被依赖对象
<p>4.关联关系--关联关系是一种比较强的关系，他们的关系是比较持久的，稳定,单向关联我们用带箭头的实线表示，箭头指向被引用或者被包含的类
<p>5.聚合关系--聚合关系是一种特殊的关联关系，聚合关系强调的是整体和部分的关系,聚合用带空心菱形的直线表示，其中菱形指向整体
<p>6.组合关系--组合关系也是一种特殊的关联关系，它与聚合关系很像，也是强调整体与部分的关系，不同的是部分无法脱离整体存在,用带实心的菱形直线表示，其中菱形指向整体

### 设计模式六大原则
####  一、开-闭原则：
<p>  1、开闭原则顾名思义就是对修改关闭，对扩展开放；
<p>  2、开闭原则是六大原则的核心，即我们之后做的任何改变都不需要修改原有的代码，只需要加入一些新的实现即可达到目的；
<p>  3、开闭原则也是任何一个系统设计期望达到的理想境界。

#### 二、单一职责原则：
<p>    单一职责即每个类都只负责单一的功能，莫要太贪心，除此之外尽量把一个类的功能完善到极致，可以用final来修饰的程度

#### 三、里氏替换原则：
<p>      里氏替换原则具体指的是一个子类可以在替换掉其父类后正常工作，也就是自类不应该重写父类的方法，其主要作用是规范继承是子类的一些书写规则，主要目的是保持父类方法不被覆盖。
<p>      1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法(要不重新写给类算了，干嘛要继承)；
<p>      2、子类中可以增加自己特有的方法；
<p>      3、当子类覆盖或实现父类方法时，方法的前置条件(方法的形参)要比其父类方法的输入参数更宽松(如：fun(ArrayLIst, list) VS fun(List, list) )；
<p>     4、当子类的方法实现父类的抽象方法时，方法的后置条件(方法的返回值)要比其父类更严格。

#### 四、接口隔离原则：
<p>     接口隔离原则也叫做接口最小化原则，指的是一个接口拥有的行为应该尽可能的最小

#### 五、依赖倒置原则：
<p>      这个原则描述的是高层模块不该依赖于低层模块，两个模块都应该依赖依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。因为实现都是易变的，只有抽象是稳定的，所以当我们依赖于抽象是，实现的变化就不会影响客户端的调用

#### 六、迪米特原则：
 <p>    迪米特原则也称最小知道原则，就是一个类尽量不应该知道(包括)其他类太多的东西，不要和其他类有太多的交集。该原则的制定的终极目的就是解耦，即将细节全部高内聚于类的内部，其他的类只需知道这个类主要提供的功能就OK了，减少不必要的依赖，高聚合低耦合
 
### 设计模式

#### 1 策略模式
<p> 用于处理不同情况 不同的应变处理 
<p> 举例: 线程池的拒绝策略 是应用了策略模式, 不同策略不同处理
<p> 可以和工厂模式一起 使用，解决多层if else的情况

#### 2 工厂模式 
<p>2.1 简单工厂模式
<p>根据传入的参数，动态决定应该创建哪一个产品类
<p>举例: Spring中的BeanFactory就是简单 工厂的应用

<p>2.2 工厂方法模式
<p> 创建对象的接口 让子类自己决定实例化哪一个类
<p> 在大话设计模式中 例子雷锋工厂 通过调用方自己去实例相应实例

#### 3 代理模式
<p> 用途: 某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。
<p> 作用:起到了隔离作用 增强了开闭原则
<p> 举例： spring的aop 
<p> 3.1 静态代理
<p> 通过生成代理类和 共同父类 关联关系 实现 静态代理
<p> 3.2 动态代理
<p> java中的动态代理一般有jdk和cglib   代码如下:
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/proxy">  code</a>     
<p> 他们主要区别在 jdk的需要提供接口  cglib 不需要提供接口    
<p> 他们实现原理都是通过字节码生成一个新的 代理类  不同的是jdk 生成的 类会 implements 传入的接口 所以jdk方式需要接口
<p> 而cglib 通过asm 也是生成一个新的代理类 但实现的传过来的类 修改子类的代码来实现的
                                      
 
