## 设计模式学习笔记
<p>笔记几乎都是大话设计模式上的 只是帮助记忆

###  UML类图
#### 类之间的关系
<img src="https://s2.ax1x.com/2019/11/18/McUw6I.jpg" alt="McUw6I.jpg" border="0" />
<p> 类与类一共有如下几种关系：泛化（Generalization）、实现（Realization）、依赖（Dependence）、关联（Association）、聚合（Aggregation）、组合（Composition）
<p>1.泛化关系--泛化关系在Java中也叫作继承关系，在UML中我们用带空心三角形的直线来表示
<p>2.实现关系--这里的实现关系就是Java中类与接口的实现关系，在UML中我们用带空心三角形的虚线表示
<p>3.依赖关系--依赖关系是一种很弱的关系，一般是指一个类使用另一个类,用带箭头的虚线表示，箭头指向被依赖对象
<p>4.关联关系--关联关系是一种比较强的关系，他们的关系是比较持久的，稳定,单向关联我们用带箭头的实线表示，箭头指向被引用或者被包含的类
<p>5.聚合关系--聚合关系是一种特殊的关联关系，聚合关系强调的是整体和部分的关系,聚合用带空心菱形的直线表示，其中菱形指向整体
<p>6.组合关系--组合关系也是一种特殊的关联关系，它与聚合关系很像，也是强调整体与部分的关系，不同的是部分无法脱离整体存在,用带实心的菱形直线表示，其中菱形指向整体

### 设计模式六大原则
####  一、开-闭原则：
<p>  1、开闭原则顾名思义就是对修改关闭，对扩展开放；
<p>  2、开闭原则是六大原则的核心，即我们之后做的任何改变都不需要修改原有的代码，只需要加入一些新的实现即可达到目的；
<p>  3、开闭原则也是任何一个系统设计期望达到的理想境界。

#### 二、单一职责原则：
<p>    单一职责即每个类都只负责单一的功能，莫要太贪心，除此之外尽量把一个类的功能完善到极致，可以用final来修饰的程度

#### 三、里氏替换原则：
<p>      里氏替换原则具体指的是一个子类可以在替换掉其父类后正常工作，也就是自类不应该重写父类的方法，其主要作用是规范继承是子类的一些书写规则，主要目的是保持父类方法不被覆盖。
<p>      1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法(要不重新写给类算了，干嘛要继承)；
<p>      2、子类中可以增加自己特有的方法；
<p>      3、当子类覆盖或实现父类方法时，方法的前置条件(方法的形参)要比其父类方法的输入参数更宽松(如：fun(ArrayLIst, list) VS fun(List, list) )；
<p>     4、当子类的方法实现父类的抽象方法时，方法的后置条件(方法的返回值)要比其父类更严格。

#### 四、接口隔离原则：
<p>     接口隔离原则也叫做接口最小化原则，指的是一个接口拥有的行为应该尽可能的最小

#### 五、依赖倒置原则：
<p>      这个原则描述的是高层模块不该依赖于低层模块，两个模块都应该依赖依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。因为实现都是易变的，只有抽象是稳定的，所以当我们依赖于抽象是，实现的变化就不会影响客户端的调用

#### 六、迪米特原则：
 <p>    迪米特原则也称最小知道原则，就是一个类尽量不应该知道(包括)其他类太多的东西，不要和其他类有太多的交集。该原则的制定的终极目的就是解耦，即将细节全部高内聚于类的内部，其他的类只需知道这个类主要提供的功能就OK了，减少不必要的依赖，高聚合低耦合

###三大类总纲设计模式分别有那些具体的设计模式？

####A：创建型模式

<p>创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
<p>它包括以下几种具体的设计模式：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式

####B：结构型模式

<p>结构型模式设计，它关注类和对象的组合。继承这一概念被用来组合接口和定义组合对象获得新功能的方式。
<p>它包括以下几种具体的设计模式：适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式

####C：行为型模式

<p>行为型模式设计，更关注对象与对象之间的通信。它包括以下几种具体的设计模式：
<p>责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、空对象模式、策略模式、模板模式、访问者模式


### 设计模式

#### 1 策略模式
<p> 用于处理不同情况 不同的应变处理 
<p> 举例: 线程池的拒绝策略 是应用了策略模式, 不同策略不同处理
<p> 可以和工厂模式一起 使用，解决多层if else的情况

#### 2 工厂模式 
<p>2.1 简单工厂模式
<p>根据传入的参数，动态决定应该创建哪一个产品类
<p>举例: Spring中的BeanFactory就是简单 工厂的应用

<p>2.2 工厂方法模式
<p> 创建对象的接口 让子类自己决定实例化哪一个类
<p> 在大话设计模式中 例子雷锋工厂 通过调用方自己去实例相应实例

#### 3 代理模式
<p> 用途: 某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。
<p> 作用:起到了隔离作用 增强了开闭原则
<p> 举例： spring的aop 
<p> 3.1 静态代理
<p> 通过生成代理类和 共同父类 关联关系 实现 静态代理
<p> 3.2 动态代理
<p> java中的动态代理一般有jdk和cglib   代码如下:
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/proxy">  code</a>     
<p> 他们主要区别在 jdk的需要提供接口  cglib 不需要提供接口    
<p> 他们实现原理都是通过字节码生成一个新的 代理类  不同的是jdk 生成的 类会 implements 传入的接口 所以jdk方式需要接口
<p> 而cglib 通过asm 也是生成一个新的代理类 但实现的传过来的类 修改子类的代码来实现的

#### 4 装饰模式   
<p>装饰器模式是继承的一种替代模式，其优点是可以动态扩展一个实现类的功能。这种设计模式下不仅可以扩展一个类的功能，
<p>也可以动态增加功能，动态撤销。但缺点就是多层装饰使用起来相对比较复杂。本质是将具体功能职责划分（例如区分核心组件以及附加属性职责）减少子类直接继承父类的耦合性
<p>增加附加功能 如加密解密, 多个装饰之间 最好独立 没有关系
                           
#### 5 原型模式
<p> 最直接的理解就是 复制原型对象的方法来创建对象的新实例
<p> java中的 克隆
<p> 1 实现 Cloneable 接口  这是个标记接口 没有实际方法  但要标记该对象能clone
<p> 2 重写clone 方法  object.clone() 是protected的
<p> java 中的浅克隆和深克隆
<p>  浅拷贝：被复制对象的所有值属性都含有与原来对象的相同，而所有的对象引用属性仍然指向原来的对象。
<p>  深拷贝：在浅拷贝的基础上，所有引用其他对象的变量也进行了clone，并指向被复制过的新对象。
<p> java 中克隆对象的其他实现
<p> 1 序列化 2 BeanUtils （commons和spring 都有） 3 cglib (默认是浅克隆 但能扩展) 4 其他框架


#### 6 模板方法模式
<p>  模板方法模式，定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
<p> 1）模板方法模式的优点
<p> ①模板方法模式通过把不变的行为搬移到父类，去除了子类中的重复代码。 
<p> ②子类实现算法的某些细节，有助于算法的扩展。 
<p> ③通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。
<p> （2）模板方法模式的缺点
<p> 按照设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类负责完成具体的事务属性和方法，但是模板方式正好相反，子类执行的结果影响了父类的结果，会增加代码阅读的难度。
<p> （3）模板方法模式适合的场景
<p> ①多个子类有共有的方法，并且逻辑基本相同。 
<p> ②重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 
<p> ③重构时，模板方法是一个经常使用的方法，把相同的代码抽取到父类中，然后通过构造函数约束其行为。


#### 7 外观模式
<p>为子系统中的一组接口提供一个一致的界面，用来访问子系统中的一群接口
<p> 优点：
<p>    　　1、实现了子系统与客户端之间的松耦合关系；
<p>    　　2、客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。
<p>缺点：
<p>    　　1、不符合开闭原则，如果要修改某一个子系统的功能，通常外观类也要一起修改；
<p>    　　2、没有办法直接阻止外部不通过外观类访问子系统的功能，因为子系统类中的功能必须是公开的（根据需要决定是否使用internal访问级别可解决这个缺点，但外观类需要和子系统类在同一个程序集内）

