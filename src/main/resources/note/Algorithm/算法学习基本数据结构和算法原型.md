# 数据结构
##  二叉树
### 树 二叉树
#### 树 定义
<p>“树”这种数据结构真的很像我们现实生活中的“树”，这里面每个元素我们叫作“节点”；
<p>用来连线相邻节点之间的关系，我们叫作“父子关系”

#### 树的其他概念
<p> 高度（Height）、深度（Depth）、层（Level）
<p> 高度=根节点到叶子节点最长边长
<p> 深度=根节点到这个节点经历的个数
<p> 层数=深度+1
 
#### 二叉树 定义
<p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。
<p>不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点

### 二叉树练习
   + 1 实现二叉树的先序、中序、后序遍历，包括递归方式和非递归方式
       <p> 先序遍历: 先打印父节点，之后打印左子节点 最后 右子节点
       <p> 中序遍历: 先打印左子节点 之后打印父节点 最后右子节点
       <p> 后序遍历: 先打印左子节点,之后打印左子节点，最后父节点
       <p>思路: 
       <p>1 递归
       <p> 在递归遍历中 因为使用栈的原因 每一个节点都会访问三次 前序在第一次 中序在第二次 后序在第三次
       <p> 2 非递归
       <p> 用栈模拟 递归压栈 出栈   
       <p> 3 Morris遍历(..)
       <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_01_PreInPosTraversal.java">code</a>
   + 2 如何直观的打印一颗二叉树
        <p> 题外： 在有前序和中序的时候 是能逆推出一颗树的 :
        <p>  这种树还原要么节点值都不一样 要么数组传入的是原树的节点对象 （思路是前序第一个一定是首节点,在中序中他左边的一定是他的左节点 右边的一定是他的右节点  递归一定能拿到颗正确的二叉树
        <p>    <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/offer/前序遍历和中序推出二叉树.java">前序和中序逆推二叉树code</a>
        <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_02_PrintBinaryTree.java">左神打印二叉树code</a>
   + 3 在二叉树中找到一个节点的后继节点
         <p>【题目】 现在有一种新的二叉树节点类型如下：
            <pre><code> 
            public class Node { 
              public int value;
              public Node left;
              public Node right; 
              public Node parent;
              public Node(int data) { this.value = data; }
            }
        </code></pre>
      <p>该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假
      <p>设有一 棵Node类型的节点组成的二叉树，树中每个节点的parent指针
      <p>都正确地指向 自己的父节点，头节点的parent指向null。
      <p>只给一个在二叉树中的某个节点 node，请实现返回node的后继节点的函数。
      <p>在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点
      <p> 概念: 在中序中 该节点前一个输出的节点叫他的前驱节点 后一个叫后继节点
      <p> 思路: 寻找一个节点的后继节点
      <p>  1.一个节点如果有右子子树 右子树的最左节点就是他的后继 
      <p>  2. 一个节点如果没有右子树 找想上父节点找 该节点是父节点的左子树 是父节点是他的后继 不是继续想上 直到root上不是 没有后继
      <p> 前驱逻辑相反 
      <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_03_SuccessorNode.java">找后继code</a>

   + 4 介绍二叉树的序列化和反序列化
       <p> 1. 每个节点用!隔开,空节点用#表示
       <p> 2. 
       <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_04_SerializeAndReconstructTree.java">code</a>
   + 6 判断一棵二叉树是否是平衡二叉树
        <p> 平衡二叉树的严格定义
        <p> 左子树和右子树高度差不大于1
        <p> 思路: 左子树不是平衡树 整棵树一定不是 右子同理 ，左子和右子都是 他们高度差大于1 不是
        <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_06_IsBalancedTree.java">code</a>

   + 7 判断一棵树是否是搜索二叉树、判断一棵树是否是完全二叉树
        <p>  搜索二叉树 左子节点比父节点小 右子节点比父节点大 一般不包含重复的节点（重复节点可放在同一节点）
        <p> 判断是否是搜索二叉树  中序遍历  值一定是递增的
        <p>  判断时候是完全二叉树 
        <p>1. 有右子节点 无左子树 一定不是
        <p>2. 有左子树 无右子树  接下来所有节点必须是叶子节点 才是完全二叉树
        <p> 注: 深度遍历用栈 广度用队列
   + 8 已知一棵完全二叉树，求其节点的个数
      <p>要求：时间复杂度低于O(N)，N为这棵树的节点个数    
      <p> 思路：1. 直接遍历  时间复杂度时O(n)
      <p> 2. 满二叉树的节点个数是= (1<< 高度)-1   能把一个二叉树 拆分成左子树 和右子树，
      <p> 在右子树的最左节点存在时 左子树一定是一个满二叉树 ，当最左节点高度比左子树小 右子树一定是一个 高度减1的满二叉树 O(Log N)^2
      <p>   <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_08_CompleteTreeNodeNumber.java">code</a>
 
###  Hash 算法和散列表
#### Hash 算法
<p> Hash码 --由Hash算法(MD5、SHA 等) 计算出来的十六进制的数字

##### 经典Hash函数性质：
<p>1. 输入域是无穷大的
<p>2. 输出是有范围的
<p>3. 在输入一样时 输出是一样的
<p>4. 在输入不一样是,输出也有可能一样（就是hash碰撞 1,2,3 会导致hash碰撞）
<p>5. 在大量输入的时候,得到的相对应的值是均匀分布在 输出范围内的 叫离散型( 在实际应用中很重要的特性，如负载均衡，分片)

##### Hash函数特性：
<p>1. 输入和输出是没有关系的
<p>2. 因为在输出域上均匀分布,得到推论: 一组数据得到的Hash码%m,在0~m-1上也是均匀分布的
<p>3.Hash 码的每一位是相对独立的 彼此关系不大

##### 应用
<p>1.安全加密
<p>2.唯一标识
<p>3.数据校验
<p>4.散列函数
<p>5.负载均衡
<p>6.数据分片
<p>7.分布式存储

<p> Hash 分流案例：
<p> 如一个10T文件 内容是有一行一个字符串  可能有重复  找出重复的
<p>思路: 1 分布式处理  把字符hash 通过hash的均匀分布特性 
<p>2. %机器台数得到位置 （hash的1，2）保证相同的数据 能放在同一台机器上 
<p>3. 每台机器可以多线程或单线程处理 属于自己的数据

#### Hash 表
##### 经典Hash表实现 （java 实现在8中加入了红黑树）
<p>1. 生成数组 得到大小len
<p>2. put 时获取key的hashcode  然后 %len 得到他属于数组的位置
<p>3. 数组里面存链表,检查对应位置 下是否有当前key的节点，有更新，无，链在链表后面
<p>4. 如果链表长度到达 阈值，因为hash算法的特性 均匀分布，所以数组其他其他位置类似，此时扩容
<p>5. 扩容 重新调整数组大小，从新hash，分配（在java中 扩容是<<1 所以实际只有一半需要从新分配 具体可以看HashMap的笔记）
<p> 离线扩容: 在离线时扩容, 扩容完成替换 

#### 布隆过滤器
<p> 主要用于去重或黑名单
<p> bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
<p>  和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。
<p>  算法：
<p> 1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
<p> 2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
<p>  3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
<p>  4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。
<p>  优点：不需要存储key，节省空间
<p>  缺点：
<p>  1. 算法判断key在集合中时，有一定的概率key其实不在集合中
<p>  2. 无法删除
  

+ 一个bit数组实现        
    <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic05/BitArray.java">  code</a>                                               


#### 一致性哈希
##### 经典设计负载均衡
<p> 站点层 通过负载均衡 （这里只hash）,访问服务层集群 拿到数据
<p> 问题: 在加机器减机器时会很麻烦

##### 一致性哈希
<p> 在保证负载均衡的同时 把机器迁移代价从全量变成增量
 
 [一致性Hash算法及实现](https://blog.csdn.net/suifeng629/article/details/81567777)
<p> 解决了服务器增减 产生的 负载均衡问题
<h5>  hash 环
<p>一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形） 服务ip 放在上面
<h5> 数据存放
<p> 对数据(之前写错了  在一致性Hash中没有取摸的操作 2^32 取模 虽然不算错但是不准确) 得到值 在Hash环上顺时针找到服务器节点(逻辑是hash环  实现数据结构应该是有序数组 用二分查找 -可以用TreeMap 直接tailMap() 大于的 第一个就是需要的节点)
<h5>  如果服务器节点过少 会有负载不均衡的问题（这是hash算法 决定的）
<p>  解决办法 ：虚拟节点 （生成路由表 虚拟现实对照 虚拟放在hash环  维持负载均衡）
    
#### Hash 练习题
+ 设计RandomPool结构
<p>   【题目】 设计一种结构，在该结构中有如下三个功能：
<p>   insert(key)：将某个key加入到该结构，做到不重复加入。
<p>  delete(key)：将原本在结构中的某个key移除。 getRandom()：
<p>   等概率随机返回结构中的任何一个key。
<p>   【要求】 Insert、delete和getRandom方法的时间复杂度都是 O(1)
<p> 思路：用两个map 一个记录key，index  一个记录index,key  存取,随机都是O(1)
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic05/Code_02_RandomPool.java">  code</a>                                               
 

### 并查集 
<p> 功能：
<p> 1. 快速查询两个元素 是否属于一个集合
<p> 2. 两个元素各自在自己的集合 合并在一起
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic05/Code_04_UnionFind.java">  code</a>                                               
 


  