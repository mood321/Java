# 数据结构
##  二叉树
### 树 二叉树
#### 树 定义
<p>“树”这种数据结构真的很像我们现实生活中的“树”，这里面每个元素我们叫作“节点”；
<p>用来连线相邻节点之间的关系，我们叫作“父子关系”

#### 树的其他概念
<p> 高度（Height）、深度（Depth）、层（Level）
<p> 高度=根节点到叶子节点最长边长
<p> 深度=根节点到这个节点经历的个数
<p> 层数=深度+1
 
#### 二叉树 定义
<p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。
<p>不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点

### 二叉树练习
   + 1 实现二叉树的先序、中序、后序遍历，包括递归方式和非递归方式
       <p> 先序遍历: 先打印父节点，之后打印左子节点 最后 右子节点
       <p> 中序遍历: 先打印左子节点 之后打印父节点 最后右子节点
       <p> 后序遍历: 先打印左子节点,之后打印左子节点，最后父节点
       <p>思路: 
       <p>1 递归
       <p> 在递归遍历中 因为使用栈的原因 每一个节点都会访问三次 前序在第一次 中序在第二次 后序在第三次
       <p> 2 非递归
       <p> 用栈模拟 递归压栈 出栈   
       <p> 3 Morris遍历(..)
       <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_01_PreInPosTraversal.java">code</a>
   + 2 如何直观的打印一颗二叉树
        <p> 题外： 在有前序和中序的时候 是能逆推出一颗树的 :
        <p>  这种树还原要么节点值都不一样 要么数组传入的是原树的节点对象 （思路是前序第一个一定是首节点,在中序中他左边的一定是他的左节点 右边的一定是他的右节点  递归一定能拿到颗正确的二叉树
        <p>    <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/offer/前序遍历和中序推出二叉树.java">前序和中序逆推二叉树code</a>
        <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_02_PrintBinaryTree.java">左神打印二叉树code</a>
   + 3 在二叉树中找到一个节点的后继节点
         <p>【题目】 现在有一种新的二叉树节点类型如下：
            <pre><code> 
            public class Node { 
              public int value;
              public Node left;
              public Node right; 
              public Node parent;
              public Node(int data) { this.value = data; }
            }
        </code></pre>
      <p>该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假
      <p>设有一 棵Node类型的节点组成的二叉树，树中每个节点的parent指针
      <p>都正确地指向 自己的父节点，头节点的parent指向null。
      <p>只给一个在二叉树中的某个节点 node，请实现返回node的后继节点的函数。
      <p>在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点
      <p> 概念: 在中序中 该节点前一个输出的节点叫他的前驱节点 后一个叫后继节点
      <p> 思路: 寻找一个节点的后继节点
      <p>  1.一个节点如果有右子子树 右子树的最左节点就是他的后继 
      <p>  2. 一个节点如果没有右子树 找想上父节点找 该节点是父节点的左子树 是父节点是他的后继 不是继续想上 直到root上不是 没有后继
      <p> 前驱逻辑相反 
      <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_03_SuccessorNode.java">找后继code</a>

   + 4 介绍二叉树的序列化和反序列化
       <p> 1. 每个节点用!隔开,空节点用#表示
       <p> 2. 
       <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_04_SerializeAndReconstructTree.java">code</a>
   + 6 判断一棵二叉树是否是平衡二叉树
        <p> 平衡二叉树的严格定义
        <p> 左子树和右子树高度差不大于1
        <p> 思路: 左子树不是平衡树 整棵树一定不是 右子同理 ，左子和右子都是 他们高度差大于1 不是
        <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_06_IsBalancedTree.java">code</a>

   + 7 判断一棵树是否是搜索二叉树、判断一棵树是否是完全二叉树
        <p>  搜索二叉树 左子节点比父节点小 右子节点比父节点大 一般不包含重复的节点（重复节点可放在同一节点）
        <p> 判断是否是搜索二叉树  中序遍历  值一定是递增的
        <p>  判断时候是完全二叉树 
        <p>1. 有右子节点 无左子树 一定不是
        <p>2. 有左子树 无右子树  接下来所有节点必须是叶子节点 才是完全二叉树
        <p> 注: 深度遍历用栈 广度用队列
        
###  