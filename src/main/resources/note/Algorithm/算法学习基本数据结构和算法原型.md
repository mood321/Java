# 数据结构
##  二叉树
### 树 二叉树
#### 树 定义
<p>“树”这种数据结构真的很像我们现实生活中的“树”，这里面每个元素我们叫作“节点”；
<p>用来连线相邻节点之间的关系，我们叫作“父子关系”

#### 树的其他概念
<p> 高度（Height）、深度（Depth）、层（Level）
<p> 高度=根节点到叶子节点最长边长
<p> 深度=根节点到这个节点经历的个数
<p> 层数=深度+1
 
#### 二叉树 定义
<p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。
<p>不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点

### 二叉树练习
   + 1 实现二叉树的先序、中序、后序遍历，包括递归方式和非递归方式
       <p> 先序遍历: 先打印父节点，之后打印左子节点 最后 右子节点
       <p> 中序遍历: 先打印左子节点 之后打印父节点 最后右子节点
       <p> 后序遍历: 先打印左子节点,之后打印左子节点，最后父节点
       <p>思路: 
       <p>1 递归
       <p> 在递归遍历中 因为使用栈的原因 每一个节点都会访问三次 前序在第一次 中序在第二次 后序在第三次
       <p> 2 非递归
       <p> 用栈模拟 递归压栈 出栈   
       <p> 3 Morris遍历(..)
       <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_01_PreInPosTraversal.java">code</a>
   + 2 如何直观的打印一颗二叉树
        <p> 题外： 在有前序和中序的时候 是能逆推出一颗树的 :
        <p>  这种树还原要么节点值都不一样 要么数组传入的是原树的节点对象 （思路是前序第一个一定是首节点,在中序中他左边的一定是他的左节点 右边的一定是他的右节点  递归一定能拿到颗正确的二叉树
        <p>    <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/offer/前序遍历和中序推出二叉树.java">前序和中序逆推二叉树code</a>
        <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_02_PrintBinaryTree.java">左神打印二叉树code</a>
   + 3 在二叉树中找到一个节点的后继节点
         <p>【题目】 现在有一种新的二叉树节点类型如下：
            <pre><code> 
            public class Node { 
              public int value;
              public Node left;
              public Node right; 
              public Node parent;
              public Node(int data) { this.value = data; }
            }
        </code></pre>
      <p>该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假
      <p>设有一 棵Node类型的节点组成的二叉树，树中每个节点的parent指针
      <p>都正确地指向 自己的父节点，头节点的parent指向null。
      <p>只给一个在二叉树中的某个节点 node，请实现返回node的后继节点的函数。
      <p>在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点
      <p> 概念: 在中序中 该节点前一个输出的节点叫他的前驱节点 后一个叫后继节点
      <p> 思路: 寻找一个节点的后继节点
      <p>  1.一个节点如果有右子子树 右子树的最左节点就是他的后继 
      <p>  2. 一个节点如果没有右子树 找想上父节点找 该节点是父节点的左子树 是父节点是他的后继 不是继续想上 直到root上不是 没有后继
      <p> 前驱逻辑相反 
      <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_03_SuccessorNode.java">找后继code</a>

   + 4 介绍二叉树的序列化和反序列化
       <p> 1. 每个节点用!隔开,空节点用#表示
       <p> 2. 
       <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_04_SerializeAndReconstructTree.java">code</a>
   + 6 判断一棵二叉树是否是平衡二叉树
        <p> 平衡二叉树的严格定义
        <p> 左子树和右子树高度差不大于1
        <p> 思路: 左子树不是平衡树 整棵树一定不是 右子同理 ，左子和右子都是 他们高度差大于1 不是
        <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_06_IsBalancedTree.java">code</a>

   + 7 判断一棵树是否是搜索二叉树、判断一棵树是否是完全二叉树
        <p>  搜索二叉树 左子节点比父节点小 右子节点比父节点大 一般不包含重复的节点（重复节点可放在同一节点）
        <p> 判断是否是搜索二叉树  中序遍历  值一定是递增的
        <p>  判断时候是完全二叉树 
        <p>1. 有右子节点 无左子树 一定不是
        <p>2. 有左子树 无右子树  接下来所有节点必须是叶子节点 才是完全二叉树
        <p> 注: 深度遍历用栈 广度用队列
   + 8 已知一棵完全二叉树，求其节点的个数
      <p>要求：时间复杂度低于O(N)，N为这棵树的节点个数    
      <p> 思路：1. 直接遍历  时间复杂度时O(n)
      <p> 2. 满二叉树的节点个数是= (1<< 高度)-1   能把一个二叉树 拆分成左子树 和右子树，
      <p> 在右子树的最左节点存在时 左子树一定是一个满二叉树 ，当最左节点高度比左子树小 右子树一定是一个 高度减1的满二叉树 O(Log N)^2
      <p>   <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic04/Code_08_CompleteTreeNodeNumber.java">code</a>
 
###  Hash 算法和散列表
#### Hash 算法
<p> Hash码 --由Hash算法(MD5、SHA 等) 计算出来的十六进制的数字

##### 经典Hash函数性质：
<p>1. 输入域是无穷大的
<p>2. 输出是有范围的
<p>3. 在输入一样时 输出是一样的
<p>4. 在输入不一样是,输出也有可能一样（就是hash碰撞 1,2,3 会导致hash碰撞）
<p>5. 在大量输入的时候,得到的相对应的值是均匀分布在 输出范围内的 叫离散型( 在实际应用中很重要的特性，如负载均衡，分片)

##### Hash函数特性：
<p>1. 输入和输出是没有关系的
<p>2. 因为在输出域上均匀分布,得到推论: 一组数据得到的Hash码%m,在0~m-1上也是均匀分布的
<p>3.Hash 码的每一位是相对独立的 彼此关系不大

##### 应用
<p>1.安全加密
<p>2.唯一标识
<p>3.数据校验
<p>4.散列函数
<p>5.负载均衡
<p>6.数据分片
<p>7.分布式存储

<p> Hash 分流案例：
<p> 如一个10T文件 内容是有一行一个字符串  可能有重复  找出重复的
<p>思路: 1 分布式处理  把字符hash 通过hash的均匀分布特性 
<p>2. %机器台数得到位置 （hash的1，2）保证相同的数据 能放在同一台机器上 
<p>3. 每台机器可以多线程或单线程处理 属于自己的数据

#### Hash 表
##### 经典Hash表实现 （java 实现在8中加入了红黑树）
<p>1. 生成数组 得到大小len
<p>2. put 时获取key的hashcode  然后 %len 得到他属于数组的位置
<p>3. 数组里面存链表,检查对应位置 下是否有当前key的节点，有更新，无，链在链表后面
<p>4. 如果链表长度到达 阈值，因为hash算法的特性 均匀分布，所以数组其他其他位置类似，此时扩容
<p>5. 扩容 重新调整数组大小，从新hash，分配（在java中 扩容是<<1 所以实际只有一半需要从新分配 具体可以看HashMap的笔记）
<p> 离线扩容: 在离线时扩容, 扩容完成替换 

#### 布隆过滤器
<p> 主要用于去重或黑名单
<p> bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
<p>  和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。
<p>  算法：
<p> 1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
<p> 2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
<p>  3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
<p>  4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。
<p>  优点：不需要存储key，节省空间
<p>  缺点：
<p>  1. 算法判断key在集合中时，有一定的概率key其实不在集合中
<p>  2. 无法删除
  

+ 一个bit数组实现        
    <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic05/BitArray.java">  code</a>                                               


#### 一致性哈希
##### 经典设计负载均衡
<p> 站点层 通过负载均衡 （这里只hash）,访问服务层集群 拿到数据
<p> 问题: 在加机器减机器时会很麻烦

##### 一致性哈希
<p> 在保证负载均衡的同时 把机器迁移代价从全量变成增量
 
 [一致性Hash算法及实现](https://blog.csdn.net/suifeng629/article/details/81567777)
<p> 解决了服务器增减 产生的 负载均衡问题
<h5>  hash 环
<p>一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形） 服务ip 放在上面
<h5> 数据存放
<p> 对数据(之前写错了  在一致性Hash中没有取摸的操作 2^32 取模 虽然不算错但是不准确) 得到值 在Hash环上顺时针找到服务器节点(逻辑是hash环  实现数据结构应该是有序数组 用二分查找 -可以用TreeMap 直接tailMap() 大于的 第一个就是需要的节点)
<h5>  如果服务器节点过少 会有负载不均衡的问题（这是hash算法 决定的）
<p>  解决办法 ：虚拟节点 （生成路由表 虚拟现实对照 虚拟放在hash环  维持负载均衡）
    
#### Hash 练习题
+ 设计RandomPool结构
<p>   【题目】 设计一种结构，在该结构中有如下三个功能：
<p>   insert(key)：将某个key加入到该结构，做到不重复加入。
<p>  delete(key)：将原本在结构中的某个key移除。 getRandom()：
<p>   等概率随机返回结构中的任何一个key。
<p>   【要求】 Insert、delete和getRandom方法的时间复杂度都是 O(1)
<p> 思路：用两个map 一个记录key，index  一个记录index,key  存取,随机都是O(1)
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic05/Code_02_RandomPool.java">  code</a>                                               
 

### 并查集 
<p> 功能：
<p> 1. 快速查询两个元素 是否属于一个集合
<p> 2. 两个元素各自在自己的集合 合并在一起
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic05/Code_04_UnionFind.java">  code</a>                                               
 
#### 并查集应用
<p>岛问题
<p>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右
<p>四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个
<p>矩阵中有多少个岛？
<p>举例：
<p>0 0 1 0 1 0
<p>1 1 1 0 1 0
<p>1 0 0 1 0 0
<p>0 0 0 0 0 0
<p>这个矩阵中有三个岛。
<p> 思路：
<p>     如果当前节点是1 把他相邻的1 和本身全部变成2 (表示是同一个岛) 下次遇到2 就可以跳过
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic05/Code_03_Islands.java">  code</a>                                               
<p> 进阶: 如果多线程或者分布式服务器怎么处理
<p>思路: 拆分任务  然后用上面处理  但这里多了合并结果的操作 所以要记录边界的岛（这里用并查集,可以处理相交问题很简单） 

### 前缀树
<p> 是一颗根据内容元素生成链在首节点的一颗多叉树 位置相同元素相同合并
<p> 扩展:
<p>1. 在元素中记录 有几个是以当前节点作为尾节点的个数
<p>作用: 可以知道当前节点是否是一个串的结束
<p>2. 在元素中记录有几个是包含当前节点的
<p>作用: 便于查找 以这个节点做前缀的个数

### 贪心算法 （经典题）
<p> 1 .     一块金条切成两半，是需要花费和长度数值一样的铜板的。比如
<p>  长度为20的 金条，不管切成长度多大的两半，都要花费20个铜板。
<p>  一群人想整分整块金 条，怎么分最省铜板？
<p>  例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为
<p>  10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长
<p>  度60的金条分成10和50，花费60 再把长度50的金条分成20和30，
<p>  花费50 一共花费110铜板。
<p>  但是如果， 先把长度60的金条分成30和30，花费60 再把长度30
<p>  金条分成10和20，花费30 一共花费90铜板。
<p>  输入一个数组，返回分割的最小代价。
<p> 思路：贪心策略-先拿出两两最小（哈夫曼编码的问题） （用堆实现）
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic07/Code_02_Less_Money.java">  code</a>                                               

<p> 2. 一个项目有收入 有支出  现在有本金  求怎么做项目赚的多 
<p>输入： 参数1，正数数组costs 参数2，正数数组profits 参数3，
<p>   正数k 参数4，正数m
<p>  costs[i]表示i号项目的花费 profits[i]表示i号项目在扣除花
<p>   费之后还能挣到的钱(利润) k表示你不能并行、只能串行的最多
<p>   做k个项目 m表示你初始的资金
<p>   说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个 项目。
<p>  输出： 你最后获得的最大钱数。  
<p> 思路: 正常逻辑 在本金允许下 优先选择利润最高的项目去做
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic07/Code_03_IPO.java">  code</a>                                               


<p> 3.一个数据流中，随时可以取得中位数
<p> 思路: 1.排序(X) 不支持数据流
<p>  2. 借用堆排序的思路   得到最大 与最小
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic07/Code_04_MadianQuick.java">  code</a>                                               


<p> 4.给定一个字符串类型的数组strs，找到一种拼接方式，使得把所
<p>有字 符串拼起来之后形成的字符串具有最低的字典序。
<p>思路:1. 贪心 -按数字的逻辑  高位上数值越小 拼接值越小
<p> 2. 在字符中 得到字典序 也可以先排序  然后小的在前
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic07/Code_05_LowestLexicography.java">  code</a>                                               

 
 
<p> 5. 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目
<p>       的宣讲。 给你每一个项目开始的时间和结束的时间(给你一个数
<p>       组，里面 是一个个具体的项目)，你来安排宣讲的日程，要求会
<p>       议室进行 的宣讲的场次最多。返回这个最多的宣讲场次
<p> 思路:  先找到最早结束的 此时开始时间小于结束时间的不能用 找下一个最早结束的
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic07/Code_06_BestArrange.java">  code</a>                                               


### 递归

<p>1 求!n 的值
<p> 思路：怎么试出来结果
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic08/Code_01_Factorial.java">  code</a>                                               

<p>2. 汉诺塔问题
<p> 思路: 1 非递归用栈 弹出 2 递归
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic08/Code_02_Hanoi.java">  code</a>                                               

<p>3. 求一个字符串的子序列
<p> ps: 子序列和子串的关系 - 子串在元字符的顺序是原顺序 - 子序列 不要求原顺序
<p> 思路: 按规则递归 
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic08/Code_03_Print_All_Subsquences.java">  code</a>                                               

<p> 4 母牛的问题 有一头母牛  三年后生一只母牛  每年生  这只母牛三年后又可以生小牛 牛不会死 N年后 有多少牛
<p>  思路: 计算N年的牛  N-1的牛不会死 f(n-1)  +  三年钱生产的牛 f(n-3)
 <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic08/Code_05_Cow.java">  code</a>                                               

####  递归 改动态规划
<p> 1.   一个二位数组 数组值都是正数  要求从左上走到右下  每一步只能 向右  向下 经过数字要求最小 返回最小
<p> 思路: 穷举  每一条路 递归
<p> 引发的问题 
<table>
       <tr>
           <td></td>
           <td>0</td>
           <td>1</td>
           <td>2</td>
           <td>3</td>
           <td>4</td>
       </tr>
       <tr>
           <td>0</td>
           <td>1</td>
           <td>A(0,1)</td>
           <td></td>
           <td></td>
           <td></td>
       </tr>
       <tr>
           <td>1</td>
           <td>A(1,0)</td>
           <td>A(1,1)</td>
           <td></td>
           <td></td>
           <td></td>
       </tr>
       <tr>
           <td>2</td>
           <td></td>
           <td></td>
           <td></td>
           <td></td>
           <td></td>
       </tr>
       <tr>
           <td>3</td>
           <td></td>
           <td></td>
           <td></td>
           <td></td>
           <td></td>
       </tr>
</table>
<p>1. 在案例中 A(1,1) 的值一定依赖A(1,0)和A(0,1)  而且他本身的值是不受 是怎么来到这个点上的的影响
<p> 他本身的最短 只受 A(0,1)和A(1,0)的影响 (参数固定 返回一定固定) 这种叫做无后效性问题
<p>2. 在汉诺塔问题中(N皇后) 之前的选择会影响 之后的选择   这叫有后效性问题
 <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic08/Code_07_MinPath.java">  code</a>                                               

<p> 2.  给一个数组 arr 和一个数arm   用任意数组的数 能否相加得到arm  T/F
<p> 思路: 无脑递归
 <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic08/Code_08_Money_Problem.java">  code</a>                                               


<p> 3 背包问题 背包有n种商品 商品有价格 有重量  在限定的总重量内，我们如何选择，才能使得物品的总价格最高
<p> 思路: 思路还是推测递归 当重量超过 返回  商品用完 返回    决策 价格最高为解
 <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic08/Code_09_Knapsack.java">  code</a>                                               

### 图  
<p> 时间不太够  没找到太好的系统的  暂停

<p> 1 图的存储方式
<p>       1）邻接表
<p>       2）邻接矩阵
<p>      如何表达图？生成图？

<p> 2     宽度优先遍历 1，利用队列实现 2，从源节点开始依次按照宽
<p>          度进队列，然后弹出 3，每弹出一个点，把该节点所有没有进
<p>          过队列的邻接点放入队 列 4，直到队列变空
<p>    广度优先遍历 1，利用栈实现 2，从源节点开始把节点按照深
<p>          度放入栈，然后弹出 3，每弹出一个点，把该节点下一个没有
<p>          进过栈的邻接点放入栈 4，直到栈变空

<p> 3 .拓扑排序算法 适用范围：要求有向图，且有入度为0的节点，且没有环

<p> 4.  kruskal算法 适用范围：要求无向图

<p> 5. prim算法 适用范围：要求无向图
<p> 6. Dijkstra算法 适用范围：没有权值为负数的边


## 进阶
### KMP 算法
<p>  原型用于 查找字符st1中是否有和领一个字符串(st2)一样的子串 
<p> java中String.indexOf(String s) 类似  但java 中是暴力  应该是kmp 更擅长 特殊字符 本身有很多重复 字符不长的情况 更耗时
<p> 暴力方式:  st1从0 开始 依次和st2 比对  ，不同退回到1 重新开始比对 复杂度是O(M*N)
<p> 问题是 每次上次计算内容不可重用

<p> KMP 的重点在 最长前缀和最长后缀
<img src="https://s2.ax1x.com/2019/11/14/MYrx3D.jpg" alt="MYrx3D.jpg" border="0" />
<p>  他每次节省了最长后缀前面这一串子串的重复计算
<p> 最长前缀的算法  
<p>得到的是 int next[]  里面存着对应下标字符的最长前缀长度  ,原字符数组记为 char str[]
<p> i=0 位置是-1  i=1前面只有0 即为0  (从0->..  复杂度O(M))
<p> 当i>1  流程 :
<p> 1 拿到next[i-1]的值 i-1的最长前缀 记为cur  看str[cur] 与str[i] 是否相等
<p> 2 相等 next[i]等于 next[i]+1  结束
<p> 3 不相等 来到next[next[i]] 记最长前缀所在的字符的位置 记为cur 拿到cur的最长前缀  流程和1,2 一致
<p> 4 如果一直不等  来到0位置  那next[i]=0

<p> KMP 算法流程
<p>1   判断s1中m1  所在元素 和  s2 中m2 是否相等 
<p>2    相同 都后移
<p>3     不相等 s2 中m2 在0位置   s1 后移
<p>4   不相等  s2中m2 不在0位置  因为最长前缀和后缀相等  所以此时 s1 中m1 前面字符一定和 s2的m2的最长前缀相等
<p>  调整让m2来到 最长前缀的位置  继续while 

<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/advanced01/KMP.java">  code</a>                                               

### ManaChar 算法
<p> 作用: 用于找到 字符中找到最长回文子串
<p> 暴力方式： 字符开始和结束 以及字符之间 加上特殊字符  寻找每个字符的回文长度 拿出最长/2 得到结果
<p> 思路：
<p> 1 需要辅助数据  -- 数组 记录每个点最长回文半径 -- 已查询的字符回文到达最远的下标R -- 第一次到达R的圆心点
<p> 2 通过数组记录数据 减少暴力次数
<img src="https://s2.ax1x.com/2019/11/17/MsDmVK.jpg" alt="MsDmVK.jpg" border="0" />
<p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/advanced01/Manachar.java">  code</a>                                               


### BFPRT算法 
<p> 作用 ：找出第n大或者小的数
<p> 暴力思路: 排序 然后找出第n个数
<p> 暴力优化: 使用随机快排思路,但只用拍小的一半 或者打的一半
<p> BFPRT 算法: 
<p> 1.  把原数组拆分成 5（模数）个数组  数组之间无序
<p> 2.  找出每个数组的中位数    组成新的数组new_arr  
<p> 3.  递归调用函数 传入新的数组  和 他的中位数 new_arr.length/2   返回num
<p> 4.  num 一定是所有数的中位数 然后用快排的思路（暴力优化） 只拿大的或者小的
 <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/advanced01/TopK.java">  code</a>                                               


### 窗口 
<p> 窗口，其实就是一个队列；滑动窗口，就是将这个队列朝着一个方向滑动，也就是将先进入队列的元素移出，重新往队列中添加元素
<p> 问题及应用: 一个数组想窗口添加或移除 元素  都能取的这是的最大值  窗口大小为w  返回所有窗口的最大值
 <p> <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/advanced01/WindowMaxNun.java">  code</a>                                               


 
 



