## 部分算法学习笔记
### 基础知识
<a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/Conllection/SelectSort.java">常见排序算法</a>

<h4> 基础


   +  时间复杂度
    <p>一个算法流程中，常数操作数量的指标。常用O（读作big O）来表示。具体来说，在常数操作数量的表达式中，
    <p>只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分 如果记为f(N)，那么时间复杂度为O(f(N))
   + 对数器的概念和使用
     <p>0，有一个你想要测的方法a，
     <p> 1，实现一个绝对正确但是复杂度不好的方法b，
     <p> 2，实现一个随机样本产生器
     <p> 3，实现比对的方法
     <p> 4，把方法a和方法b比对很多次来验证方法a是否正确。
     <p> 5，如果有一个样本使得比对出错，打印样本分析是哪个方法出错
     <p> 6，当样本数量很多时比对测试依然正确，可以确定方法a已经 正确。
   + 冒泡排序细节的讲解与复杂度分析
     <p>时间复杂度O(N^2)，额外空间复杂度O(1)
   + 选择排序的细节讲解与复杂度分析
     <p>时间复杂度O(N^2)，额外空间复杂度O(1)
   + 插入排序的细节讲解与复杂度分析
     <p>时间复杂度O(N^2)，额外空间复杂度O(1)
   + 剖析递归行为和递归行为时间复杂度的估算
     <p>一个递归行为的例子
     <p> master公式的使用
     <p>T(N) = a*T(N/b) + O(N^d)
     <p>1) log(b,a) > d -> 复杂度为O(N^log(b,a))
     <p>2) log(b,a) = d -> 复杂度为O(N^d * logN)
     <p>3) log(b,a) < d -> 复杂度为O(N^d)
     <p>补充阅读：www.gocalf.com/blog/algorithm-complexity-and-master-theorem.html
   + 小和问题和逆序对问题
        <h4>小和问题
        <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic/Code_12_SmallSum.java">小和算法code</a>
        <p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
        <p>例子：
        <p>[1,3,4,2,5]
        <p>1左边比1小的数，没有；
        <p>3左边比3小的数，1；
        <p>4左边比4小的数，1、3；
        <p>2左边比2小的数，1；
        <p>5左边比5小的数，1、3、4、2；
        <p>所以小和为1+1+3+1+1+3+4+2=16
        <h4>逆序对问题
        <p>在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。
   + 归并排序的细节讲解与复杂度分析
     <p>时间复杂度O(N*logN)，额外空间复杂度O(N)
     <p> 思路:
     <p>1.还是分治拆分 分别排序 返回
     <p>2.得到中间点分开的两段数组 他们分别有序 对他们合并 保持有序
     <p>ps: 合并思路 , 从两段数组分别开始遍历比较 一个较小 放入辅助数组，下标++，继续计较 一段到终点另一段下标之后都加入辅助数组 辅助数组回填 完成
     <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/Conllection/SelectSort.java">常见排序算法-归并code</a>

   + 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。
     <p>要求额外空间复杂度O(1)，时间复杂度O(N)
     <p> 思路:
     <p> 给定限定值x 当前小于等于num的边界为-1（初始值） 循环数组 如果当前值小于等于num 与x+1交换值 x++  大于则进行下一次循环
     
      ![](https://ftp.bmp.ovh/imgs/2019/10/ab5f4d0a0efb81c2.jpg)
   + 问题二（荷兰国旗问题）
     <p>给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。
     <p>要求额外空间复杂度O(1)，时间复杂度O(N)
     <p> 思路: 
     <p> 1. 数组应该分成三部分 第一部分小于num 范围是0～less(less 默认-1 不存在 包含less)、 
     <p>    等于num的范围less+1～more-1 (more默认位置长度+1)
     <p>    大于num的范围more～数组长度（包含more）
     <p>2.流程:
     <p>2.1 在小于more的范围内遍历数组 用cur表示当前数下标
     <p>2.2 如果cur所在的值小于num  cur和less+1 交换 ,cur++
     <p>2.3 如果等于  cur++
     <p>2.4 如果大于 cur所在值与more-1的值交换 ，进行下一次循环
     
      ![](https://ftp.bmp.ovh/imgs/2019/10/8868a69a889295c5.jpg)
     [code](https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic/Code_08_NetherlandsFlag.java)
    
   + 快速排序
       <p> 时间复杂度O(N*logN)，额外空间复杂度O(logN)
       <p> 快速排序不能保证排序的稳定性
       <p> 随机快速排序解决了 快速排序受数据状况影响的问题
       
       - 随机快速排序的细节和复杂度分析
       - 可以用荷兰国旗问题来改进快速排序
       - [code](https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic/Code_04_QuickSort.java)
      
   + 堆排序
        - 堆的概念
            <p> java中优先队列都是用的堆
            <p>还不懂堆？看一看这篇文章【<a href="https://mp.weixin.qq.com/s/AF2tMHfofG8b51yIyaIReg">拜托，面试别再问我堆（排序）了！</a>】。</p>
        - 入堆（自下而上的堆化）
            <p> 1.把需要入堆的元素放在 heapsize+1 位置（最后一个节点）
            <p> 2.去和父节点比较大小 如大顶堆 比父节点大就交换 （父节点index= (子节点index-1) /2） 然后继续比较
            <p> code见heapInsert方法
        - 出堆（自上而下的堆化）（举例用大顶堆）
            <p> 1.头结点和最后一个节点交换 交换后最后一个节点是需要弹出的值 堆大小-1 
            <p> 2.继续堆化  此时顶点的数据 不一定是最大的 他需要和子节点大的比较 大于则不动 小于交换 
            <p> ps:（此处不是和每个节点比较 因为堆只要求父节点大于子节点 不要求左节点小于右节点）
            <p> 3.交换后 继续2的操作
            <p> code见 heapify()方法
            <p> 堆只有从顶点弹出的操作 不能从任意节点弹出 
        - 堆排序 用入堆,出堆的思想实现
            <p> 先堆化一个数组 堆化完成顶点一定一定是最大或最小
            <p> 弹出顶点 放在数组最后 数组堆的范围-1 
            <p> 此时顶点 还是最大或最小 继续操作 
            
        -  [code](https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic/Code_03_HeapSort.java)
   
   + 桶排序、计数排序、基数排序的介绍
        -  桶排序是一个逻辑概念 计数排序和基数排序是他具体 实现
        - 如果有问题 对一个数据范围在 0-60的数组排序 
        
        -  计数排序 用辅助空间思路：
            <p>1. 用一个辅助数组 长度为60的数组
            <p>2. 循环原数组  如果为1 辅助数组下标1的值+1  循环完毕
            <p>3. 依据辅助数组的值 重建数组
        - 基数排序 是对计数的优化 有点类似 分段 桶不是具体值  而是一个范围 然后对范围在分
     
        - 问题 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时
             间复杂度O(N)，且要求不能用非基于比较的排序
             <p> 思路： 找出最大的差值 现在数组是有序的（不能用比较的排序） 
             <p> 1. 差值数组有n个数  设置n+1 个桶  保证必有一个桶是空 
             <p> 2. 最大差值必定是一个非空桶的小值 和前非空桶的差值最大的一个
             
   
   + 问题 用数组结构实现大小固定的队列和栈
        <p> 思路: 循环利用数组
        <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic03/Array_To_Stack_Queue.java">code<a>
   + 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作
        <p> 要求 ：
        <p> 1．pop、push、getMin操作的时间复杂度都是O(1)
        <p> 2．设计的栈类型可以使用现成的栈结构
        <p> 思路:  
        <a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic03/Code_02_GetMinStack.java">code<a>
        
