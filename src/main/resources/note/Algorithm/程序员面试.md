### 左神的程序员面试指南上面的练习题

<p> 排序算法
<a href="/src/main/java/Conllection/SelectSort.java">常见排序算法</a>
<p> 堆排序  从原来的大根堆 改写小根堆
<p><a href="/src/main/java/algorithm/basic/Code_03_HeapSort.java">大根堆排序</a>
<p><a href="/src/main/java/algorithm/basic/Code_03_MinHeapSort.java">小根堆排序</a>
 
 <p><a href="/src/main/java/algorithm/basic/Code_04_QuickSort.java"> 快速排序</a>

### 栈和队列
<p>1 一个栈不但要有他原来的功能 还要能拿出来最小值
 <p>思路: 两个栈 一个正常存数据 一个存当前最小值的栈
 <p> 这有两种思路 1, 小栈对应栈的值 每一个存下当前位置的最小 2 不对应 小栈只存一次  多个值对应的最小是一个 , 这种在取值的时候要判断,你吧当前最小值取出去了 小栈要pop
 <p><a href="/src/main/java/algorithm/Interview/practice01/P_1_0_GetMinStack.java"> code</a>
 
<p>2 栈实现一个队列
<p>思路: 两个栈的倒序 
 <p><a href="/src/main/java/algorithm/Interview/practice01/P_1_1_StackQueue.java"> code</a>


<p> 3 用栈和递归 逆序一个栈
<p> 思路: 利用递归会回到方法的 特性  ,1  利用递归取出栈底的数  2 取出栈的数重新入栈
<p> ps: 本题重要思想, 递归栈 在递归前取出来的数 是记录在递归栈的 程序计数器回到这儿是能取到原来放在这得值的
<p><a href="/src/main/java/algorithm/Interview/practice01/P_1_2_ReverseStack.java"> code</a>

<p> 4 猫狗队列的问题
<p> 实现一种猫狗队列的结构，要求如下： 
  <pre>  
    用户可以调用add方法将cat类或者dog类的实例放入队列中；
    用户可以调用pollAll方法，将队列中所有的实例按照队列的先后顺序依次弹出；
    用户可以调用pollDog方法，将队列中dog类的实例按照队列的先后顺序依次弹出；
    用户可以调用pollCat方法，将队列中cat类的实例按照队列的先后顺序依次弹出；
    用户可以调用isEmpty方法，检查队列中是否还有dog和cat的实例；
    用户可以调用isDogEmpty方法，检查队列中是否还有do的实例；
    用户可以调用isCatEmpty方法，检查队列中是否还有cat的实例。  </pre>
<p>思路: 不能改写远数据结构 ,可以通过包装
<p><a href="/src/main/java/algorithm/Interview/practice01/P_1_3_CatDogQueue.java"> code</a>

<p> 5  用栈解决一个栈排序的问题
<p> 不能用其他数据节后
<p>思路: (降序) 用辅助栈 help ,取出stack的头, 小于等于放在help ,大于把help值取出来 直到小于help顶或者isEmpty 
<p> 思路有点像汉诺塔问题 ,但是是在两个之间
<p><a href="/src/main/java/algorithm/Interview/practice01/P_1_4_StackSort.java"> code</a>


<p> 6 用栈解决汉诺塔的问题
<p> 修改规则 不能从最左到最右  也不能从最右到最左 必须走中间
<p> 普通版和晋级版  都是递归  但也能用栈 思路是一样的 比较大小 选择放值
<p><a href="/src/main/java/algorithm/Interview/practice01/P_1_5_Hanoi.java"> code</a>


<p> 7 求生产窗口最大值 得到结果是每个窗口的最大值  一个数组
<p> 窗口必生成一个最大值  但我们并不需要一个整个窗口 只要窗口最大(但不能只保留最大 可能有限窗口最大是马上要出窗口的操作 )
 <p><a href="/src/main/java/algorithm/Interview/practice01/P_1_6_WindowMax.java"> code</a>
 

<p> 8 一个数组的MaxTree定义：   
<li>   数组必须没有重复元素
<li>      MaxTree是一棵二叉树，数组的每一个值对应一个二叉树节点
<li>      包括MaxTree树在内且在          其中的每一棵子树上，值最大的节点都是树的头 
<p>思路: 找到每个元素的左边比他大的数  右边比他大的数   两边较小的就是他的父节点 没有表示他是root节点 没有父节点
<p>给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组的长度为N，则时间复杂度为O(N)、额外空间复杂度为O(N)
<p>先用上面窗口的方法  找到每个数 左边比他大的   右边比他大的   然后构建树                                                                                                                                         
<p><a href="/src/main/java/algorithm/Interview/practice01/P_1_7_MaxTree.java"> code</a>


<p> 9 返回一个二位数组最大矩阵大小
<p>  例如给定如下矩阵:
<pre>   
     1 0 1 0 0
     1 0 1 1 1
     1 1 1 1 1
     1 0 0 1 0
     Return 4                                                                                                                                                   
    </pre>
<p> 时间复杂度,O(M*N)
<p>思路：
  <img src="https://s2.ax1x.com/2019/11/21/MhgGCQ.jpg" alt="MhgGCQ.jpg" border="0" />
 <p>将其放到一个矩阵中，同时从第0行开始计算，以该行打底时，直方图的最大面积。
 <p>如，第0行，数组为[1, 0, 1, 1]，此时可以求直方图的最大面积
 <p>然后以第一行打底，此时数组为[2, 1, 2, 2]，同理求直方图的最大面积。
 <p>然后以第2行打底，此时数组为[3, 2, 3, 0]。
 <p>类似的题目：给定一个数组，表示的是每个位置的直方图的高度，求直方图中连续部分的最大面积
 <p> 实际上面已经求出了 每个点对应的矩阵的高( 但实际的高 是单调栈里面的最小高) ,  然后利用单调栈可以拿到这个矩阵的宽 
 <p>怎么拿
 <p>利用单调栈，构成一个有栈底到栈顶是从小到大的结构，当要入栈的元素num小于栈顶元素时，栈顶元素出栈，同时对该元素左右能到达的边界进行记录
<p><a href="/src/main/java/algorithm/Interview/practice01/P_1_8_MaxMatrix.java"> code</a>


 <p> 10 最大值减去最小值 小于或等于num 的子数组数量
 <p> 每个子数组 的最大值减最小值等于 num 即满足条件
 <p>思路:
 <p> 1 找出所有子数组 O(N^2)  找出最大最小 O(N) 最后时间复杂度O(N^3)
 <p> 2 窗口就是子数组 (根据题意  这题是不需要差值是大于num 的子数组  即窗口内的数组 最大 最小一定小于num ) 用双指针调整窗口大小 时间复杂度O(N)
<p> 注释加code
<p><a href="/src/main/java/algorithm/Interview/practice01/P_1_9_AllLessNumArray.java"> code</a>

  
### 链表问题

<p> 1 打印有序链表的公共部分
<p>  思路: 因为是有序链表 所以两个链表双指针 比较就好了
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_0_PrintCommonPart.java"> code</a>


<p> 2  在单双链表中删除 倒数第k个元素
<p>思路 :
<p> 1 辅助时间数据结构 比如map表 下标和元素  虽然占用空间变大了  但是只循环N
<p> 2 先计算长度 然后找出len-k 的元素  虽然省下了时间 但要循环两次

<p> 双链表查找逻辑 是一样的  但是重连逻辑多点
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_1_RemoveLastKNode.java"> code</a>


<p> 3 删除 链表中间节点和 a/b 的节点
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_2_DeleteNode.java"> code</a>


<p>4 反转单向链表  和双向链表
<p> 思路: 把当前节点从链表拿出来 放在头
 <p><a href="/src/main/java/algorithm/Interview/practice02/P_2_3_ReverseList.java"> code</a>

<p>5 反转部分链表
<p> 思路: 上面的思路 多了处理需要反转的头尾 把当前节点从链表拿出来 放在头
 <p><a href="/src/main/java/algorithm/Interview/practice02/P_2_4_ReversePart.java"> code</a>

 <p>6 环形单链表的约瑟夫问题
 <p> 据说著名犹太历史学家Josephus有过以下故事：在罗马人占领乔塔帕特后，
     39个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也
     不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个
     人开始报数，报数到3的人就自杀，然后再由下一个人重新报1，报数到3的人
     再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的
     命运。这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整
     个自杀过程。
     
<p>  输入：一个环形单向链表的头节点head和报数的值m。
<p>返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。
 <p><a href="/src/main/java/algorithm/Interview/practice02/P_2_5_Josephu.java"> code</a>
 
 
 <p>7  一个链表是不是一个回文结构
 <p> 进阶: 时间O(N) ,空间O(1)
 <p> 思路1: 用栈  ,回文结构逆序一定和原链表一致 ,相同则是,
<p> 思路2:  优化下可以不整个放到栈 ,只放前一半就行
 <p>进阶思路:     链表反转,可节省下来上面思路的占用空间
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_6_IsPalindRom.java"> code</a>
   
 
<p>8  一个单项链表 根据给的值  变成 左边小  中间相等  右边大于的 形式 
<p>进阶: 保持原链表的顺序
<p> 思路:(时间 O(N),空间 O(N))拿到长度 , 新建一个Node[] ,然后按快排 partition的双指针过程填值 ,循环完,数组内即为结果,链表连接,得到结果
<p> 进阶思路: (上面思路 快排会破坏稳定性同理) 所以不能用数组  ,可以用三个链表 ,链表维持稳定性
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_7_ListPartiton.java"> code</a>
   
  
<p>9  复制含有随机节点的链表
<p>  给定一个由Node节点类型组成的无环单链表的头结点head,请实现一个函数完成这个链表结构的复制，并返回新链表的头结点。
<p> 例如：链表1->2->3->null,假设1的rand指针指向3,2的rand指正指向null,3的rand指针指向1。复制后的链表应该也是这种结构。 
<p>进阶: 不适用额外辅助空间  O(N)
<p> 思路:   map 的 K,V 对应关系  然后 get  set 
<p> 进阶思路: 首先我们把链表的形式由1-2-3-null变为1-1’-2-2’-3-3’-null,意思就是把我们复制的链表插在我们的中间。 
<p>           2。复制rand。 
<p>           3 大链表 拆成两个各自的链表
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_8_CopyRandNode.java"> code</a>
   
  
<p>10  两个单链表生成相加链表
<p>   假设链表中每一个节点的值都在0-9之间，那么链表整体就可以代表一个整数。例如9->3->7，代表937. 
<p>   给定两个这种链表的头节点head1和head2，请生成代表两个整数相加值的结果链表。 
<p>   例如：9->3->7和6->3，相加结果为1->0->0->0
<p> 思路1:  用栈或者双向链表  ( 和leetcode 第二题有点一样  但不完全一样 leetcode是逆序存的值 )
<p> 思路2: 利用链表倒序 得到结果  然后把顺序倒回来 
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_10_LookNode.java"> code</a>
   
  
<p>11  将单链表每K个节点逆序
<p>   链表 1 2 3 4 5
<p>   输入 K=2 ，要反转成 2 1 4 3 5
<p> 思路1: 利用栈逆序 时间复杂高点
<p> 思路2: 直接链表逆序 链表  可省下空间复杂度
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_11_ReverseKNode.java"> code</a>
   
  
     
<p>12 删除无需单链表中出现的重复节点                                    
<p> 给定一个无序单链表的头结点head，删除其中值重复出现的节点。 
<p>    例如：1->2->3->3->4->4->2->1->1->null，删除重复的节点之后为1->2->3->4->null。
<p>    算法1：时间复杂度O(N) 
<p>    算法2：额外空间复杂度O(1)
<p>思路1: 很明显用map 空间O(N)
<p>思路2: 如果只要求空间复杂度  没有时间  可以类似排序的方法 O(N^2)
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_12_RemoveNode.java"> code</a>
   
     
<p>13 删除单链表中指定值的节点                                
<p> 　给定一个链表的头节点 head 和一个整数 num，请实现函数将值为 num 的节点全部删除。
<p>例如，链表为 1->2->3->4->NULL，num=3，链表调整后为：1->2->4->NULL。
<p>思路1: 很明显还是辅助空间 时间O(N) 空间O(N)
<p>思路2:  链表重连的方法
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_13_RemoveNumNode.java"> code</a>
   
     
<p>14 将搜索二叉树转换成双向链表                     
<p> 　  对二叉树的节点来书，有本身的值域，有指向左孩子和右孩子的指针；对双链表的节点来说，有本身的值域，有指向上一个节点和下一个节点的指针。在结构上，两种结构有
<p>       相似性，现在有一棵搜索二叉树，请将其转换为一个有序的双向链表。
<p>思路1: 使用辅助队列，先遍历二叉搜索树，将节点存入一个队列，再依次出队中元素，将先后出队的节点前后链接起来。时间复杂度为O(N),空间复杂度为O(N)
<p>思路2:  递归( 请记住二叉树二分递归) ,时间O(N) 时间O(h)
<p>   思路2的精髓除了递归还有  递归链表的特殊性  尾节点指向头结点
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_14_TreeNodeToList.java"> code</a>


<p>15 单链表的选择排序         
<p>思路1: 选择排序思路 ,在没排序的部分找到最小的 放在拍好的后面,除了这个就是链表的重连
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_15_SelectionSortNode.java"> code</a>
   
<p>16 一种怪异的节点删除方式  
<p>链表节点类型都是int，给定一个节点node，但不给定整个链表头节点，如何从链表中删除node？
  
<p>思路1:  1->2->3->4->null，删除节点3，只需要把节点3的值改成4，删掉节点4
<li>无法删除最后一个节点
<li>  根本不是删除了node节点，而是改变了node节点的值，并删除下一个节点，实际工程中可能不适用
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_16_RemoveNodeWired.java"> code</a>
   
<p>17 向有序的环形单链表插入新节点
<p>思路1:  有序表示尾节点 大于头节点  ,拿出来插进去 ,O(N) ,空间O(1)
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_17_InsertNum.java"> code</a>
   

 
   
<p>18 合并两个有序单链表
<p>思路1:   两个链表都不为null 指针比较 ,放到新链表
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_18_MergeNode.java"> code</a>
   

 
<p>19 按照左右半区的方式重新组合成单链表
<p> 给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区； 如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区； 左半区从左到右依次记为L1->L2->...，右半区从左到右依次记为R1->R2->...。请将单链表调整成L1->R1->L2->R2->...的样子。 例如： 1->2->3->4 调整后：1->3->2->4 1->2->3->4->5 调整后：1->3->2->4->5 要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)

<p>思路1:  为空 长度是1 可以直接返回,其他情况找到左面最后节点 重链一个链表
<p><a href="/src/main/java/algorithm/Interview/practice02/P_2_19_RelocateNode.java"> code</a>
   

### 二叉树问题

<p>1 递归和非递归 先序 中序 后序
<p> 
<p>思路1: 递归思路,一个节点到达次数是3次, 不同序是不同打印时机
<p>思路2: 非递归思路  (深度用栈,广度用队列)
<p> 先序(父->左->右): 1,先来到父,2,处理,3,栈存右,4来到左,4.1左不为null ,继续1,2,3,4   4.2 为null,从栈弹出一个,继续1,2,3,4  栈空结束
<p> 中序(左->父->右): 1,先来到父  1.1 左不为空 栈存父,来到左   1.2 左null 处理 ,来到右  2 右不为null 继续,为null 栈弹出
<p> 后序(左->右->父): 1 根据先序改出来 父->右->左 2 逆序
<p> 思路3: <a href="#Morris">Morris遍历 </a>
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_0_PrintOrderRecur.java"> code</a>
   
<p>2 打印二叉树的边界节点
<p>给定一颗二叉树的根节点 root，按照如下两种标准分别实现二叉树的边界节点的逆时针打印。
<p>标准一：
<p>1，根节点为边界节点。
<p>2，叶节点为边界节点。
<p>3，如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。
<p>标准二：
<p>1，根节点为边界节点。
<p>2，叶节点为边界节点。
<p>3，树左边界延伸下去的路径为边界节点。
<p>4，树右边界延伸下去的路径为边界节点。
 <pre><code>
  /**
    *                        1
    *          2                          3
    *                4               5           6
    *             7     8         9    10
    *                     11   12
    *                   13 14 15 16
    */</code></pre>
<p>按标准一的打印结果为：1，2，4，7，11，13，14，15，16，12，10，6，3
<p>按标准二的打印结果为：1，2，4，7，13，14，15，16，10，6，3
<p>【要求】
<p>1.如果节点数为N，两种标准实现的时间复杂度要求都为O(N)，额外空间复杂度要求都为O(h)，h为二叉树的高度。
<p>2.两种标准都要求逆时针顺序且不重复打印所有的边界节点。

<p> 思路1: 标准1 的思路 ,   打印的数据实际上分成三部分 每层最左节点(1，2，4，7，11，13) ,最右节点(16，12，10，6，3) 和不属于最左最右的叶子节点
<p> 思路1: 标准2 的思路 ,  1 只有一个孩子的 直接打印  2 有左右的 判断是有左右孩子  只有一个打印 3  叶子打印
 <p><a href="/src/main/java/algorithm/Interview/practice03/P_3_1_PrintEdge.java"> code</a>
   
<p>3 如何直观的打印二叉树
<p> 先序 中序 后序打印并不直观 
<p>思路1: 高度,标识左子还是右子
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_2_PrintBinaryTree.java"> code</a>


<p>4 二叉树的序列化和反序列化
<p> 
<p>思路1: 思路就是 先序或者其他方式 遍历,空节点用特殊字符表示
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_3_SerialNode.java"> code</a>
<p> <a href="/src/main/java/algorithm/basic04/Code_04_SerializeAndReconstructTree.java">两种实现code</a>
 
    
<p ><a name="Morris">5 Morrris 遍历</a>
<p> 
<p>思路1: 1.当前结点cur没有左子树，当前结点cur向右移动
<p>2.当前结点cur有左子树，找到当前结点左子树的最右结点
<p> 2.1如果左子树的最右结点的右子树为空，那么将本来指向空的最右结点指向当前结点cur，然后当前结点向左移动
<p> 2.2如果当前结点cur左子树的最右结点指向当前结点cur，让最右孩子指向空，cur向右移动

<p> morris 遍历 是模拟了递归栈遍历的方式   
<p> 递归栈 在递归时有自己的栈  每个节点都能来到三次  前中后序 只是打印时机不同
<p> morris 有左子树的节点来到两次 没有的只来一次
<p> 所以morris的后序  相对来说复杂一些     
<p>  后序思路：前面还是morris的思路, 来到节点 如果有左子节点 把左子树最右节点的 右子节点设为cur  开始后序自己思路
<p> 1 有左子树来到 左子节点
<p> 2 没有左子树 来到右子节点
<p> 3 来到叶子节点  逆序打印当前叶子节点这一右列  (对辅助空间没要求可以用栈 有要求逆序打印二叉树的思路)
<p> ps: 逆序的思路在基础3-07 里面  
<img src="https://s2.ax1x.com/2019/11/25/Mvq32q.jpg" alt="Mvq32q.jpg" border="0" />
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_4_Morris.java">后序栈实现 code</a>
 <p> <a href="/src/main/java/algorithm/advanced01/Morris.java">后序链表逆序实现  code</a>   
 
 
<p>6 在二叉树中找到累加和为指定值的最长路径的长度
<p> 给定一颗二叉树的头节点head和一个32位整数sum，二叉树节点值类型为整型，求累加和胃sum的最长路径长度。
<p>
<p>思路: 1 递归找出每个子树  2 改动态规划    ( 这题逻辑和数组里面找到 相加为定值差不多  <a href="/src/main/resources/note/Algorithm/算法学习基本数据结构和算法原型.md">原型里的数组子序列最长 (原型)</a>)
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_5_MaxLength.java"> code</a>
  
<p>7  找到二叉树中的最大搜索二叉树
<p>   题目要求找到最大的二叉搜索子树，补充一下子树的定义，从节点a开始，a以及a的所有后裔最大搜索二叉树构成一个子树。如果不按照这个子树定义的话，书中给出的例子存在一个节点数为8的二叉树。
<p>思路1:  中序遍历,找搜索树,   要遍历所有子树
 <p> 思路2： 递归左右树  来到cur
 <p> 1 最大的二叉树在左测 （ 左子树的最大比右子树 大  并与cur无关）
 <p> 2 最大的二叉树在右测 （ 左子树的最大比右子树 小  并与cur无关）
 <p> 2 最大的二叉树是cur这颗树 （ 左子树,右子树 的最大搜索树是cur的左右子节点 并 左子树最大节点小于cur，右子最小节点大于cur）
<p> <a href="/src/main/java/algorithm/advanced04/Code_04_BiggestSubBSTInTree.java"> 原型实现 code</a>
  
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_6_BiggestSubBSTInTree.java"> code</a>
  
 
<p>8 找到二叉树中复合二叉搜索树的最大拓扑结构
<p>    
<p>思路1:  先序遍历的方式：先序遍历每个节点，获取以当前节点为头的情况下的最大BST拓扑结构，并记录最大值
<p>思路2： 后序遍历的方式：后序遍历，先获取到左右子树的情况，然后再通过左右子树的情况来更新当前节点

> 为什么左子树只需要对左子树的右边界进行过滤更新，为什么右子树只需要对右子树的左边界进行过滤更新？
     假设已经左右子树已经完成了贡献记录的更新，这个时候，左子树就是一个BST，所以左子树的右边界在不断的增大，
     由于这个子树只能保证所有的右边界大于左子树的头结点；同时左边界都小于左子树的头结点，
     所以，需要更新的只有不符合以head为头结点的情况下可能会出现大于head节点的情况，因此只有右边界可能出现大于head节点的情况，
     所以，在modifyMap的时候，如果是左子树，只需考察右边界，在右边界上有节点大于head节点的时候去更新右边界。
     右子树也是同理，只有左边界上可能出现小于head节点的节点，这种节点会破坏原来右子树的记录，所以需要更新。

<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_7_BstTopoSize.java"> code</a>
  
 
<p>9 二叉树按层打印和ZigZag打印
<p>   链接：https://www.nowcoder.com/questionTerminal/6a1815a85bfc411d9295bc017e6b6dbe?orderByHotValue=1&mutiTagIds=583&page=1&onlyReference=false
<p> 
<p> 输入描述:
<p> 第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
<p> 以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理) 
<p>思路: 二叉树按成打印 用队列,
<p> zigzag 的顺序用,双端队列实现
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_8_PrintByLevel.java"> code</a>
  
 
<p>10 调整搜索二叉树两个错误节点
<p> 一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个错误节点并返回。已知二叉树中所有节点的 值都不一样，给定二叉树的头节点 head，返回一个长度为 2 的二叉树节点类型 的数组 errs，errs[0]表示一个错误节点，errs[1]表示另一个错误节点。
<p> 如果在原问题中得到了这两个错误节点，我们当然可以通过交换两个节点的节点 值的方式让整棵二叉树重新成为搜索二叉树。但现在要求你不能这么做，而是在 结构上完全交换两个节点的位置，请实现调整的函数。
<p> {1,2,3,4,5}-->{1,5,3,4,2}
<p>解析: 二叉搜索树,中序一定升序,两个错误节点在一起,只有一次降序, 不在一起,第一个点是第一次降序的前一个节点,第二个是第二次降序的第二个节点
<p>思路1: 递归,非递归,morris 中序   
<p>思路2: 用中序,找子节点是不是错误节点
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_9_TwoErrorNode.java"> code</a>
  
<p>11 判断 t1 树是否包含t2 树的拓扑结构
<p> 
<p>思路1: 找t1 里面和t2 一样的节点 O(M*N)
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_10_Contains.java"> code</a>


<p>12 判断 t1 树是否包含t2 树的完全一致的拓扑结构
<p> 
<p>思路1: 和上面一样,找t1 里面和t2 一样的节点 O(M*N)
<p>思路2:序列化成字符串,KMP能在线性时间完成比较
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_11_KmpContainsAll.java"> code</a>


<p>13 判断二叉树是否是平衡二叉树
<p> 
<p>思路1:  遍历,判断左右树 是否是平衡(高度差不大于1), 双参数,高度,当前节点是不是
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_12_IsBalance.java"> code</a>

<p> 14 根据后序数组重建搜索二叉树
<p> 给定一个整型数组arr，已知其中没有重复值，判断arr是否可能是节点值类型为整型的搜索二叉树后序遍历的结果。
<p>进阶：
<p>  如果整型数组arr中没有重复值，且已知是一棵搜索二叉树的后 序遍历结果，通过数组arr重构二叉树。
<p>解析: 二叉树必须两个数组才能确认,但搜索二叉树不一样 ,他有顺序,最后一个一定是root,小的左子,大的右子,不满足不是
<p>思路1: 
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_13_IsSreach.java"> code</a>
  
 
<p> 15 判断一棵树是否是搜索二叉树和完全二叉树
<p> 
<p>解析:搜索二叉树 中序
<p> 完全二叉树: 层级遍历,左到右,1, 一个节点有右无左,不是 2,一个节点右为空,后面节点都为叶节点,否则 不是, 3 遍历完,没有遇到1,2 是
<p>思路1: 
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_14_NodeSCBT.java"> code</a>

<p> 16 通过有序数组生成平衡二叉搜索树
<p> 
<p>解析: 不用平衡就就简单,找到root ,递归左子右子
<p>思路1: 
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_15_generateBST.java"> code</a>
  
 
<p> 17 在二叉树中找一个节点的后继节点
<p> 这是一种带part的二叉树
<p>解析: 后继节点就是中序遍历后一个节点,前驱相反
<p>思路1:  中序遍历一定能找到 时间空间 O(N)
<p>思路2:  时间 O(L) ,节点与后继距离 ,空间 O(1)
<p> 解法: 两种情况 1 节点有右子,那就是右子最左节点  2 没有右子 ,看父节点, 是左子 ,就是父节点, 是右子,继续向上判断,到最后root都是右子就是null
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_15_generateBST.java"> code</a>
  
<p> 18 在二叉树中找到两个节点最经的公共节点
<p> 进阶问题：
<p>  如果查询两个节点的最近公共祖先的操作十分频繁，想办法让单条查询的查询时间减少。
<p>这个问题其实是先花较大的力气建立一种记录，以后执行每次查询时就可以完全根据记录进行查询。
<p>再进阶: 
<p> 节点数n,多条查询M  时间复杂度O(M+N) 
<p>解析: 
<p>思路1:  后序遍历, 拿到左子 右子,1 左右都有,就是cur, 2 都没有 为null 3 一个有,返回
<p>思路2:  用容器存起来
<p>思路3:  看下一题
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_17_LowestAncestor.java"> code</a>


<p> 19 Tarjan和并查集解决二叉树节点间最近公共祖先的批量查询问题
<p>Tarjan算法是离线算法，基于后序DFS（深度优先搜索）和并查集
<p>思路1:  
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_18_TarjanGroupParent.java"> code</a>
  
 
<p> 20 二叉树两个节点最大距离
<p>
<p>思路1: 二叉树两个节点之间的最大距离，以根节点分析，最大距离可能有3种情况：
<p> 左左+右右+左右
<p> 左左相当于求左子树上的递归子问题，右右相当于求右子树的递归子问题。左右是需要我们处理的问题。我们使用record[]数组来记录左边的最大值和右边的最大值。
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_19_MaxLength.java"> code</a>
  
 
<p> 21 前序 中序  后序 两两结合重构二叉树
<p>
<p>有中序的,中序中间是root,用拆分递归就行
<p>    <a href="/src/main/java/offer/前序遍历和中序推出二叉树.java">剑指offer 的题 --前序和中序逆推二叉树code</a>
<p> 先序 + 后序 ==> 二叉树
<p>　　在大多数情况下是无法通过先序数组和后序数组重建二叉树的，因为很多结构不同的树的先序数组和后序数组相同
<p>　　只有当一棵二叉树满足除叶节点外，其它所有节点都有左孩子和右孩子时，才可以被先序和后序数组重建出来
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_20_PosToTree.java"> code</a>

<p> 21 前序 中序  求后序数组
<p>
<p>思路:不用重构二叉树
<p>preorder: 1 2 4 5 3 6 7
<p>inorder: 4 2 5 1 6 3 7
<p>先序序列的第一个值肯定是根节点，从中序序列找到这个值（二叉树所有节点值不相同为前提），则中序序列中，根节点左边的4 2 5是左子树，右边的6 3 7是右子树。递归求解即可
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_21_GetPosArray.java"> code</a>


<p> 22 统计和生成所有不同二叉树
<p>
<p>思路:假设num[n]代表ｎ个节点的搜索二叉树有多少种可能。假设序列｛1 , …, i , … , N｝，如果以ｉ作为头结点，ｉ的左子树有i-1个节点，所以可能的结构有num[i-1]种，右子树有N-i个节点，所以有num[N-i]种可能，故以ｉ作为头结点的可能的结构的种数为num[i-1]*num[N-i]。 
      　　把从１到Ｎ分别作为头节点，所有可能的结构加起来就是答案，利用动态规划加速运算
<p> 进阶:N的含义不变，假设可能的二叉树结构有M种，请返回M个二叉树的头节点，每一颗二叉树代表一种可能的结构
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_22_NumTree.java"> code</a>

<p> 23 统计完全二叉树的节点个数
<p>
<p>思路: 遍历一定能求出来
<p> 思路2: 满二叉树 好求,每层是 2^(h-1) 相加得到值, 不是满的,就拆分,
<p><a href="/src/main/java/algorithm/Interview/practice03/P_3_22_NumTree.java"> code</a>
  
### 递归和动态规划

<p>1    斐波那契系列问题的递归和动态规划
<p> 1.1 给定N 返回斐波那契的第N项
<p> 1.2 给定N  ,代表台阶数,一次一步或者两步 ,多少种走法
<p> 1.3 给定N 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛,返回N年有多少牛
<p> 时间复杂度 O(Log N)
<p> 思路: 都一样,递归 O(2^N) 
<p>2 记忆 从第一项和第二项 慢慢推下去,O(N)
<p>3 矩阵 动态规划 O(log N)
 <p><a href="/src/main/java/algorithm/Interview/practice04/P_4_1_Fibonacci.java"> code</a>
 
 
<p>2 矩阵的最小路径和
<p> 思路1: 递归 
<p>思路2: 动态规划 
 <p><a href="/src/main/java/algorithm/Interview/practice04/P_4_2_MinPathSum.java"> code</a>
 
<p>3 换钱的最小货币数
<p> 给定数组arr, arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求组成aim的最少货币数。
<p> 进阶: 每种面值一张
<p> 思路1: 递归 O(2^N) 
<p>思路2: 动态规划 
 <p><a href="/src/main/java/algorithm/Interview/practice04/P_4_3_MinCoins.java"> code</a>


<p>* 4   换钱的方法数 ( 这题方法很经典)
<p> 给定数组arr，所有元素都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。
<p> 进阶: 每种面值一张
 <p><a href="/src/main/java/algorithm/Interview/practice04/P_4_3_MinCoins.java"> code</a>

<p> 5 最长递增子序列
<p> 给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4.
<p>思路1: O(N^2) 
<p>思路2:  加二分    O(LogN)
 <p><a href="/src/main/java/algorithm/Interview/practice04/P_4_4_MaxLength.java"> code</a>
 
    
### 其他
 <p> 1 拼多多2019数据结构题
 <p> 整形矩阵 找最长递增路径
 <p> 思路: 主要还是递归
 <p><a href="/src/main/java/algorithm/Interview/practice01/P_0_0_MostLang.java"> code</a>
  
