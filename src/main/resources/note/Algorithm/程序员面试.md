### 左神的程序员面试指南上面的练习题

<p> 排序算法
<a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/Conllection/SelectSort.java">常见排序算法</a>
<p> 堆排序  从原来的大根堆 改写小根堆
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic/Code_03_HeapSort.java">大根堆排序</a>
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic/Code_03_MinHeapSort.java">小根堆排序</a>
 
 <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/basic/Code_04_QuickSort.java"> 快速排序</a>

### 栈和队列
<p>1 一个栈不但要有他原来的功能 还要能拿出来最小值
 <p>思路: 两个栈 一个正常存数据 一个存当前最小值的栈
 <p> 这有两种思路 1, 小栈对应栈的值 每一个存下当前位置的最小 2 不对应 小栈只存一次  多个值对应的最小是一个 , 这种在取值的时候要判断,你吧当前最小值取出去了 小栈要pop
 <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_0_GetMinStack.java"> code</a>
 
<p>2 栈实现一个队列
<p>思路: 两个栈的倒序 
 <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_1_StackQueue.java"> code</a>


<p> 3 用栈和递归 逆序一个栈
<p> 思路: 利用递归会回到方法的 特性  ,1  利用递归取出栈底的数  2 取出栈的数重新入栈
<p> ps: 本题重要思想, 递归栈 在递归前取出来的数 是记录在递归栈的 程序计数器回到这儿是能取到原来放在这得值的
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_2_ReverseStack.java"> code</a>

<p> 4 猫狗队列的问题
<p> 实现一种猫狗队列的结构，要求如下： 
  <pre>  
    用户可以调用add方法将cat类或者dog类的实例放入队列中；
    用户可以调用pollAll方法，将队列中所有的实例按照队列的先后顺序依次弹出；
    用户可以调用pollDog方法，将队列中dog类的实例按照队列的先后顺序依次弹出；
    用户可以调用pollCat方法，将队列中cat类的实例按照队列的先后顺序依次弹出；
    用户可以调用isEmpty方法，检查队列中是否还有dog和cat的实例；
    用户可以调用isDogEmpty方法，检查队列中是否还有do的实例；
    用户可以调用isCatEmpty方法，检查队列中是否还有cat的实例。  </pre>
<p>思路: 不能改写远数据结构 ,可以通过包装
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_3_CatDogQueue.java"> code</a>

<p> 5  用栈解决一个栈排序的问题
<p> 不能用其他数据节后
<p>思路: (降序) 用辅助栈 help ,取出stack的头, 小于等于放在help ,大于把help值取出来 直到小于help顶或者isEmpty 
<p> 思路有点像汉诺塔问题 ,但是是在两个之间
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_4_StackSort.java"> code</a>


<p> 6 用栈解决汉诺塔的问题
<p> 修改规则 不能从最左到最右  也不能从最右到最左 必须走中间
<p> 普通版和晋级版  都是递归  但也能用栈 思路是一样的 比较大小 选择放值
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_5_Hanoi.java"> code</a>


<p> 7 求生产窗口最大值 得到结果是每个窗口的最大值  一个数组
<p> 窗口必生成一个最大值  但我们并不需要一个整个窗口 只要窗口最大(但不能只保留最大 可能有限窗口最大是马上要出窗口的操作 )
 <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_6_WindowMax.java"> code</a>
 

<p> 8 一个数组的MaxTree定义：   
<li>   数组必须没有重复元素
<li>      MaxTree是一棵二叉树，数组的每一个值对应一个二叉树节点
<li>      包括MaxTree树在内且在          其中的每一棵子树上，值最大的节点都是树的头 
<p>思路: 找到每个元素的左边比他大的数  右边比他大的数   两边较小的就是他的父节点 没有表示他是root节点 没有父节点
<p>给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组的长度为N，则时间复杂度为O(N)、额外空间复杂度为O(N)
<p>先用上面窗口的方法  找到每个数 左边比他大的   右边比他大的   然后构建树                                                                                                                                         
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_7_MaxTree.java"> code</a>


<p> 9 返回一个二位数组最大矩阵大小
<p>  例如给定如下矩阵:
<pre>   
     1 0 1 0 0
     1 0 1 1 1
     1 1 1 1 1
     1 0 0 1 0
     Return 4                                                                                                                                                   
    </pre>
<p> 时间复杂度,O(M*N)
<p>思路：
  <img src="https://s2.ax1x.com/2019/11/21/MhgGCQ.jpg" alt="MhgGCQ.jpg" border="0" />
 <p>将其放到一个矩阵中，同时从第0行开始计算，以该行打底时，直方图的最大面积。
 <p>如，第0行，数组为[1, 0, 1, 1]，此时可以求直方图的最大面积
 <p>然后以第一行打底，此时数组为[2, 1, 2, 2]，同理求直方图的最大面积。
 <p>然后以第2行打底，此时数组为[3, 2, 3, 0]。
 <p>类似的题目：给定一个数组，表示的是每个位置的直方图的高度，求直方图中连续部分的最大面积
 <p> 实际上面已经求出了 每个点对应的矩阵的高( 但实际的高 是单调栈里面的最小高) ,  然后利用单调栈可以拿到这个矩阵的宽 
 <p>怎么拿
 <p>利用单调栈，构成一个有栈底到栈顶是从小到大的结构，当要入栈的元素num小于栈顶元素时，栈顶元素出栈，同时对该元素左右能到达的边界进行记录
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_8_MaxMatrix.java"> code</a>


 <p> 10 最大值减去最小值 小于或等于num 的子数组数量
 <p> 每个子数组 的最大值减最小值等于 num 即满足条件
 <p>思路:
 <p> 1 找出所有子数组 O(N^2)  找出最大最小 O(N) 最后时间复杂度O(N^3)
 <p> 2 窗口就是子数组 (根据题意  这题是不需要差值是大于num 的子数组  即窗口内的数组 最大 最小一定小于num ) 用双指针调整窗口大小 时间复杂度O(N)
<p> 注释加code
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_1_9_AllLessNumArray.java"> code</a>

  
### 链表问题

<p> 1 打印有序链表的公共部分
<p>  思路: 因为是有序链表 所以两个链表双指针 比较就好了
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_0_PrintCommonPart.java"> code</a>


<p> 2  在单双链表中删除 倒数第k个元素
<p>思路 :
<p> 1 辅助时间数据结构 比如map表 下标和元素  虽然占用空间变大了  但是只循环N
<p> 2 先计算长度 然后找出len-k 的元素  虽然省下了时间 但要循环两次

<p> 双链表查找逻辑 是一样的  但是重连逻辑多点
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_1_RemoveLastKNode.java"> code</a>


<p> 3 删除 链表中间节点和 a/b 的节点
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_2_DeleteNode.java"> code</a>


<p>4 反转单向链表  和双向链表
<p> 思路: 把当前节点从链表拿出来 放在头
 <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_3_ReverseList.java"> code</a>

<p>5 反转部分链表
<p> 思路: 上面的思路 多了处理需要反转的头尾 把当前节点从链表拿出来 放在头
 <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_4_ReversePart.java"> code</a>

 <p>6 环形单链表的约瑟夫问题
 <p> 据说著名犹太历史学家Josephus有过以下故事：在罗马人占领乔塔帕特后，
     39个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也
     不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个
     人开始报数，报数到3的人就自杀，然后再由下一个人重新报1，报数到3的人
     再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的
     命运。这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整
     个自杀过程。
     
<p>  输入：一个环形单向链表的头节点head和报数的值m。
<p>返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。
 <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_5_Josephu.java"> code</a>
 
 
 <p>7  一个链表是不是一个回文结构
 <p> 进阶: 时间O(N) ,空间O(1)
 <p> 思路1: 用栈  ,回文结构逆序一定和原链表一致 ,相同则是,
<p> 思路2:  优化下可以不整个放到栈 ,只放前一半就行
 <p>进阶思路:     链表反转,可节省下来上面思路的占用空间
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_6_IsPalindRom.java"> code</a>
   
 
<p>8  一个单项链表 根据给的值  变成 左边小  中间相等  右边大于的 形式 
<p>进阶: 保持原链表的顺序
<p> 思路:(时间 O(N),空间 O(N))拿到长度 , 新建一个Node[] ,然后按快排 partition的双指针过程填值 ,循环完,数组内即为结果,链表连接,得到结果
<p> 进阶思路: (上面思路 快排会破坏稳定性同理) 所以不能用数组  ,可以用三个链表 ,链表维持稳定性
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_7_ListPartiton.java"> code</a>
   
  
<p>9  复制含有随机节点的链表
<p>  给定一个由Node节点类型组成的无环单链表的头结点head,请实现一个函数完成这个链表结构的复制，并返回新链表的头结点。
<p> 例如：链表1->2->3->null,假设1的rand指针指向3,2的rand指正指向null,3的rand指针指向1。复制后的链表应该也是这种结构。 
<p>进阶: 不适用额外辅助空间  O(N)
<p> 思路:   map 的 K,V 对应关系  然后 get  set 
<p> 进阶思路: 首先我们把链表的形式由1-2-3-null变为1-1’-2-2’-3-3’-null,意思就是把我们复制的链表插在我们的中间。 
<p>           2。复制rand。 
<p>           3 大链表 拆成两个各自的链表
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_8_CopyRandNode.java"> code</a>
   
  
<p>10  两个单链表生成相加链表
<p>   假设链表中每一个节点的值都在0-9之间，那么链表整体就可以代表一个整数。例如9->3->7，代表937. 
<p>   给定两个这种链表的头节点head1和head2，请生成代表两个整数相加值的结果链表。 
<p>   例如：9->3->7和6->3，相加结果为1->0->0->0
<p> 思路1:  用栈或者双向链表  ( 和leetcode 第二题有点一样  但不完全一样 leetcode是逆序存的值 )
<p> 思路2: 利用链表倒序 得到结果  然后把顺序倒回来 
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_10_LookNode.java"> code</a>
   
  
<p>11  将单链表每K个节点逆序
<p>   链表 1 2 3 4 5
<p>   输入 K=2 ，要反转成 2 1 4 3 5
<p> 思路1: 利用栈逆序 时间复杂高点
<p> 思路2: 直接链表逆序 链表  可省下空间复杂度
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_11_ReverseKNode.java"> code</a>
   
  
     
<p>12 删除无需单链表中出现的重复节点                                    
<p> 给定一个无序单链表的头结点head，删除其中值重复出现的节点。 
<p>    例如：1->2->3->3->4->4->2->1->1->null，删除重复的节点之后为1->2->3->4->null。
<p>    算法1：时间复杂度O(N) 
<p>    算法2：额外空间复杂度O(1)
<p>思路1: 很明显用map 空间O(N)
<p>思路2: 如果只要求空间复杂度  没有时间  可以类似排序的方法 O(N^2)
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_12_RemoveNode.java"> code</a>
   
     
<p>13 删除单链表中指定值的节点                                
<p> 　给定一个链表的头节点 head 和一个整数 num，请实现函数将值为 num 的节点全部删除。
<p>例如，链表为 1->2->3->4->NULL，num=3，链表调整后为：1->2->4->NULL。
<p>思路1: 很明显还是辅助空间 时间O(N) 空间O(N)
<p>思路2:  链表重连的方法
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_13_RemoveNumNode.java"> code</a>
   
     
<p>14 将搜索二叉树转换成双向链表                     
<p> 　  对二叉树的节点来书，有本身的值域，有指向左孩子和右孩子的指针；对双链表的节点来说，有本身的值域，有指向上一个节点和下一个节点的指针。在结构上，两种结构有
<p>       相似性，现在有一棵搜索二叉树，请将其转换为一个有序的双向链表。
<p>思路1: 使用辅助队列，先遍历二叉搜索树，将节点存入一个队列，再依次出队中元素，将先后出队的节点前后链接起来。时间复杂度为O(N),空间复杂度为O(N)
<p>思路2:  递归( 请记住二叉树二分递归) ,时间O(N) 时间O(h)
<p>   思路2的精髓除了递归还有  递归链表的特殊性  尾节点指向头结点
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_14_TreeNodeToList.java"> code</a>


<p>15 单链表的选择排序         
<p>思路1: 选择排序思路 ,在没排序的部分找到最小的 放在拍好的后面,除了这个就是链表的重连
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_15_SelectionSortNode.java"> code</a>
   
<p>16 一种怪异的节点删除方式  
<p>链表节点类型都是int，给定一个节点node，但不给定整个链表头节点，如何从链表中删除node？
  
<p>思路1:  1->2->3->4->null，删除节点3，只需要把节点3的值改成4，删掉节点4
<li>无法删除最后一个节点
<li>  根本不是删除了node节点，而是改变了node节点的值，并删除下一个节点，实际工程中可能不适用
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_16_RemoveNodeWired.java"> code</a>
   
<p>17 向有序的环形单链表插入新节点
<p>思路1:  有序表示尾节点 大于头节点  ,拿出来插进去 ,O(N) ,空间O(1)
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_17_InsertNum.java"> code</a>
   

 
   
<p>18 合并两个有序单链表
<p>思路1:   两个链表都不为null 指针比较 ,放到新链表
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_18_MergeNode.java"> code</a>
   

 
<p>19 按照左右半区的方式重新组合成单链表
<p> 给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区； 如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区； 左半区从左到右依次记为L1->L2->...，右半区从左到右依次记为R1->R2->...。请将单链表调整成L1->R1->L2->R2->...的样子。 例如： 1->2->3->4 调整后：1->3->2->4 1->2->3->4->5 调整后：1->3->2->4->5 要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)

<p>思路1:  为空 长度是1 可以直接返回,其他情况找到左面最后节点 重链一个链表
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_2_19_RelocateNode.java"> code</a>
   

### 二叉树问题

<p>1 递归和非递归 先序 中序 后序
<p> 
<p>思路1: 递归思路,一个节点到达次数是3次, 不同序是不同打印时机
<p>思路2: 非递归思路  (深度用栈,广度用队列)
<p> 先序(父->左->右): 1,先来到父,2,处理,3,栈存右,4来到左,4.1左不为null ,继续1,2,3,4   4.2 为null,从栈弹出一个,继续1,2,3,4  栈空结束
<p> 中序(左->父->右): 1,先来到父  1.1 左不为空 栈存父,来到左   1.2 左null 处理 ,来到右  2 右不为null 继续,为null 栈弹出
<p> 后序(左->右->父): 1 根据先序改出来 父->右->左 2 逆序
<p> 思路3: Morris遍历 之后再补
<p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice02/P_3_0_PrintOrderRecur.java"> code</a>
   

 
    
### 其他
 <p> 1 拼多多2019数据结构题
 <p> 整形矩阵 找最长递增路径
 <p> 思路: 主要还是递归
 <p><a href="https://github.com/mood321/JavaDemo/blob/master/src/main/java/algorithm/Interview/practice01/P_0_0_MostLang.java"> code</a>
  
