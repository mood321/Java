### 记面试题


<p>大概总结
<p> Java并发、mysql、网络、JDK集合、jvm、spring源码、tomcat、linux、系统设计、生产实践


### java 集合
<p> <a href="/src/main/resources/note/集合目录.md"> 这个可以看看之前写的集合</a>

<h4> HashMap
<p><a href="/src/main/resources/note/conllection/HashMap源码分析.md">HashMap源码解析 </a>
<p> 数组+链表+红黑树
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。
<p>
<p>当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。
<p>
<p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。

<h5> hash 算法和寻址优化  (这个原来笔记没有)
<pre>
  static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}</pre>

<p>  比如说：有一个key的hash值
<pre>
     1111 1111 1111 1111 1111 1010 0111 1100
     0000 0000 0000 0000 1111 1111 1111 1111
     1111 1111 1111 1111 0000 0101 1000 0011 -> int值，32位
     </pre>
<p> 简而言之就是,高16 不变,低16变成 高16位于低16位异或结果
<h4>寻址算法优化
<p>(n - 1) & hash -> 数组里的一个位置
<li> 用& 是因为 & 运算比取摸效率高,当然结果一样,这是个数学问题
<li> &也会导致一个问题 ,高16 的&运算 没有实际意义
<p>假设有两个hash值  ,低16一样,高16不一样, 这样&运算结果就会有问题
  <pre>
1111 1111 1111 1111 1111 1010 0111 1100 -> 1111 1111 1111 1111 0000 0101 1000 0011
1111 1111 1111 1110 1111 1010 0111 1100 -> 1111 1111 1111 1110 0000 0101 1000 0010</pre>
<p> 这时就是hash算法的优化,也就是上面是异或,  异或之后 ,低16位现在包含高低16两段的特征
<h4>总结
<p>hash算法的优化：对每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置
<p>寻址算法的优化：用与运算替代取模，提升性能


