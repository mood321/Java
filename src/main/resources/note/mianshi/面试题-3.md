### 记面试题


<p>大概总结
<p> Java并发、mysql、网络、JDK集合、jvm、spring源码、tomcat、linux、系统设计、生产实践


<p>java 集合
<p> <a href="/src/main/resources/note/集合目录.md"> 这个可以看看之前写的集合</a>

<h3>1 HashMap   </h3>
<p><a href="/src/main/resources/note/conllection/HashMap源码分析.md">HashMap源码解析 </a>
<p> 数组+链表+红黑树
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。
<p>
<p>当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。
<p>
<p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。

<h4> hash 算法和寻址优化  (这个原来笔记没有)  </h4>
<pre>
  static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}</pre>

<p>  比如说：有一个key的hash值
<pre>
     1111 1111 1111 1111 1111 1010 0111 1100
     0000 0000 0000 0000 1111 1111 1111 1111
     1111 1111 1111 1111 0000 0101 1000 0011 -> int值，32位
     </pre>
<p> 简而言之就是,高16 不变,低16变成 高16位于低16位异或结果
<h4>寻址算法优化    </h4>
<p>(n - 1) & hash -> 数组里的一个位置
<li> 用& 是因为 & 运算比取摸效率高,当然结果一样,这是个数学问题
<li> &也会导致一个问题 ,高16 的&运算 没有实际意义
<p>假设有两个hash值  ,低16一样,高16不一样, 这样&运算结果就会有问题
  <pre>
1111 1111 1111 1111 1111 1010 0111 1100 -> 1111 1111 1111 1111 0000 0101 1000 0011
1111 1111 1111 1110 1111 1010 0111 1100 -> 1111 1111 1111 1110 0000 0101 1000 0010</pre>
<p> 这时就是hash算法的优化,也就是上面是异或,  异或之后 ,低16位现在包含高低16两段的特征
<h4>总结   </h4>
<p>hash算法的优化：对每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置
<p>寻址算法的优化：用与运算替代取模，提升性能

<h4> HashMap是如何解决hash碰撞问题     </h4>
<p>两个key，多个key，他们算出来的hash的值，与n-1，与运算之后，发现定位出来的数组的位置还是一样的，hash碰撞，hash冲突
<p>get，如果定位到数组里发现这个位置挂了一个链表，此时遍历链表，从里面找到自己的要找的那个key-value对就可以了
<p>假设你的链表很长，可能会导致遍历链表，性能会比较差，O(n)
<p>优化，如果链表的长度达到了一定的长度之后，其实会把链表转换为红黑树，遍历一颗红黑树找一个元素，此时O(logn)，性能会比链表高一些
<p> 转红黑树条件:数组长度64,链表长度8 
<p>当单个桶中元素数量小于6时，进行反树化

<h4> HashMap是如何进行扩容的  </h4>
<p>（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12；
<p>（2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方；
<p>（3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍；
<p>（4）创建一个新容量的桶；
<p>（5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；
<p>如果数组的长度扩容之后 = 32，重新对每个hash值进行寻址，也就是用每个hash值跟新数组的length - 1进行与操作
<pre>
n-1        0000 0000 0000 0000 0000 0000 0001 1111
hash1     1111 1111 1111 1111 0000 1111 0000 0101
&结果    0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）
n-1        0000 0000 0000 0000 0000 0000 0001 1111
hash2     1111 1111 1111 1111 0000 1111 0001 0101
&结果    0000 0000 0000 0000 0000 0000 0001 0101 = 21（index = 21的位置）  </pre>
<p>判断二进制结果中是否多出一个bit的1，如果没多，那么就是原来的index，如果多了出来，那么就是index + oldCap，通过这个方式，就避免了rehash的时候，用每个hash对新数组.length取模，取模性能不高，位运算的性能比较高

<h3> 2  并发编程  </h3>
<p> synchronized实现原理、CAS无锁化的原理、AQS是什么、Lock锁、ConcurrentHashMap的分段加锁的原理、线程池的原理、java内存模型、volatile、对java并发包

<h4> synchronized关键字    </h4>
<p>synchronized关键字，在底层编译后的jvm指令中，会有monitorenter和monitorexit两个指令
<p>每个对象都有一个关联的monitor，比如一个对象实例就有一个monitor，一个类的Class对象也有一个monitor，如果要对这个对象加锁，那么必须获取这个对象关联的monitor的lock锁
<p>他里面的原理和思路大概是这样的，monitor里面有一个计数器，从0开始的。如果一个线程要获取monitor的锁，就看看他的计数器是不是0，如果是0的话，那么说明没人获取锁，他就可以获取锁了，然后对计数器加1

<p>如果一个线程第一次synchronized那里，获取到了myObject对象的monitor的锁，计数器加1，然后第二次synchronized那里，会再次获取myObject对象的monitor的锁，这个就是重入加锁了，然后计数器会再次加1，变成2
<p>这个时候，其他的线程在第一次synchronized那里，会发现说myObject对象的monitor锁的计数器是大于0的，意味着被别人加锁了，然后此时线程就会进入block阻塞状态，什么都干不了，就是等着获取锁
<p>接着如果出了synchronized修饰的代码片段的范围，就会有一个monitorexit的指令，在底层。此时获取锁的线程就会对那个对象的monitor的计数器减1，如果有多次重入加锁就会对应多次减1，直到最后，计数器是0
<p>然后后面block住阻塞的线程，会再次尝试获取锁，但是只有一个线程可以获取到锁

<h4> CAS的理解   </h4>
<p>有多个线程要同时读写类似上面的这种内存里的数据，此时必然出现多线程的并发安全问题
<p>CAS，compare and set
<p>CAS在底层的硬件级别给你保证一定是原子的，同一时间只有一个线程可以执行CAS，先比较再设置，其他的线程的CAS同时间去执行此时会失败

<h4> ConcurrentHashMap实现线程安全的底层原理
<p><a href="/src/main/resources/note/conllection/ConcurrentHashMap.md"> ConcurrentHashMap笔记</a>
<p>JDK并发包里推出了一个ConcurrentHashMap，他默认实现了线程安全性
<p>ps:对同一个元素执行put操作，此时是需要多线程是需要进行同步的
<p>[一个大的数组]，数组里每个元素进行put操作，都是有一个不同的锁，刚开始进行put的时候，如果两个线程都是在数组[5]这个位置进行put，这个时候，对数组[5]这个位置进行put的时候，采取的是CAS的策略
<p>同一个时间，只有一个线程能成功执行这个CAS，就是说他刚开始先获取一下数组[5]这个位置的值，null，然后执行CAS，线程1，比较一下，put进去我的这条数据，同时间，其他的线程执行CAS，都会失败
<p>分段加锁，通过对数组每个元素执行CAS的策略，如果是很多线程对数组里不同的元素执行put，大家是没有关系的，如果其他人失败了，其他人此时会发现说，数组[5]这位置，已经给刚才又人放进去值了
<p>就需要在这个位置基于链表+红黑树来进行处理，synchronized(数组[5])，加锁，基于链表或者是红黑树在这个位置插进去自己的数据
<p>如果你是对数组里同一个位置的元素进行操作，才会加锁串行化处理；如果是对数组不同位置的元素操作，此时大家可以并发执行的

<h6> 总结   </h6>
<p>（1）CAS + 自旋，乐观锁的思想，减少线程上下文切换的时间；
<p>（2）分段锁的思想，减少同一把锁争用带来的低效问题；
<p>（3）CounterCell，分段存储元素个数，减少多线程同时更新一个字段带来的低效；
<p>（4）@sun.misc.Contended（CounterCell上的注解），避免伪共享；（p.s.看笔记）
<p>（5）多线程协同进行扩容；
<h6> 不能解决的问题
<p>1  特定值put
<pre>
 public void unsafeUpdate(Integer key, Integer value) {
     Integer oldValue = map.get(key);
     if (oldValue == null) {
         map.put(key, value);
     }
 }</pre>
<p> putIfAbsent ,null才插入,
<p>另一个方法叫replace(K key, V oldValue, V newValue) 如果传入的ne程池中的最大线程数量。程池中的最大线程数量。程池中的最大线程数量。wValue是null，则会删除元素
<p> 2   不具备原子性  (多线程如果对同一个key操作 )
<p> 自己加锁,保证安全

<h4> JDK中的AQS理解     </h4>
<p> AQS，Abstract Queue Synchronizer，抽象队列同步器
<p>state变量 -> CAS -> 失败后进入队列等待 -> 释放锁后唤醒
<p>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词
<p> 等待线程进入等待队列
<p>ReentrantLock lock = new ReentrantLock();  => 非公平锁

<h4>线程池的底层工作原理   </h4>
<p>系统是不可能说让他无限制的创建很多很多的线程的，会构建一个线程池，有一定数量的线程，让他们执行各种各样的任务，线程执行完任务之后，不要销毁掉自己，继续去等待执行下一个任务
<li>提交任务，先看一下线程池里的线程数量是否小于corePoolSize，也就是3，如果小于，直接创建一个线程出来执行你的任务
<li>如果执行完你的任务之后，这个线程是不会死掉的，他会尝试从一个无界的LinkedBlockingQueue里获取新的任务，如果没有新的任务，此时就会阻塞住，等待新的任务到来
<li>你持续提交任务，上述流程反复执行，只要线程池的线程数量小于corePoolSize，都会直接创建新线程来执行这个任务，执行完了就尝试从无界队列里获取任务，直到线程池里有corePoolSize个线程
<li>接着再次提交任务，会发现线程数量已经跟corePoolSize一样大了，此时就直接把任务放入队列中就可以了，线程会争抢获取任务执行的，如果所有的线程此时都在执行任务，那么无界队列里的任务就可能会越来越多
<p>fixed，队列，LinkedBlockingQueue，无界阻塞队列

<h4> 线程池的核心配置参数   </h4>
<p>创建一个线程池就是这样子的，corePoolSize，maximumPoolSize，keepAliveTime，queue，这几个参数，如果你不用fixed之类的线程池，自己完全可以通过这个构造函数就创建自己的线程池
<li> corePoolSize：指定了线程池中的线程数量。
<li> maximumPoolSize：指定了线程池中的最大线程数量。
<li> keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。
<li> unit：keepAliveTime 的单位。
<li> workQueue：任务队列，被提交但尚未被执行的任务。
<li> threadFactory：线程工厂，用于创建线程，一般用默认的即可。
<li> handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。
<p>拒绝策略如下：
<li>AbortPolicy ： 直接抛出异常，阻止系统正常运行。
<li>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。
<li> DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。
<li> DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。
<li>  以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。   
      
<h4> 线程池中使用无界阻塞队列会发生什么问题   </h4>
<p>在远程服务异常的情况下，使用无界阻塞队列，是否会导致内存异常飙升？
<p>调用超时，队列变得越来越大，此时会导致内存飙升起来，而且还可能会导致你会OOM，内存溢出

<h4> 线上机器突然宕机，线程池的阻塞队列中的请求  ?    </h4>
<p>必然会导致线程池里的积压的任务实际上来说都是会丢失的
<p>如果说你要提交一个任务到线程池里去，在提交之前，麻烦你先在数据库里插入这个任务的信息，更新他的状态：未提交、已提交、已完成。提交成功之后，更新他的状态是已提交状态
<p>系统重启，后台线程去扫描数据库里的未提交和已提交状态的任务，可以把任务的信息读取出来，重新提交到线程池里去，继续进行执行

<h3> Java内存模型    </h3>
<p> 之前计算机组成原理写过一些( 说下volatile 在java中的实现)
<p>Java 提供给我们的 8 个原子操作：lock、unlock、read、load、use、assign、store、write
<p>一个变量从主内存拷贝到工作内存，再从工作内存同步回主内存的流程为：

>|主内存| -> read -> load -> |工作内存| -> user -> |Java线程| -> assign -> |工作内存| -> store -> write -> |主内存|

<p> 8 个原子操作
<li>lock：作用于主内存，把一个变量标识为一个线程独占状态。
<li>unlock：作用于主内存，释放一个处于锁定状态的变量。
<li>read：作用于主内存，把一个变量的值从主内存传输到线程工作内存中，供之后的 load 操作使用。
<li>load：作用于工作内存，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
<li>use：作用于工作内存，把工作内存中的一个变量传递给执行引擎，虚拟机遇到使用变量值的字节码指令时会执行。
<li>assign：作用于工作内存，把一个从执行引擎得到的值赋给工作内存的变量，虚拟机遇到给变量赋值的字节码指令时会执行。
<li>store：作用于工作内存，把工作内存中的一个变量传送到主内存中，供之后的 write 操作使用。
<li>write：作用于主内存，把 store 操作从工作内存中得到的变量值存入主内存的变量中。
<p>主内存对应 系统内存空间,工作内存对应CPU高速缓存内存
<li>use 操作必须与 load、read 操作同时出现，不能只 use，不 load、read。
<ul>use <- load <- read     </ul>     

<p> 使用时必须去取主内存

<li>assign 操作必须与 store、write 操作同时出现，不能只 assign，不 store、write。
<ul>assign -> store -> write

<p> 更新必须写主内存


<h4> Java内存模型中的原子性、有序性、可见性</h4>
<p> Java内存模型 -> 原子性、可见性、有序性 -> volatile -> happens-before / 内存屏障
<p> 可见性
<p> 如果有一个线程修改了,会让其他线程工作空间的值失效,重新读主内存的值
<p> 原子性
<p>data++，必须是独立执行的，没有人影响我的，一定是我自己执行成功之后，别人才能来进行下一次data++的执行
<p>有序性
<p> 对于代码，同时还有一个问题是指令重排序，编译器和指令器，有的时候为了提高代码执行效率，会将指令重排序，就是说比如下面的代码
<p> 具备有序性，不会发生指令重排导致我们的代码异常；不具备有序性，可能会发生一些指令重排，导致代码可能会出现一些问题

<h4>volatile关键字的原理</h4>
<p>volatile关键字是用来解决可见性和有序性，在有些罕见的条件之下，可以有限的保证原子性，他主要不是用来保证原子性的


<h4> 指令重排以及happens-before原则</h4>
<p> volatile关键字和有序性的关系，volatlie是如何保证有序性的，如何避免发生指令重排的
<p>根据语义，Happens-Before，就是即便是对于不同的线程，前面的操作也应该发生在后面操作的前面，也就是说，<strong>Happens-Before 规则保证：前面的操作的结果对后面的操作一定是可见的</strong>。</p>
<p><strong>Happens-Before 规则本质上是一种顺序约束规范，用来约束编译器的优化行为</strong>。就是说，为了执行效率，我们允许编译器的优化行为，但是为了保证程序运行的正确性，我们要求编译器优化后需要满足 Happens-Before 规则。</p>
<p>根据类别，我们将 Happens-Before 规则分为了以下 4 类：</p>
<ul>
<li>操作的顺序：
<ul>
<li><strong>程序顺序规则：</strong> 如果代码中操作 A 在操作 B 之前，那么同一个线程中 A 操作一定在 B 操作前执行，即在本线程内观察，所有操作都是有序的。</li>
<li><strong>传递性：</strong> 在同一个线程中，如果 A 先于 B ，B 先于 C 那么 A 必然先于 C。</li>
</ul>
</li>
<li>锁和 volatile：
<ul>
<li><strong>监视器锁规则：</strong> 监视器锁的解锁操作必须在同一个监视器锁的加锁操作前执行。</li>
<li><strong>volatile 变量规则：</strong> 对 volatile 变量的写操作必须在对该变量的读操作前执行，保证时刻读取到这个变量的最新值。</li>
</ul>
</li>
<li>线程和中断：
<ul>
<li><strong>线程启动规则：</strong> <code>Thread#start()</code> 方法一定先于该线程中执行的操作。</li>
<li><strong>线程结束规则：</strong> 线程的所有操作先于线程的终结。</li>
<li><strong>中断规则：</strong> 假设有线程 A，其他线程 interrupt A 的操作先于检测 A 线程是否中断的操作，即对一个线程的 <code>interrupt()</code> 操作和 <code>interrupted()</code> 等检测中断的操作同时发生，那么 <code>interrupt()</code> 先执行。</li>
</ul>
</li>
<li>对象生命周期相关：
<ul>
<li><strong>终结器规则：</strong> 对象的构造函数执行先于 <code>finalize()</code> 方法。</li>
</ul>
</li>
</ul>
<p>规则制定了在一些特殊情况下，不允许编译器、指令器对你写的代码进行指令重排，必须保证你的代码的有序性
<p>指令重排 -> happens-before -> volatile起到避免指令重排

<h4> volatile底层是如何基于内存屏障保证可见性和有序性的？</h4>
<p> 内存模型 -> 原子性、可见性、有序性 - > volatile+可见性 -> volatile+有序性（指令重排 + happens-before） -> voaltile+原子性 -> volatile底层的原理（内存屏障级别的原理）

<h5>lock指令：volatile保证可见性</h5>
<p>对volatile修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写回主内存，同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改
<p>如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了
<p>lock前缀指令 + MESI缓存一致性协议

<h5> volatile 的有序实现</h5>
<p>对于volatile修改变量的读写操作，都会加入内存屏障
<p>每个volatile写操作前面，加StoreStore屏障，禁止上面的普通写和他重排；每个volatile写操作后面，加StoreLoad屏障，禁止跟下面的volatile读/写重排
<p>每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和voaltile读重排；每个volatile读操作后面，加LoadStore屏障，禁止下面的普通写和volatile读重排

<p>synchronized、volatile，底层都对应着一套复杂的cpu级别的硬件原理，大量的内存屏障的原理；lock API，concurrenthashmap，都是各种复杂的jdk级别的源码，技术深度是很深入的


<h3> Spring</h3>

<h4>Spring的 IOC 机制</h4>
<p>Spring IOC框架，控制反转，依赖注入
<p>tomcat在启动的时候，直接会启动spring容器
<p>spring ioc，spring容器，根据xml配置，或者是你的注解，去实例化你的一些bean对象，然后根据xml配置或者注解，去对bean对象之间的引用关系，去进行依赖注入，某个bean依赖了另外一个bean
<p>底层的核心技术，反射，他会通过反射的技术，直接根据你的类去自己构建对应的对象出来，用的就是反射技术
<p>spring ioc，系统的类与类之间彻底的解耦合

<h4> pring的AOP机制的理解</h4>
<p> spring核心框架里面，最关键的两个机制，就是ioc和aop，根据xml配置或者注解，去实例化我们所有的bean，管理bean之间的依赖注入，让类与类之间解耦，维护代码的时候可以更加的轻松便利
<p>他有几个概念，可以做一个切面，语法、用法、术语和概念
<p>做一个切面，如何定义呢？MyServiceXXXX的这种类，在这些类的所有方法中，都去织入一些代码，在所有这些方法刚开始运行的时候，都先去开启一个事务，在所有这些方法运行完毕之后，去根据是否抛出异常来判断一下，如果抛出异常，就回滚事务，如果没有异常，就提交事务 => AOP

<p>spring在运行的时候，动态代理技术，AOP的核心技术，就是动态代理
<p>他会给你的那些类生成动态代理,把你本身的类注入到代理类
<p>事务，mysql，数据库里都提供一个事务机制，我们如果开启一个事务，在这个事务里执行多条增删改的sql语句，这个过程中，如果任何一个sql语句失败了，会导致这个事务的回滚，把其他sql做的数据更改都恢复回去
<p>在一个事务里的所有sql，要么一起成功，要么一起失败，事务功能可以保证我们的数据的一致性，在业务逻辑组件里去加入这个事务

<h4>cglib动态代理？他跟jdk动态代理的区别</h4>
<p> 其实就是动态的创建一个代理类出来，创建这个代理类的实例对象，在这个里面引用你真正自己写的类，所有的方法的调用，都是先走代理类的对象，他负责做一些代码上的增强，再去调用你写的那个类
<p> spring里使用aop，比如说你对一批类和他们的方法做了一个切面，定义好了要在这些类的方法里增强的代码，spring必然要对那些类生成动态代理，在动态代理中去执行你定义的一些增强代码
<p> 如果你的类是实现了某个接口的，spring aop会使用jdk动态代理，生成一个跟你实现同样接口的一个代理类，构造一个实例对象出来，jdk动态代理，他其实是在你的类有接口的时候，就会来使用
<p> 很多时候我们可能某个类是没有实现接口的，spring aop会改用cglib来生成动态代理，他是生成你的类的一个子类，他可以动态生成字节码，覆盖你的一些方法，在方法里加入增强的代码

<p> AspectJ和spring aop
<p> AspectJ是一个代码生成工具
<p> AspectJ有自己的类装载器，支持在类装载时织入切面，即所谓的LTW机制
<p> AspectJ同样也支持运行时织入，运行时织入是基于动态代理的机制。（默认机制）
<p>spring aop是aop实现方案的一种，它支持在运行期基于动态代理的方式将aspect织入目标代码中来实现aop。
<p>但是spring aop的切入点支持有限，而且对于static方法和final方  法都无法支持aop（因为此类方法无法生成代理类）；另外spring aop只支持对于ioc容器管理的bean，其他的普通java类无法支持aop。同时spring整合了aspectj，使得在spring  体系中可以使用aspectj语法来实现aop

<h4>Spring中的Bean是线程安全的吗？</h4>
<p>Spring容器中的bean可以分为5个范围：

<li>（1）singleton：默认，每个容器中只有一个bean的实例
<li>（2）prototype：为每一个bean请求提供一个实例
<p>一般来说下面几种作用域，在开发的时候一般都不会用，99.99%的时候都是用singleton单例作用域
<p>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收
<p>（4）session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效
<p>（5）global-session
<p>答案是否定的，绝对不可能是线程安全的，spring bean默认来说，singleton，都是线程不安全的，java web系统，一般来说很少在spring bean里放一些实例变量，一般来说他们都是多个组件互相调用，最终去访问数据库的
<p> 如果bean 有变量,多个请求是会不安全的
