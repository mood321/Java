1、回顾一下YGC的过程：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/16294800_1641211651.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

（1）暂停系统程序运行

（2）选择需要回收的region

（3）标记所有存活对象

（4）复制对象操作

（5）清理垃圾，释放region

2、mixed gc有那些步骤？

Mixed gc（混合回收）主要有以下步骤：

① 初始标记阶段

标记出所有由 gc roots（及RSet）直接引用的对象，会暂停程序运行

② 并发标记阶段

标记出所有①中标记的对象所引用的对象。不会stop the world

③ 最终标记阶段

这个阶段是标记出②中所有没有被标记到的对象。（主要是程序还在运行产生的一些新对象）。会stw

④ 存活对象计数

对每个区域中被标记的对象进行计数。即统计出每个region存活对象的数量

⑤ 垃圾回收阶段

需要stw。这个阶段会选择性价比比较高的region，把存活对象复制到新的分区，然后回收掉选择的那些分区。

上述其实就是mixed gc（混合回收）的大概步骤。大家还记不记得我们前面分析gc的转换关系？在ygc之后，有可能会进入mixed gc并发标记阶段。

大家是不是觉得奇怪？为啥没有初始标记阶段啊？Mixed gc在某次ygc之后，就直接开始进入并发标记阶段了？

 

3、young gc和mixed gc的关系

大家回顾一下，在young gc的时候，是不是也有gc roots标记这个步骤？我们当时的说法是，把所有新生代相关的gc roots + 老年代引用新生代的RSet作为根，也就是标记的起始点，开始去标记。

实际上，gc roots本身是没有所有老年代，新生代的区分的。所以，在新生代做标记的时候，会把所有gc roots直接引用的对象全部都标记，而处理的时候，只处理新生代的就OK了。

所以说，young gc其实是mixed gc的前奏，young gc可以算作是mixed gc的初始标记阶段。

这也就解释了我们上面的那个问题，为啥在那个转换图里面，直接就进入并发标记阶段了。

因为如果ygc 结束，开启的并发标记的时候，实际上就代表了mixed gc已经走完了初始标记阶段，ygc已经干完了初始标记阶段的活儿了。

 

4、mixed gc的并发标记是从那些对象开始的？

从逻辑上来讲，并发标记阶段，实际上就是把gc roots直接引用的对象中的一个一个字段全部都给遍历一遍，找到所有的间接引用的存活对象，然后打上存活标记。

这样子，肯定可以找到gc roots直接+间接引用的所有的存活对象。而实际上的实现不是这样子的。

其实，我们可以自己思考一下，经过了ygc之后，所有在新生代的gc roots直接引用，间接引用的存活对象，是不是都在survivor 区了？并且老年代引用的新生代的存活对象也全部都在survivor区了。

那么，还剩下哪些对象需要我们全部找出来？是不是就是老年代所有的存活对象？老年代的所有存活对象，怎么找呢？

首先除了新生代里面包含的那部分gc roots直接引用的对象，还有一部分gc roots直接引用的对象，在老年代，我直接拿gc roots找到他们。

那么此时是不是就可以确定并发标记的起始点了：
survivor区的对象+老年代gc roots直接引用的对象 + 老年代的RSet。为什么要加上这个RSet？

原因很简单，混合回收，肯定不可能直接把老年代整个都遍历一遍吧！所以肯定要用RSet来作为起始点出发，找到跨分区引用的引用链。从而找到存活对象。

 

5、思考题：mixed gc（混合回收）的标记还需要做哪些内容？

提示：要从老年代选择性价比最高的一些区域来回收。

 

性价比相关的标记是不是要做？前面我们说位图会在并发标记阶段使用，大家思考一下位图在这里应该怎么用？性价比我们又该怎么算？