本节主要内容：

对象分配的基本流程

对象分配的效率会存在什么问题？

G1中对象分配是怎样的流程？

G1采取了什么方式来优化对象分配的效率？

 

1、G1中是怎么分配一个对象的？

首先，系统程序运行，分配一个对象，肯定是先找新生代的eden区来存储，在G1里面，就是从eden包含的region里面选择一个region来做对象的分配。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1241700_1640327337.png)

但是我们想想，如果说，有两个线程，同时要找其中一个region来分配对象，并且，两个线程刚刚好找到了某个region里面的同段内存，这个时候怎么办？岂不是要冲突了？很简单，和我们写代码同样的道理，这个时候出现了并发安全问题。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/5183100_1640327337.png)

2、如何解决对象创建过程的冲突问题？

一个简单的思路：加锁！线程1在分配对象的时候，直接对堆内存加个锁！分配完成之后，再由线程2进行对象的分配！此时一定不会出现并发的问题。

为什么要对堆内存进行加锁？因为对象分配的过程是非常复杂的，不单单是分配一个对象，还要做引用替换，引用关系处理，region的一些元数据的维护，对象头的一些处理等等，非常复杂，所以只是锁一个region，或者只是锁一段内存是不够的，所以只能锁整个堆内存。

是一个堆内存的全局的一组元数据。

 

但是新的问题出现了，这个分配效率很显然低的要命！那么如何解决这个分配的效率问题？

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/38511300_1640327337.png)

3、无锁化分配 ——G1的快速分配原理TLAB撞针分配

我们思考一下，如果要解决并发安全问题，一般有几种思路

（1）使用锁

（2）使用CAS这种自旋模式（和锁的思想类似）

（3）使用自己本地的内存，自己改自己的

那么G1采取的就是本地缓冲区的思想来分配的，TLAB全称，Thread Local Allocation Buffer。也就是说，每个线程都有一个自己线程的本地分配缓冲区，专门用于对象的**快速分配。**

**改变引用关系，是另外一套异步机制。**

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/37470600_1640327337.png)

这个缓冲区，保证了一个线程过来的时候，尽可能的走这个TLAB来分配对象，能够做到快速分配，并且实现了无锁化分配。

TLAB可以直接用来分配对象，那怎么分配TLAB？

4、只需要在分配TLAB的时候对堆内存加锁，大大减少了锁冲突，导致串行化执行的问题

分配TLAB，可能也就是跟线程数量是一致。也就是执行几十次，最多上百次就OK。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/40637700_1640327337.png)

如图所示，只有在线程需要分配TLAB的时候才会对堆内存加一个全局锁。如果不需要分配TLAB就直接快速分配一个对象，大大提升了效率。

 

思考：既然要分配TLAB，那什么时候分配TLAB？分配多大？TLAB占满了怎么办？如果实在没有办法用TLAB的方式分配，有没有什么兜底的策略？

TLAB不能无限大，并且一定有占满的时候，并且，占满了以后，程序肯定要继续运行。这个时候，应该怎么办？