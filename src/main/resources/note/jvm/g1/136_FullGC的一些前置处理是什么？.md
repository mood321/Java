回顾：

1、被选中的CSet

2、XX:G1MixedGCLiveThresholdPercent参数

3、混合回收是否要执行的条件

4、MixedGC的最后一步，垃圾回收过程

5、分批次回收选择的region个数限制

 

本节内容：

1、对象分配失败就会进入FULL GC的流程

前面我们在讲对象分配的时候有讲到，在对象分配过程中，TLAB不够，会扩展新的TLAB，region不够，从自由分区拿，自由分区不够，从堆内存扩展，扩展失败，就垃圾回收清理出一些空闲region，垃圾回收的过程是YGC，MixedGC，如果还是无法分配对象，就进入FULL GC。

整体流程如下：

TLAB分配 --> 扩展TLAB进行分配 --> 申请新的TLAB --> 从自由分区新的region给新生代--> 堆内存扩展分区给新生代 --> 垃圾回收（YGC、MixedGC）--> FULL GC（第一次） --> FULL GC（第二次，回收软引用）

那么在Full GC之前，我们看的出来，G1会做一系列的尝试，去尝试搞一块儿内存来给系统程序分配对象。如果实在是失败了就只能进入Full GC了。那么，在Full GC之前，也就是Full GC的一系列操作失败之前，到底会做什么？

为什么要问这个问题呢，大家想想看，如果说，前面的过程，我只进行了一半儿，比如说，我在进行GC的时候，发现一部分对象复制成功了，一部分找不到足够的空闲空间来复制，但是我扩展又扩展不到新的内存。如图所示：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/46412100_1641818626.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

此时，怎么办呢？有些已经复制完成了，有些准备复制，又无法找到多余的空间给它复制，比如对象O3，找不到空间给他存，那么此次的GC是不是要失败了？对于已经复制成功的，我们可以不用管它，因为他们接下来肯定是要被回收掉的。对于没有复制成功的，我们怎么办？

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/46779700_1641818626.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

2、对已经成功的对象做更新RSet处理，对失败的对象，做恢复处理

我们在讲GC的时候说过，对象是复制到一个新的分区，然后再更新引用，最后清理掉垃圾对象的。那么在我们这个场景里面，部分已经复制成功的对象，我们可以考虑直接把它保持原状不变，那么已经复制成功的这些对象所在的新位置，继续保持原来的引用关系，老的对象直接给它一个dummy对象的标记，在后面出现GC的时候，就可以直接回收掉了。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/47429900_1641818626.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

注意看，图中的所有复制成功的对象，都会被标记成dummy对象。然后复制成功的对象，接下来要更新对应的卡表，RSet相关的信息。更新完成后，其实这些复制成功的对象就可以正常使用，而他们原来所在的位置的对象是dummy对象，在GC的时候就可以被识别到，然后就可以被回收掉了。

那么对于复制失败的对象，我们其实要对它稍微做一些处理。

 

3、对复制失败的对象做自引用处理

对象的复制过程其实是一个相对比较复杂的过程。这里简单给大家描述一下：一个对象复制，首先对象头里面有一些引用信息啊，加锁信息啊，GC标记状态等等……那么如果我们要复制这个对象，这个对象的地址，肯定是会变化的，但是我们知道对象的引用，其实引用的是一块儿地址，也就是说，如果对象要进行复制，对象头势必要发生改变，比如对象头中描述对象所在位置的信息。如图所示：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/44402100_1641818626.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

其实在对象复制的时候，对象头是需要处理掉的。而且这个操作，在对象复制之前，也就是说，如果说我要复制一个对象，对象不管复制成功与否，对象头都会发生改变。那如果我复制失败了，此时对象头改变了，但是我对象又没有复制成功。如果对象头不被恢复的话，肯定是有问题的对吧？所以此时就需要做一些操作，要去把对象头给恢复回来。

 

4、如何恢复对象头？

首先，对象先不要被识别成dummy或者垃圾对象什么的。一定是需要有一个引用的，先把对象做活再说，对不对？但是这个引用由谁来引用呢？随便找一个对象吗？那如果这个对象被回收了呢？咋整？

所以，G1就会搞一个自引用指针，也就是把对象的指针指向它自己。这样子会让这个对象有独一无二的特点，一旦JVM在任何一个过程中，发现一个对象的指针指向了自己，那就认为，是需要恢复对象头的对象。然后就去恢复这个对象的对象头。

G1在对象复制的过程中，比较慎重，会把对象复制成功前的一些对象头信息专门保存起来，恢复的时候就从那里去恢复。

所以其实JVM就是用了一个简单对象的指针指向自己的方式（自引用的方式）来做这个对象头恢复的标识。然后去找到对象头信息去把对象头恢复。

 

5、恢复对象头之后的其他恢复操作 Redirty恢复RSet

对象头恢复后，还没有万事大吉，首先这个自引用肯定是需要删除的。然后因为是复制失败的过程，其中一部分对象是复制成功了的，所以，需要执行redirty操作，重构整个RSet，把RSet更新的最终状态。此时复制成功的对象和复制失败的对象就都恢复到了正常状态。然后才可以执行后续的Full GC操作