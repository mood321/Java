- 回顾：

  G1为了提升GC标记效率做了哪些设计？

  （1）记忆集

  （2）卡表+位图

   

  本节内容：

  1、怎么标记一个对象？

  2、跨代引用会造成什么问题？

  3、怎么记录跨代的引用关系？ --- RSet记忆集

  4、在G1中有多少种引用关系？哪些需要记录？

   

  1、怎么标记一个对象？

  我们需要思考，如果说，我们需要标记一个对象为垃圾对象，或者标记一个对象为存活对象，要通过什么方式来判断？

  其实很多有JVM基础的同学是大概知道的，简单来说就是通过GC ROOTS，追踪引用关系来标记，如果一个对象被gc roots引用或者被gc roots引用的对象引用了，那么就标记为存活对象，否则就标记为垃圾对象，然后就可以对垃圾对象进行回收了。

   

  那么如何知道引用关系呢？

   

  最简单的方式就是，其实也是最准确无误的方式，我从GC roots 出发，一个一个对象去遍历，把每一个对象的每个字段引用的内容都遍历一下，就能找出来引用关系了。其实这个时候同时也把标记做好了。

  ![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/82073900_1640665646.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

  如果出现了跨代引用，会有问题。比如说老年代里面的一个对象引用新生代，那么我们用新生代的gc roots能找全吗？

  老年代的一些对象，可能也需要加入到新生代的gc roots里面去。

   

  2、跨代引用会造成什么问题？

   

  那么思考一个问题，我们知道G1本身也是有分代的，那么如果我要触发young gc，在某种特殊情况下，有一个老年代的对象引用了新生代的对象，那么我怎么找到这个老年代的对象？因为我找不到这个对象，我就没办法找到这个老年代对象引用了哪些新生代对象。

   

  大家注意，young gc，针对的是整个新生代的空间，也就是，我会选择所有新生代的region，拿到gc roots，遍历整个新生代。

   

  也就是说，找不到老年代对新生代的引用关系，那么垃圾回收的时候就可能会出现误操作，要么多清理，要么少清理，其实不管是多清理或者少清理，其实都比较麻烦。

   

  多清理，系统直接报错了。

  少清理，垃圾对象占用新生代，可能会更加频繁的GC。

   

  所以这个引用关系是必须知道的，那我应该怎么拿到这个引用关系？其实就是需要找到那些老年代的对象引用了新生代的那些对象？说白了就是，要找到老年代里面引用了新生代对象的那些对象。怎么找？

  最最简单的方式就是，我直接把老年代也遍历一边儿，看看引用关系！

  但是大家要明白，我们做的是新生代的回收，把老年代也遍历一边儿，是不是太不合理了？标记时间会非常长，而且遍历整个老年代，从分代隔离回收这个基本思路上来看，也非常非常不合适！

   

  ![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/85774400_1640665646.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

   

  那么我们怎么记录跨代的引用关系？

   

   

  3、怎么记录跨代的引用关系？ --- RSet记忆集

   

  思路其实也很简单。举个例子：

  假如我们很多块儿region，一部分属于新生代，一部分属于老年代，老年代的对象引用了新生代的对象，我直接针对被引用对象搞一块儿内存，用来存储到底是谁引用了我。

  ![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/86374700_1640665646.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

  当遍历新生代所有对象前，直接把这块儿内存里面的引用了我的那个对象，也给加入到gc roots里面，然后进行遍历。这样子就能避免遍历老年代整个分代了。

  从效率，从分代隔离的层面，这样做都是非常合理的。

  ![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/85391400_1640665646.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

  记忆集的维度应该是什么？针对新生代和老年代各搞一个？还是针对region每个region都搞一个？

  对于G1来说，它是以region为最小内存管理维度的，它的RSet记忆集的维度是对每一个region，都搞一块儿内存，存储region里面所有的对象被引用的引用关系。

  针对region这个维度，是因为，每次回收之后，老年代，新生代，大对象区域的region可能都会变化，所以，如果说，对每个分代都搞一份儿的话，不太合理，因为region不断的在变化，同时也会有并发问题，效率问题。

  同时，除了新生代的回收是需要选择所有新生代的region，老年代的回收，是需要找性价比高的region来回收的，也就是选择一部分去回收，那么选择一部分回收的时候，还要去整个分代对应的这么一大块儿引用关系数据，去做遍历，筛选，才能拿到需要的数据。

  ![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/86492700_1640665646.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

  那么最终，G1就选择了使用Rset记忆集这种方式，记录了这些引用关系，方便在进行垃圾回收的时候去找到有哪些GC roots，大大减少了不必要的遍历操作。

   

  4、在G1中有多少种引用关系？哪些需要记录？

  （1）region分区内部的引用关系

  （2）新生代region 到 新生代region有引用关系

  （3）新生代region 到 老年代region有引用关系

  （4）老年代region 到 新生代region有引用关系

  （5）老年代region 到 老年代region有引用关系

  G1种的引用关系一共就这么几种，那么到底哪些需要记录？我们思考下面这个问题：

  如果不记录，会不会造成漏标记，或者说，漏回收的情况？如果一定会出现这个现像，那么就必须要记录下来。

  针对上述的几种情况，我们来分析以下：

  （1）region内部的引用关系

  因为是内部的，不管是做新生代，还是老年代，还是full gc的回收，在gc roots标记的过程种，是一定可以追踪到这种引用关系的。因为只要被选中的分区，所有的对象一定都会被遍历，所以，内部的引用关系，一定会被全部都遍历一遍。因此不需要记录

  （2）新生代和新生代间的引用关系

  这个其实和region内部的原理是一样的，新生代gc的时候肯定可以全部遍历一遍，所以不需要记录。老年代gc的话，和这种新生代间的引用关系又没啥相关联的地方。

  （3）新生代到老年代的引用关系

  假如说，要进行新生代的回收，因为是新生代引用了老年代的对象，就算遍历到了，新生代gc也不会去动老年代的对象，并且这种引用关系在新生代回收的过程中，一定会被遍历到。

  假如说，要进行老年代的回收，老年代region需要知道谁引用了我，不然可能会出错。但是我们要知道，gc回收过程是没有老年代单独的回收的，所以如果要回收老年代的时候，肯定是会带着一次新生代回收，或者直接full gc的，所以也不需要记录。

  （4）老年代到新生代的引用

  这个很明显是需要记录的，上面我们已经分析了这个内容

  （5）老年代到老年代的引用

  假如进入到了mixed回收，那么此时老年代只会选择回收部分region对吧？所以，进入这个mixed混合回收的时候，如果只需要选择部分region进行回收，那其他的region我们肯定不想去遍历，所以，我们还是要记录以下老年代到老年代的引用关系，避免在mixed回收的时候，需要整个老年代都要遍历。

   

  5、思考：RSet里面到底是怎么存的？G1是怎么设计引用关系存储结构的？