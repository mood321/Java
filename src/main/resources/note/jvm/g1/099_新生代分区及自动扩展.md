本节内容：

1、G1的分代模型设计

2、新生代内存分配

3、G1的新生代内存应该怎么设置才合理？它有什么机制？

4、G1的内存动态扩展机制是怎样的？

5、思考题：是什么东西在保证停顿时间？

 

1、G1基于逻辑分代模型的设计

G1垃圾回收器，其实也是基于分代模型来做的。使用逻辑分区的概念来完成整个G1的设计，一部分region属于新生代，一部分老年代，一部分大对象，还有一部分是自由分区，对象分配，也是先进新生代的eden区。

 

2、新生代内存分配方式

Xmx 最大值 Xms是最小值，设置堆内存大小。InitialHeapSize堆内存的初始大小 默认0

MaxHeapSize 96MB

 

（1）参数指定方式

第一种：指定堆内存新生代的大小，具体参数：MaxNewSize、NewSize，需要注意的是，如果说只设置了Xmn这个参数，在G1里面，默认是认为相当于设置了MaxNewSize = NewSize = Xmn 如果设置了，说明新生代内存的大小是固定的。

定死了新生代内存的大小，就意味着，在做ygc的时候，很有可能停顿预测模型没有办法生效。停顿预测模型+动态调整机制，保障我们GC百分之九十能够保持在某个停顿时间内的关键。

第二种：指定了新生代的占比，具体参数：NewRatio，这个参数是用来设置老年代比新生代的比例的。例如，-XX:NewRatio=4，则代表老年代：新生代=4：1，需要注意的是，如果**只设置了****NewRatio**，则对于新生代而言，MaxNewSize = NewSize，也就是新生代最大值最小值是相等的，即新生代空间大小 = heapSize / (NewRatio+1)，如果设置了MaxNewSize、NewSize，同时又设置了NewRatio，此时NewRatio会被忽略。

**注意：一般来说，在****G1****垃圾回收器里面，我们不推荐直接自己指定新生代的大小，并且指定成一个固定值。**

 

（2）G1启发式推断

第三种：没有指定新生代MaxNewSize最大值和NewSize最小值，或者只设置了其中一个，G1会根据G1MaxNewSizePercent（默认60%）和G1NewSizePercent（5%），来计算新生代内存大小。

如果我们没有设置新生代的大小，或者说只设置了MaxNewSize 和 NewSize其中一个，此时新生代初始化的大小就是5%的堆内存空间，然后最大就是60%。

如果只设置了NewRatio，其实也是无法达到自动计算新生代空间的效果。

一般来说，都是设定好堆内存的大小，然后新生代比例，新生代内存的大小，就让G1自动推断就好。

除非，你系统运行了很长时间，你发现了一个非常合理的**新生代的范围**，那么你可以考虑，把新生代的内存设置一下，一定是MaxNewSize 和 NewSize不相等 100 10。

 

（3）老年代内存是多少？

老年代内存没有一个固定的大小，也没有具体的参数来设置，除非是设置了NewRatio这个参数，会间接设置老年带的大小。

-XX:InitiatingHeapOccupancyPercent这个参数，代表老年代45%的内存占用的时候会触发mixedgc，也就是混合回收。老年代内存使用的比例，默认最高是45%。

 

3、我们应该怎么设置G1的新生代内存的大小？

必须要满足动态扩展机制，结合GC和停顿预测模型能够满足停顿时间的一个设置

（1）如何满足G1新生代的动态扩展机制？

不要自己指定新生代的大小为一个固定值，不要直接指定Xmn，也不要直接只设置一个NewRatio，指定MaxNewSize = NewSize，真的需要自己设置新生代的值，可以设置成范围，比如，MaxNewSize=100 NewSize=10，但是这个范围如果你设置的不是很合理，很有可能还是会有性能问题。

 

（2）为什么要满足G1新生代的动态扩展？

为了满足用户设定的停顿时间，也就是期望停顿时间，满足期望停顿时间，就需要做一个垃圾回收时间和程序运行时间的平衡。控制回收时间在一个范围内，就只能根据我们回收的时间，回收的内存空间的大小来做综合计算。动态调整内存分区的占比，来满足回收时间。如果不做动态调整，那么GC时间过长，就没办法满足停顿时间。动态增加，动态减少，才能调整到一个合理的值。一旦超过了时间范围，就再调整一下。

G1的新生代的动态扩展，可以帮助我们做到，动态调整YGC所需要的时间。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/7547100_1640327037.png)

（3）新生代的动态扩展是怎么实现的？

正常来说，我们直接设置的MaxNewSize=100MB NewSize=10MB，最小值，最大值都有，最小值10分区（region）10MB,100个分区100MB，需要扩展分区的时候（此时是最小分区数量），就相当于要拿一些分区给新生代。

 

每一种类型的分区有一个分区列表，新生代分区列表，老年代分区列表，大对象，自由分区。如果说新生代需要扩展的时候，此时就从自由分区拿一些region，加入到新生代分区列表中。

如果说，自由分区没有了，无法给新生代提供分区了，这个时候怎么办？找JVM去拓展新的分区，然后加入到新生代分区列表中，然后继续分配对象。

堆内存使用 200MB 总共给了500MB，此时就需要去拓展比如：100MB

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/11885700_1640327037.png)

 

思考一下：从堆内存扩展新的分区的时候，什么时候去扩展？扩展多少？

 

4、G1是怎么扩展新分区的？有什么规则限制？

200MB，500MB，如果说我直接扩展个400MB，能扩展吗？

（1）扩展新分区的规则是什么？

是根据-XX:GCTimeRatio这个参数去控制。这个参数表示，GC与应用的耗费时间比，G1中默认这个值是9，意思是，如果G1 GC时间与应用运行的时间占比不超过10%的时候，不需要动态扩展，如果GC时间占比超过了这个阈值，就需要做动态扩展。

 

（2）扩展的内存大小分区数量有什么限制？

有一个参数G1ExpandByPercentOfAvailable（默认是20），也就是说，每次扩展的时候都从未使用的内存中申请20%的空间。并且，最小不能小于1MB，最大不能超过已经使用内存的一倍。 例如 10G，然后我计算出来，未使用 * 20% > 10G，那就按照10G来算。

例如：我们现在堆内存一共最大64GB，使用了32GB，如果要做一次扩展，就要用，64-32里面申请20%的空间出来。如果说，按照公式计算，发现20%乘以未分配的内存，是小于1MB的，此时，就给1MB。下限是1MB，上限是，当前已经分配的内存的一倍。也就是，我们这次32GB * 20% 大于了当前已经使用的内存的一倍，也就是32GB，此时是只给1倍，不会按照计算出来的结果来分配。