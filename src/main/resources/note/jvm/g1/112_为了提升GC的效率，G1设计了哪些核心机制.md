对象分配：TLAB机制，快速分配，相当于它设计了一套提升分配效率的机制。

 

1、RSet记忆集 Remember Set

我们知道JVM使用的垃圾回收的算法，其中是包括标记算法，标记出来需要回收的对象，和存活对象，然后进行垃圾回收，根对象（gc roots）可达性分析算法。即从根对象（gc roots）出发，标记所有存活对象，然后遍历对象的每一个字段，继续标记，直到所有的对象标记完毕。 要么是存活对象，要么是垃圾对象需要被回收。

 

而分代模型的JVM　GC中，老年代和新生代的回收，一般都是不同的，新生代一般都是先触发，实在是无法腾出足够的空间，才会进入老年代GC，或者是full gc。在G1中，其实也差不多。先新生代回收，然后实在不行，就MIXED，然后最后才可能会full gc。

 

而RSet记忆集，就是针对分代模型垃圾回收，设计的一个数据结构。简单来说，由于新生代，老年代gc的阶段是不同的，所以假如我们只回收新生代，此时还是按照上面的gc roots可达性分析算法，就会把老年代全部都给标记一遍，而我们又不收集老年代，这样就会非常浪费时间。

新生代对象，一定只有新生代引用吗？有可能会有老年代的对象引用新生代的对象。那我们直接在触发新生代gc的时候，我们在老年代的里面有一些对象也在我们的引用链中。

怎么拿到老年代中引用新生代的那些对象？如果没有RSet，那我怎么找到引用了新生代的对象的那些老年代年代对象？

 

同样的道理，如果说，我们要回收老年代，我们也需要把其他代的所有对象遍历一遍，非常耗时。

RSet记忆集，就是为了解决这种问题而设计的。RSet记忆集，用一组key - value结构，记录了跨代引用的引用关系，在gc的时候，可以快速的借助记忆集+gc roots搞定同代引用及跨代引用的可达对象分析问题。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/7431100_1640665534.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

2、位图--bitMap

描述并发阶段的时候，内存使用状态的一个数据结构。

大家知道，JVM管理的是内存。内存的使用状态，其实是不太好标记的 000000001010。最笨的方法就是，直接遍历整个内存块儿，看看它到底有没有东西，没有东西，我就认为它是空闲的。有东西，我就认为它是使用中的。

那大家想，这种简单粗暴的方式，适合JVM吗？如果JVM想看看哪些内存被使用了，还要直接去遍历这个内存去分析分析到底有没有被使用吗？很明显这样子是不行的。效率太低太低了。

所以说，为了描述内存的使用状态，G1采取了位图的方式来做描述。在一个位图里面记录了所有内存的使用状态，如果要看内存是否被使用了，就直接访问位图中这块儿内存对应的坐标里面的内容，就能知道内存是否已经使用了。

举个例子：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/2570800_1640665534.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

什么是位图？

位图简单来说，就是通过“位”来描述某一块儿内存的状态的图。什么意思呢？

大家知道计算机是二进制，每一个进制占用一位。而我们存储数据的最小单位，是字节。一个字节，从计算机层面来说，占用了8个二进制位。

位图的意思就是，我们有一组数据，每一个位的0 1都标识了其所描述的内容的状态，比如上图所说的，内存是否使用。G1中引入了位图来描述内存使用状态，主要是在混合回收的并发标记阶段使用了位图这种数据结构。提高内存是否使用的判定效率。回收的并发标记阶段，会再详细说。

 

3、卡表 -- cardTable

卡表和位图其实是类似的东西。都是用一段数据去描述另外一块儿内存的情况。跟位图不一样的地方是：由于位图只能用一位来描述，也就是只能记录使用，或者未使用。因为一个位只能有0 1 这两种状态。而卡表为了描述更多的信息，比如内存是否使用，内存的引用关系等，使用的是8位，也就是一个字节来描述一块儿内存的使用情况，是否使用，使用了多少。

所以说，本质上卡表在数据结构层面和位图没有什么太大区别。只是描述符比位图长，描述的内容比位图多。

在G1中，卡表是用一个字节（8位）来描述512字节的空间的使用情况，及内存被谁使用了。并且卡表在G1中，是一个全局卡表，也就是，整个堆内存公用一个全局卡表，来描述全局的内存使用情况及对象引用关系。

当然，因为512字节的内存，可能会被引用多次，里面可能有多个对象，或者说，同一个个对象，被多个对象引用，所以说，卡表的描述，可以理解为一个大概的引用关系描述。

在G1中，JVM使用了RSet+卡表来作为分代模型中，跨代引用关系不好判定，不好追踪问题的解决思路。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/3157400_1640665534.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

4、这些数据结构是怎么提升GC效率的？

我们首先要知道一点，JVM的垃圾回收效率主要是在哪几个方面体现的？

（1）标记垃圾对象

（2）清理垃圾，整理内存

大体上，都是在这两个大的方面上体现的。并且，在标记这个过程中，会非常非常耗时，如果看过JVM专栏的同学，应该知道，标记过程，被JVM分成了很多个步骤，初始标记，并发标记，重新标记，最后才是并发回收什么的。可见，标记的这个过程，还是非常耗时的，不然没有必要分成这么多个阶段。

耗时具体体现在哪里呢？其实就是引用关系不好判定，内存是否使用不好判定。

首先，初始标记过程，要从gc roots出发，标记所有直接被引用的关系是吧？然后在并发标记阶段，追踪所有间接被引用的对象，如果出现跨代引用，比如我新生代对象，被老年代引用了，我肯定不能被回收啊，那么Rset就避免了对老年代的遍历。

 

引用关系怎么找？我们想啊，Rset里面肯定不能直接记录哪个对象引用了哪个对象，不然一个系统1000w个对象，引用关系还特别复杂，可能要记录很多遍，那岂不是一个Rset比整个系统占用的内存还要大？所以，这个时候，cardTable就出现了，cardTable里面可以用一个字节来描述512字节内存的引用关系，那么Rset里面直接记录cardTable相关的内容这一样就可以节省很多内存。（详细内容，我们会在后面章节里面详细展开卡表cardTable和记忆集Rset具体存储了哪些内容）

比如说，我发现 老年代 有一块儿512B的空间里面的对象引用了新生代的一个对象，Rset直接记录这个512B的空间在卡表里面的位置就OK了。

 

位图和并发标记是息息相关的，简单来说，就是在并发标记阶段，可以借助位图描述内存使用情况，避免内存使用冲突的问题，也避免GC线程无效遍历一些未使用的内存。

 

 

5、思考：Rset到底是什么？它具体是怎么实现的？它里面会记录什么内容？