本节内容：

TLAB是怎么实现分配对象的 —— 指针碰撞法

TLAB产生的内存碎片应该怎么处理？ —— dummy哑元对象

如果TLAB这种分配方式实在是无法分配对象，应该怎么处理？

 

1、TLAB是怎么实现分配对象的？

对象分配其实是一个比较复杂的过程，这里我们不关注对象到底怎么创建的，因为它包含了很多东西，比如引用，比如对象头，对象元数据，各种标记位，对象的klass类型对象啊，锁标记，GC标记，Rset，卡表等等。我们先来关注TLAB到底是怎么实现分配一个对象的。

大家思考一下，分配一个对象的时候，TLAB是只给当前这一个线程使用的。因此，当前线程可以直接找到这个TLAB进行对象的分配，那么此时，我们是不是需要知道TLAB是不是满了？或者对象能不能放的下？如果能放的下，就创建对象，如果放不下就进行我们上节课讲过的流程，要么直接堆内存创建对象，要么分配一个新的TLAB给线程，再继续创建对象。回顾一下这张图：

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/3408400_1640327759.png)

所以，对象在TLAB中能不能放的下，还是比较关键的，那么问题来了，TLAB中用了什么机制来判断能不能放得下的？

一个比较简单的思路：因为我们TLAB是一个很小的空间，分配出去了哪些空间？对象在一个TLAB里面，的分配是按照连续内存来分配。

我直接去遍历整个TLAB，然后找到第一个没有被使用的内存位置。就可以了，然后用TLAB的结束地址，减去第一个没有被使用的内存地址，再和对象的大小做一个比较。

但是这个思路有一个问题，每一次都要遍历，是不是没太大必要啊？大家想啊，我每次分配新对象的起始地址，是不是就是上一次分配对象的结束地址？那我直接用一个指针（top），记下来这个玩意不就OK了，下次直接用这个作为起始位置直接分配就OK了~。

如图所示，在分配一个obj3对象的时候，TLAB里面的top指针记录的就是obj2的对象结束位置，

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/99603900_1640327758.png)

当obj3分配完成的时候，此时就直接把指针更新一下，更新到最新的位置上去。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/1972200_1640327759.png)

但是分配对象肯定不可能直接就分配上了，因为有可能空间会不够用是吧？所以在分配对象的时候会判断一下剩余内存空间是否能够分配这个对象。那么具体应该怎么判断呢？其实也很简单，我们只需要记录一下整个TLAB的结束位置（end指针），在分配对象的时候，判断一下待分配对象的空间（objSize）和剩余的空间大小关系就OK了

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/2458600_1640327759.png)

知道end指针的位置，那么判断这个关系就很容易，直接objSize <= end - top 就分配对象，如果objSize > end -top那就不能分配对象。

 

**思考：因为TLAB****是一个固定的长度，而对象很有可能有的大有的小，所以有可能会产生一部分内存空间无法被使用的情况，也就是产生了内存碎片，这个内存碎片应该怎么处理呢？**

2、dummy哑元对象的作用

我们需要了解TLAB本身并不大，具体的计算公式之前讲过，（Eden * 2 * 1%）/线程个数，所以，如果真的造成了一定程度的内存碎片，实际上也就是比一个普通小对象的大小还要小一点点。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/22196700_1640327759.png)

对于一个系统来说，可能几十个线程几百个线程，总共加起来的内存碎片也就是几百K到几MB之间，所以说，为了这么小的空间，去专门搞一个内存压缩机制，肯定是不太合理的，而且也不太好压缩，因为，每个线程都是独立的TLAB，把所有的对象压缩一下，进入stw，然后把对象集中搞到几十个线程的TLAB吗？

如果说，不是在自己的TLAB分配的，此时搞到自己的TLAB里面了，那对象应该谁来管理？所以说，压缩肯定是不合理的。

那么我们想想，这块小碎片，对内存占用的压力不大的话，能不能直接放弃掉？答案是可以的！G1也确实是这么做的，这块儿内存直接放弃了，不使用了。而且在线程申请一个新的TLAB的时候，这个TLAB会被废弃掉（不是直接销毁，而是，不再使用这个TLAB，等待GC）。

 

此时会有一个新的问题：我们在GC的时候，遍历到一个对象，是可以直接跳过这个对象长度的内存的，因为，对象长度占用了这块儿内存，所以直接跳过，然后遍历下一段，但是如果是TLAB里面的小碎片，由于没有所谓的对象属性信息，所以，不能直接跳过，需要把这块儿内存一点一点的遍历，这样子性能就会下降了。所以说，对这块儿内存，G1直接使用了一个填充的方式，来解决GC标记遍历的时候，需要遍历这块儿碎片空间的问题。直接在碎片里面，填充一个dummy对象，这样子，GC遍历到这块儿内存的时候，就可以直接按照dummy对象的长度，直接跳过这块儿碎片的遍历。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/25014400_1640327759.png)

 

最后回到我们上节课的一个思考问题：如果没有办法用TLAB分配对象，那么此时应该怎么办？新搞一个TLAB？那么如果新搞一个TLAB，失败了，怎么办？

 

**3****、如果TLAB****这种分配方式实在是无法分配对象，应该怎么处理？**

其实这个过程，大家学到这里应该也大概猜的出来了。

首先，TLAB剩余内存太小，无法分配对象，会有不同情况，要么是大于refill_waste，直接走堆内存分配，要么是小于refill_waste，但是剩余内存空间不够，这个时候会重新分配一个TLAB来用。

然后，如果无法分配新的TLAB，就会进入堆加锁分配了。如果说，能够直接分配对象，那么就万事大吉。

最后，如果不能分配，此时就会尝试去扩展分区，也就是再申请一些新的region，成功扩展了region，就分配对象，如果不成功就会走垃圾回收。

如果垃圾回收的次数超过了某个阈值，就直接结束，OOM。

 

解释一下最后的这个垃圾回收，因为如果内存空间实在是不够，导致无法分配对象的时候，肯定是需要垃圾回收的，如果垃圾回收之后，空间还是不够，那么说明存活的对象太多了，堆内存实在是不够用了，这个时候程序肯定无法分配对象，无法运行的，所以就OOM了，那么OOM之前，肯定会做一些垃圾回收的尝试，直到尝试到某个阈值，比如说，达到了3次回收还是无法分配新对象，就只能OOM了。