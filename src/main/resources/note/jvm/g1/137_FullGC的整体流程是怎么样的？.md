回顾：

1、对象分配失败就会进入FULL GC的流程

整体流程如下：

TLAB分配 --> 扩展TLAB进行分配 --> 申请新的TLAB --> 从自由分区新的region给新生代--> 堆内存扩展分区给新生代 --> 垃圾回收（YGC、MixedGC）--> FULL GC（第一次） --> FULL GC（第二次，回收软引用）

2、对已经成功的对象做更新RSet处理，对失败的对象，做恢复处理

3、对复制失败的对象做自引用处理

4、如何恢复对象头？

5、恢复对象头之后的其他恢复操作 Redirty恢复RSet

 

本节内容：

1、各种尝试失败之后的Full GC和YGC MixedGC有什么不同？

在YGC，Mixed GC的过程中，基本的思路都是：标记对象，复制对象到空闲分区，集中回收存在垃圾的region。

而在Full GC的过程中，和YGC MGC不是特别相同。首先，第一个阶段，FULL GC，就会进入标记阶段，标记阶段会标记出所有的存活对象。这个过程和YGC MGC没有什么太大的区别，本质上都是标记对象，然后遍历对象的所有feild，最终找到所有的存活对象。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/91216700_1641818725.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

本质上还是三色标记法，nextbitmap这些东西，去找到所有的存活对象。那么找到所有的存活对象之后呢？应该怎么办？我们从基本逻辑上思考，肯定是要把垃圾对象给清理掉，然后处理一下活跃对象的引用关系，整理一下内存什么的。实际上G1也确实是这么做的。

 

2、计算对象的新地址

G1在Full GC第一步标记完所有的存活对象之后，会对每一个region进行整体的遍历，遍历的位置从一个region的底部（其实就是起始位置开始），设置一个compact top指针，如果找到了第一个存活对象，就把这个对象的对象头里面指向对象的指针给设置为这个compact top，说白了就是，前面的都是垃圾对象，找到了你这么一个存活对象，那我就先提前把你这个存活对象规划到接下来要被回收的那块儿区域的起始位置，也可以理解成，计算出每个对象在回收完垃圾对象之后，所在的新的位置。我们看看示意图：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/90953600_1641818725.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

注意看，obj0对象，在垃圾回收之后的位置，就是第一个region的起始位置，因为起始位置的对象是死亡对象，在接下回收之后，就会被清理。注意，此时还没有完成对象的复制，也没有完成垃圾对象的清理。只是做了一个新的地址的计算。

 

3、更新引用对象的地址

上一步，我们把对象头中引用自己的对象的那个地址已经更新到一个计算后的新地址上去了。那么此时，就需要把所有的活跃对象遍历一遍，把对象间的引用，也指向到新的位置上去。说白了，就是要遍历所有活跃对象，以及活跃对象的字段，然后把所有对象之间的引用，更新到最新的位置上去，（注意，此过程更新的是存活对象引用的存活对象的新位置，也就是除了对象复制的工作，其他的引用位置，对象的新位置，都已经搞好了。）

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/92035500_1641818725.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

注意看，我们Obj0这个对象本来引用的Obj1老的对象位置。但是经过了计算新位置的过程之后，Obj1最终应该在虚线指向的位置。那么此时Obj0也会指向这个新的位置。那么下一步，其实大家也可以猜到要做什么操作了。



 

4、对象复制

在上一步更新完引用关系之后，此时就需要把对象真正的复制到对象的新位置上面去。其实起到的就是一个释放掉垃圾对象占用的空间，同时让存活对象排列更加紧密的作用。这里也引出了FULL GC的算法，其实使用的是整理压缩的算法。就不是复制算法。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/93069100_1641818725.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

需要注意的是：遍历整个region的过程，需要从前向后遍历，和我们在计算新地址，给对象找新地址的过程是一致的，不然肯定会出错。

 

5、复制后的处理

我们可以看到，在前面四步完成之后，其实垃圾对象已经完成了回收，存活对象在各自的分区，也完成的紧密的排列。（注意，这个过程，并不一定能整理出来空闲的分区，因为存活的对象，都是在各自的分区）我们其实也可以猜到为什么这么做。因为不管是YGC还是MGC，最终都是要用复制算法把存活对象复制到一块儿空闲区域，然后集中回收那些复制完成的存活对象所在的区域。而到了full gc这一步，很明显是肯定没有多余的分区给你使用，才会进入full gc这一步的，所以，full gc只能对每个分区进行压缩整理。

整理完成之后，会做一些调整操作。

（1）尝试调整整个堆分区的数量大小

（2）遍历整个堆，然后重构RSet，因为对象的位置肯定已经发生了改变

（3）清除dirty card队列理解成，要去更新卡表，并把所有的分区设置Old分区

（4）记录一些GC信息，同时更新新生代大小（YGC CSet的大小），选择一些分区作为新生代，然后重新构建Eden，即对一些分区打上Eden区域的标识，支持下一次的对象分配，以及YGC等各种操作

 

注意，上面的整个过程，都是单线程执行的。

 

6、思考题：Full GC为什么特别慢？有没有什么方式提升Full GC的整体效率？