回顾：

1、卡表和记忆集到底存储了什么？

2、卡表和记忆集之间是怎么关联的？

3、RSet在空间和时间上做的平衡

 

4、思考：Remember Set的数据到底是怎么维护的？什么时候维护？如果出现了大量的引用关系变更，怎么处理？大量引用关系变更的时候会不会出现性能问题，性能问题应该怎么优化？

有可能会导致并发安全问题，以及并发性能问题。所以说什么时候维护，以怎样的方式维护，非常重要。

 

本节内容：

1、如果引用关系发生了改变，RSet是否需要更新，应该怎么更新？

如果说有对象引用变更，比如说，新增了一个对象引用，或者失去了一个对象的引用，RSet肯定是要更新的，不然肯定会出现回收的时候引用关系错误，回收会出现把正常对象当垃圾对象，或者把垃圾对象当正常对象，没有回收的情况，所以在引用关系变更的时候，一定是需要更新Rset的。

比如，我们上节课的例子：

（1）新生代region2中有一个对象Obj2

（2）老年代region1 和老年代 region5里面有Obj1 Obj3 Obj4 Obj5均引用了Obj2这个对象

（3）其中Obj3 Obj4位于老年代region1的同一个cardPage里面，这个cardPage在全局卡表的坐标位：666
  （4）Obj1和Obj5分别位于老年代region5的两个cardPage里面，这两个cardPage在全局卡表的坐标为：1788和1756

如果说，Obj5这个对象，执行了一下Obj5.Obj2 = null，那么此时Obj5对Obj2的引用关系就会消失。此时肯定是需要更新Rset的，那么到底应该怎么更新？更新的策略是什么？

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/29753700_1641210008.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

我们需要思考两个问题：

（1）每次更新引用关系，RSet是一定需要立即更新的吗？不立即更新有什么影响？

（2）立即更新会产生什么问题？不立即更新的话，有什么合理的方案？

2、每次引用关系变更都更新

首先，一个region有一个RSet，所以说，一旦发生了同一个对象，或者同一个region内对象的引用关系变更，一定是有可能出现并发访问统一个RSet的情况的，因为一个region是共享同一个RSet的。所以，第一个需要解决的问题就是并发问题，而解决并发问题的最好的方式就是串行化处理，要么就是分而治之。

思考：假如我们使用串行化，立即更新的方式可不可以？

从结果上来看，每次更新引用关系以后，立即去加一把锁，然后修改RSet，肯定是能保证RSet的准确性的。大家看下面这张图，此时，Obj5这个对象所在的cardpage已经从新生代Region2的RSet中移除了。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/68716200_1641210008.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

但是这种方式最大的问题就是，虽然我们**保证了准确性**，但是对象的更新，创建的一系列操作是非常非常频繁的，如果用这种加锁的方式更新，肯定会造成性能问题。毕竟一个region共享一个RSet，每一次对象的创建，更新等操作肯定都可能去访问这个RSet的，这样子加锁串行化处理，势必会造成整体性能的下降。

所以说，肯定不能采取这种方式，那么应该采取什么方式来处理呢？分治思想我们来思考一下是否可以使用。我们是一定要保证系统运行的效率。

 

首先，分治的话，是需要把一个RSet分割开来，交给多个线程去处理，同时在最后做一个汇总，但是在这个场景下，肯定不能这么做，为什么？

首先分治操作，把RSet按照什么维度分开，是第一个问题。

其次，分治，肯定要搞几个线程专门来做处理，因为要分开处理，最后汇总，那么线程最好是固定搞几个线程专门处理。那么我们思考，我们每次线程过来，是不是都是系统的工作线程？系统的工作线程专门用来做这个肯定不合适吧？那如果是专门搞几个线程呢？

RSet太多了，本来就有上千个Rset，还要分治。

第三，最终的汇总什么时候搞？

所以说，分治思想不太合理。那么还有没有什么其他的方案比较合适呢？

 

3、Rset的更新操作应该什么时候做？

我们想想看，RSet的数据，我们什么时候才会用到？JVM最核心的两大操作就是，对象分配，和垃圾回收对不对？这两个过程是JVM的核心过程。我们来分析分析这两个过程。

首先分配对象，需要用到RSet的数据吗？

并不需要，因为我们在分配一个对象的时候，只需要看看内存够不够，剩余空间是否能够分配一个对象，分配完成以后，直接更新一下内存的使用情况就OK了，并不需要借助RSet。

 

那么就还剩下一个垃圾回收，垃圾回收要不要用到RSet？答案是肯定的，RSet本身就是为了垃圾回收的时候更加方便，不需要遍历的空间而设计的，所以在垃圾回收的时候才需要用到RSet。

 

那么我们是不是可以得出一个结论，即，在大多数时间里，RSet即使需要更新，而我们没有把它更新，其实也无所谓，因为不影响程序运行。我们看下图，当新创建一个对象Obj6的时候，完全和RSet没有任何关系。直接创建就就OK了。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/69564300_1641210008.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

只有在垃圾回收的时候，我一定需要最新的RSet，不然就会出错。我们看下面这张图。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/70206800_1641210008.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

如果我此时需要垃圾回收，而Rset没有更新到最新的引用关系，肯定会出错，大家注意RSet里面的值，很明显1756这个值，是需要剔除的，因为Obj5已经执行过Obj5.obj2 = null这个操作了，它已经不应用Obj2了。所以，这个时候垃圾回收的遍历的过程可能会有额外的不需要的遍历。

 

那么我们就明白了，这个更新的操作应该在垃圾回收之前完成。既然是在垃圾回收之前完成，那在程序运行 -- 需要垃圾回收的这么长时间里，我偷偷摸摸把这个更新的事情做了不就OK了吗？

 

4、G1的脏数据队列异步消费，更新RSet

 

基于前面的分析，我们知道只要在垃圾回收之前把所有引用更新的操作做完就OK了。而在垃圾回收之前，我们有大把大把的时间慢慢更新这个引用关系。所以G1就设计了一个队列，叫做DCQ（Dirty Card Queue）队列，在每次有引用关系变更的时候，就把这个变更操作，发送一个消息放到DCQ里面，然后有一个专门的线程去异步消费。大家看下面的图：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/69707100_1641210008.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

这样的话，G1垃圾回收器的回收线程，在最后读RSet的时候，就能够读到正确数据，同时还不会导致系统工作性能被拖慢。

 

5、思考：异步消费是谁在消费？应该有多少个线程才不会损耗CPU大量的资源？如果到了最后垃圾回收的时候还是没有消费完毕，应该怎么办？