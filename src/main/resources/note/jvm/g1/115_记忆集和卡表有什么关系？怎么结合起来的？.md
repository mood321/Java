回顾：

1、引入位图可以干什么？

2、位图在对象引用方面的应用，会造成什么问题？

3、怎么优化位图？

4、什么是卡表？

5、卡表和位图到底是什么关系？

6、思考：卡表和Rset记忆集是怎么结合起来使用的？

 

本节内容：

1、卡表和记忆集到底存储了什么？

2、卡表和记忆集之间是怎么关联的？

用一个完整的例子来说明卡表和记忆集的存储结构及关联关系。

 

1、卡表和记忆集到底存储了什么？

我们前面已经讲过，记忆集RSet里面存储的是 《谁引用了我》 的引用信息，我们可以通过这些信息去找到引用当前region的对象，也就是说，我们能够通过记忆集找到引用了当前region的对象所在的region，内存块儿，以及最终对象的位置。那它里面的数据结构到底是什么？存储的数据又是什么呢？

首先，Rset，全称叫 Remember Set，从这个名字里其实就可以看出来，它是一个set结构，其实我们也可以理解成，它是一个类似于Hash表的结构。

前面我们讲过，一个region对应一个Rset，记录了引用本region的其他区域的对象引用关系。其实这个描述是不准确的。

一个Rset，它是由一个一个key - value对组成的。其中，key是引用了当前region的其他区域的地址。Value是一个数组，value中的元素是引用方的对象所在内存块儿在CardTable中的下标。

我们看下面这张图：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/80349700_1640665866.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

注：卡页就是512字节的内存页 就是卡表对应的cardPage的大小。

 

也就是说，如果我们在遍历对象的时候，直接找对象所在region的记忆集，从里面就能拿到所有引用了当前对象所在region的卡表数据，及卡表对应的512内存块儿的地址。

以上是Rset记忆集中存储的信息。所以说，记忆集存储的其实不是哪些对象引用了当前region，而是对象所在的卡页对当前region的引用关系，粒度相比对象来说会稍微大一些（如果对象大的话，粒度可能反而更小，要看具体对象的大小情况。）

总结来说就是，一旦有老年代的对象引用了一个新生代（老年代）的region中的对象，那么就会在这个新生代的（老年代）region 的记忆集中维护一个key - value对，其中key是引用方对象对应的region的地址，也就是那个老年代的对象所在region的地址，value是一个数组，里面存储的是这个对象所在的cardpage（512字节的卡页）在全局卡表中的下标。通过这个Rset，我们在遍历一个region的时候，就能根据这个region的Rset快速定位到引用方所在的region及引用对象所在的cardpage。从而避免对老年代进行全局扫描。

 

卡表中存储了什么呢？卡表在G1中，其实存储的不是引用关系信息，而是卡页的内存使用情况，也就是，是否使用，使用多少，以及垃圾回收过程中的一些状态信息，以及对应的哪块儿内存块儿，在G1中，记忆集这个东西存储的是内存之间的引用关系，并且借助了卡表中对内存块儿位置的描述。

大家看一下，我们上节课的卡表图和这节课的卡表图的对比。

**上节课：**

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/75922800_1640665866.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

**本节课：**

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/12613800_1640665867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

因为记忆集已经存储了引用关系。所以卡表的功能就放在了内存使用的描述上面，包括一些GC过程中的状态信息。这样通过记忆集就可以描述出引用关系，通过卡表就能描述垃圾回收的状态信息，对象所处的内存区域块儿（比如，第几个cardpage页），借助这个，我们还能快速知道内存使用的情况，比如是否使用，多少个卡页被使用等等这些信息。

 

结合起来使用，就可以轻松的**搞定引用关系**和内存使用情况的详细信息。

 

2、记忆集和卡表是怎么关联的？

上面我们已经讲了卡表和记忆集是怎么关联的。其实说白了，Rset记忆集，就是存储了一些卡表的信息。

我们用一个例子来描述这个关系：

（1）新生代region2中有一个对象Obj2

（2）老年代region1 和老年代 region5里面有Obj1 Obj3 Obj4 Obj5均引用了Obj2这个对象

（3）其中Obj3 Obj4位于老年代region1的同一个cardPage里面，这个cardPage在全局卡表的坐标位：666
  （4）Obj1和Obj5分别位于老年代region5的两个cardPage里面，这两个cardPage在全局卡表的坐标为：1788和1756

我们直接把这个引用关系图画出来：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/17585300_1640665867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

大家可以看到，对象的引用关系以及对象所在的卡表坐标在卡表中的信息如上图所示。

通过这个卡表，我们就能准确的找到对象所在的cardPage页了。

接下来，我们把Rset存储的信息，结合卡表一起画出来。如下图所示：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/16440000_1640665867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

当我们在进行新生代垃圾回收的时候，就可以通过新生代region2的记忆集Rset + GC roots来找到新生代自己的引用关系，以及老年代跨代引用的所有引用关系。

这样是不是就不会漏找，同时还能够保证不需要在只做新生代的回收的时候，还要去费时费力的遍历整个老年代？

 

大家可能会有疑问，按照RSet的这个存储逻辑，它也不能在回收的时候直接定位到老年代引用新生代的对象到底有哪些啊？

 

3、RSet在空间和时间上做的平衡

（1）我们知道，如果没有RSet + 卡表，回收新生代的时候，是需要遍历整个老年代的对象的，非常耗时，为了解决问题才引入了额外的存储结构 --- RSet + 卡表

（2）但是，如果把RSet+卡表的存储粒度，按照每一个对象来存储，实际上是不太合适的，因为RSet+卡表会占用很大的额外内存。

（3）所以说，RSet + 卡表的机制是对空间和时间做了一个平衡，最终设计的这个结果。

按照这个设计，其实每次在找老年代的引用对象的时候，实际上最多就是需要遍历一下对应的cardPage的内存就可以了，而且还可以结合对象的长度去做遍历，按照一个对象长度的内存空间为步长去遍历，整体性能不会很差。

 

4、思考：Remember Set的数据到底是怎么维护的？什么时候维护？如果出现了大量的引用关系变更，怎么处理？大量引用关系变更的时候会不会出现性能问题，性能问题应该怎么优化？

RSet是一个垃圾回收的时候非常重要的数据。所以说一定要准确，也就是说，引用关系变更的时候，一定要更改这个RSet对吧？