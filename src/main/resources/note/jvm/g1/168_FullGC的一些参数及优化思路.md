回顾

1、parnew + cms的full gc触发

ParNew + CMS触发的full gc的规则其实还是比较简单的。

总结来说，就是老年代不够用了。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/apppuKyPtrl1086/image/ueditor/55685900_1647077941.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

2、G1的full gc触发

（1）新生代晋升失败导致的full gc

（2）对象分配失败导致的full gc

3、G1的full gc更加恐怖的原因总结

（1）G1通常来说要管理更大的堆内存空间，因此需要处理更多的对象。

（2）G1触发full gc的条件比较苛刻，在分配失败后进入full gc的时候，会几乎处理整个堆内存的空间

（3）G1在执行full gc过程中，需要针对更加复杂的Rset引用关系集合做更多复杂

处理。

 

本节内容：

1、full gc相关的一些参数介绍

（1）-XX:G1HeapRegionSize 这个是我们G1课程开课阶段就讲解过的参数，用于控制region大小的参数。

关于full gc的优化，可以调这个参数。其实原因很简单，避免老年代中的大对象占用过多的内存。因为老年代大对象占用过多的内存，就会提高老年代的使用率，提高老年代的使用率，必然会造成的就是晋升失败的概率增加。所以，增大这个值，避免不算太大的对象进入老年代。

调大它的另外一个优点是，region大的时候，在发生对象复制，晋升的时候，PLAB也会相对大一些，在复制，晋升的时候，速率相对也会有一定的提升。

 

（2）-XX:G1ReservePercent 默认是10，代表的是占用堆内存的比例。这个参数是我们最近反复提到的值，意思是，老年代预留给新生代对象晋升的空间比例。其值表示的是占用堆内存的比例。如果经常发生因为晋升导致的full gc，就说明这个值太小，可以适当调高这个值，降低full gc的频率

（3）-XX:MaxGCPauseMillis 停顿时间

这个参数也是我们前面反复提到过的参数，这个参数的设置是否合理，关系到了垃圾回收的效率。假如说我们设置了一个20ms这样的停顿时间，很有可能会导致每次gc回收的垃圾量都非常少，假如系统并发非常高，产生垃圾的速度非常快，就很有可能会不断进行垃圾回收，但是每次都只能回收掉很少一部分垃圾，最终造成full gc。

所以，在这里再次强调，一个合理的停顿时间设置，是非常有必要的。一般情况下，系统的停顿时间可以设置100-200ms之间，具体情况需要根据系统运行情况及JVM监控情况来调整。

 

（4）-XX:InitiatingHeapOccupancyPercent 这个值的含义前面我们讲解MixedGC的时候也经常提到。默认是45%，也就是说，当整个堆内存占用比例达到45%的时候，就会触发并发标记，也就是有可能会开启一次MixedGC。假如说，因为垃圾回收的速率跟不上系统产生垃圾的速度而造成比较频繁的full gc，我们就可以适当调低这个参数，来尽快开启mixed gc。通过提升mixed gc的频率来避免JVM内堆积过多的垃圾对象。

 

**注意：**这个参数调小产生的多次gc和停顿时间造成的多次gc不是一个概念。停顿时间造成的gc，是因为每次停顿时间不够，只能回收很少量的垃圾，导致垃圾堆积，最终导致full gc。

而调小InitiatingHeapOccupancyPercent这个参数，回收停顿时间固定，但是回收的频率提升上来了，在同样的程序运行时间里，能够回收更多的垃圾，避免了full gc

 

（5）-XX:ConcGCThreads 这个参数是指在标记过程中的并行标记(STW)线程数量。如果说因为并发标记不够及时，并发标记时间过长，导致垃圾回收的速率跟不上，造成full gc，略微提升这个值，可能能够提升标记速度。以达到避免full gc的效果。当然还是那句话，线程数量多少，要和服务器的配置相匹配。不能盲目的调大这个值。

 

（6）-XX:G1ConcMarkStepDurationMillis参数，这个参数指的是并发标记(不会STW和引用程序一起运行)执行的时间，默认是10ms，这个值我们前面有提到过，其作用就是提升并发标记的次数，让并发标记触发的更加频繁一点儿，重新标记阶段（remark）过程的时间更短一些，来提升垃圾回收的速率，避免垃圾回收速度跟不上垃圾产生速度，最终造成full gc。正常来说这个参数也是不需要调整的，只有当我们发现系统经常因为垃圾处理不及时而频繁的触发full gc，才有可能需要调整这个参数，把这个参数调的小一点。

 

（7）-XX:MarkSweepAlwaysCompactCount，默认值为4，这个参数表示，经过n次GC之后，允许JVM的内存中有一定比例的空间用来将死亡对象当作存活对象来处理。我们可以称这块儿空间为：弥留空间。

这个空间的作用上节课我们有提到过，主要的目的就是可以把死亡对象当作存活对象来处理，相当于给了一块儿比较好处理的空间，能够在发生full gc的时候，减少full gc的处理压力。可以说是间接的“减少full gc需要处理的空间”。这个空间大家其实也可以看的出来，是不宜太大的，如果太大，肯定会造成一部分空间被占用。一般来说保持默认即可。

4次GC之后给一定的空间来作为弥留空间，弥留空间具体多大，大家可以自己去查一查试一试。

 

2、小结

上面我们介绍的这些参数，多数都是以“避免”full gc的思路来展开的优化。只有第七个参数是以，为full gc“减负”的思路来展开的优化。

 

对于full gc来说，“减负”这个思路，在多数情况下是无法采取的，因为full gc本身的特性就决定了基本上不太可能通过其本身的逻辑调整，参数调整来提升速度。更多的优化思路和优化手段还是要从“避免”出发，能够避免大多数full gc，才是优化的重点。