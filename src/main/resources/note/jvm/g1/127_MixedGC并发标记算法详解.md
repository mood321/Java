回顾：

1、Young gc的一些细节调整

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/13299000_1641817387.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

2、在YGC开始前判断的另外的一个原因

3、YGC为什么可以作为mixed gc的初始标记阶段？

4、借助survivor + gc roots记录即可完成老年代的标记

5、思考题：

Ygc是需要对所有新生代空间做全部遍历，回收的。Mixed gc是否需要对整个老年代进行回收？如果不需要，那么标记操作是否需要标记所有老年代对象？为什么？

答：不需要整体回收，但是需要全部标记，因为要选择性价比高的region进行回收。不标记全部，怎么挑选性价比比较高的region？

 

本节内容：

1、初始标记阶段给了我们什么东西？

上节课我们已经讲了，初始标记阶段，给了我们两块儿区域的内容：

（1）survivor区的存活对象

（2）老年代的gc roots直接引用的对象集合（其实是一个栈中）

然后用这两组存活对象的集合以及RSet的跨分区引用关系，我们就可以对某个region中所有的对象完成是否存活的标记。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/61609900_1641817387.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

但是，我们需要思考的问题是：这些起始点对象都拿到了，我可以通过这些对象一个一个找到所有的存活对象。但是，因为是并发标记，程序还在运行，所以这个过程中会产生一些新的对象，不在我标记的范围内，那我判定这些增量对象是否是存活对象，又该怎么判断？如图所示，在并发标记的过程中，新产生了一些对象（绿色的对象）

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/62090400_1641817387.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

我们都知道这些对象，做一些增量标记就可以了，那到底怎么做这个增量标记？G1的并发标记阶段是怎么处理的？

 

2、一个简单的思路：G1对增量对象的处理

一个简单的思路：在我并发标记阶段中，新创建的所有对象，我都存储到一个空间里。然后在并发标记阶段结束后，再直接通过我额外开辟的这块儿空间，来标记所有存活对象。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/61585500_1641817387.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

但是这个思路肯定不太合适，因为需要额外的空间，而且程序运行的并发量比较高的话，性能也比较差。这些对象很有可能会造成原有对象，我们标记过的那些，出现一些引用关系。或者说，引用关系会变更。

那到底什么思路比较合理呢？

 

3、对象分配的连续性的特性

我们先不着急确定思路，大家先回顾一下，我们在介绍对象分配的时候，用的指针碰撞法分配对象的过程：

一个top 指针，代表TLAB已经使用到的内存，一个objSize，一个end指针，分配的时候就是top + objSize，对不对？这说明什么？是不是说明，我们对象的分配，一定是线性、连续的，同时，我们但是看源码的时候，发现TLAB的分配和对象的分配，其实使用的都是同一块儿代码，TLAB的分配也是指针碰撞法，所以在同一个reigon里面分配对象的时候，region的内存使用一定是连续的。我们看下面这张图：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/63595000_1641817387.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

不管在TLAB还是在region中，内存的使用最终一定是一段连续的，如果有空的内存，会有dummy对象填充。

基于这个基础，大家思考一下，如果说我们要记录并发标记阶段新产生的对象，是不是可以借用这种连续分配的特性？

 

4、指针法来确定增量对象的范围

如果我们并发标记进行了一段时间，在某一个region（对于所有region其实都是一样的）里面，新对象，以及已经被标记的对象是不是这样子的：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/62741500_1641817387.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

其中红色的是已经被标记的对象（不一定是存活的，只是说明他们被标记了），紫色的是新产生的对象。大家发现什么特点？是不是发现，其实我标记开始的时候，到标记结束的时候，top指针一直都能指引我内存最终使用的位置？那么我能不能直接在并发标记之后对这段标记前到标记后top的位置变换的区域做遍历标记？这样子是不是就可以实现标记剩余的存活对象了？

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/64324600_1641817387.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

我们从图中可以看出，当并发标记结束后，直接从并发标记前的top位置作为起始点，遍历到并发标记后top的位置，就可以找到所有对象，判断其是否存活。

 

5、思考：如何提升标记效率呢？Mixed gc可是相当于需要遍历全部堆内存里面的对象的，如果说对每个对象打一个标签的话，虽然可行，但是在垃圾回收的时候怎么办？继续遍历对象吗？