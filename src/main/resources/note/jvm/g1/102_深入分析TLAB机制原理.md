上节课，对于G1快速分配对象的基本原理做了讲解，实际上就是基于一个TLAB缓冲区来让每个线程都可以并行的给在自己的TLAB里面分配对象达到快速分配的目的。

 

思考：既然要分配TLAB，那什么时候分配TLAB？分配多大？TLAB占满了怎么办？如果实在没有办法用TLAB的方式分配，有没有什么兜底的策略？

 

本节课内容：

TLAB是什么，如何分配的

TLAB的数量限制是怎么做的

TLAB的大小是怎么确定的

TLAB如果满了，分配对象会做什么操作

TLAB大小的动态调整

 

1、TLAB是什么？TLAB是怎么分配的？

首先，我们需要知道的一个点是，程序创建的对象是由线程创建的。线程在分配的时候，其实也是以一个对象的身份分配出来的。大家还记不记得Thread thread= new Thread()，也就是说，搞一个线程的时候，实际上也是有一个线程对象需要被分配出来的。

在G1中，实际上，在分配线程对象的时候，就会从JVM堆内存中分配一个固定大小的内存区域，并将它作为线程的私有缓冲区，这个**私有缓冲区**，其实就是TLAB。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/58627200_1640327445.png)

**注意：在分配给线程TLAB****的时候，是需要加锁的，在G1****中，使用了CAS****锁来分配TLAB**

 

**继续思考一个问题：TLAB****的数量应该怎么限制？不可能无限多个吧？**

 

其实这个问题也简单，因为我们说了，是分配线程对象的时候，给线程从JVM堆内存上分配一个TLAB，供线程使用，那么理论上，有多少个线程就有多少了TLAB缓冲区对不对？那么我们线程数量首先肯定不会是无限的，不然CPU绝对爆掉！所以说，这个数量就是跟随线程数量的。

那么新的问题来了，有多少个线程，就有多少个TLAB，如果TLAB过大，会有什么问题？如果TLAB过小，会有什么问题？

 

2、TLAB有多大？如何确定TLAB的大小？

首先要确定一个问题，**如果****TLAB****过小，会导致TLAB****快速被填满**，从而导致对象不走TLAB分配，效率会变差。如果TLAB过大，造成内存碎片，回收的效率会被拖慢。因为运行过程中，TLAB可能很多内存都没有被使用，造成内存碎片，同时，在垃圾回收的时候，因为肯定要对TLAB做一些判定，回收的效率会被拖慢。所以说TLAB要有一个平衡点。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/58270100_1640327445.png)

那么如何确定TLAB的大小呢？TLAB初始化的时候，其实是有一个公式计算的，TLABSize = Eden * 2 * 1%/线程个数，其中这个乘以2是因为，JVM的开发者默认TLAB的内存使用服从均匀分布。这个是一个数学概念。均匀分布，意思是，我使用的时候，均匀分布在整个TLAB空间，最终结果是什么呢？50%的空间会被使用。

10G eden，40个，TLAB是多大？ 10 * 2 * 1 % = 2MB TLAB = 2GB/40

分配好TLAB之后，在系统运行的时候，线程创建对象，就会优先通过TLAB来创建对象，但是我们还是有一个问题，假如TLAB满了，无法分配对象了，会怎么处理？我们其实可以推测一下，思路无非两种：

（1）重新再申请一个TLAB给这个线程，让它继续去分配对象，可能需要对老的做一下处理

（2）直接通过堆内存分配对象

在G1中，是使用了两者结合的方式来操作的。也就是说，如果说无法分配对象了，就优先去申请一个新的TLAB来存储对象。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/56544900_1640327445.png)

 

如果无法申请新的TLAB，才有可能会走对堆内存加锁，然后直接在堆上分配对象的逻辑。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60762800_1640327445.png)

3、一个关键的问题，我们怎么来判断TLAB满了？

首先我们要知道为啥需要判断TLAB满了？原因很简单，因为我们的TLAB大小分配好了之后，就固定了10MB，而对象的大小却不是规则的45KB,256KB,333KB，所以很有可能会出现对象放不进TLAB中去的情况，但是TLAB却还有比较大比例的空间没有使用，这种场景会造成比较严重的内存浪费，所以如何判断TLAB满了，是一个比较难做的事情。

TLAB 10KB，11KB，它满了吗？

TLAB 2MB空间，3MB对象，它满了吗？

 

那么G1是怎么做的呢？实际上，G1设计了一个refill_waste的值，在JVM虚拟机内部维护。

这个值是什么意思？简单来说，就是，一个TLAB可以浪费的内存大小是refill_waste。也就是说，一个TLAB中最多可以剩余refill_waste这么多的空闲空间，如果剩余了这么多，就可以代表这个TLAB已经满了。

refill_waste的值，通过TLABRefillWasteFraction来调整，它表示TLAB中可以浪费的比例，默认值是64，即可以浪费的比例为1/64

**思考：判定一个TLAB****满了以后，对象应该怎么分配呢？如果TLAB****经常进入这种满的状态，说明TLAB****的空间设置不是很合理，和我们对象大小的规律不匹配了，应该怎么解决这个不合理？10KB****，11 12 15 13** 

4、TLAB满了怎么办？经常满又怎么办？

G1设计的这个refill_waste不是简简单单的判断是否满了就万事大吉了。判断过程会比较复杂。

具体逻辑如下：

我要分配一个对象，先从线程持有的TLAB里面分配，如果空间够了，就直接分配。

空间不够，这个时候有一个refill_waste，此时需要对比对象所需空间大小是否大于这个浪费空间的值，如果大于refill_waste，则直接在TLAB外分配（这个过程，不同的GC算法，有不同的规则）也就是堆内存里直接分配，如果小于这个浪费空间，就重新申请一个TLAB，用来存储新创建的对象，重新申请一个新的TLAB的时候，会根据一个模型（TLABRefillWasteFraction）来动态调整，以适应当前系统分配对象的情况。

动态调整的依据是：因为很明显，refillwaste这个阈值，和TLAB的大小，无法满足当前系统的对象分配。因为对象既大于当前剩余的可用空间，又小于refillwaste，也就是剩余空间实在太小了，分配对象经常没办法分配，只能走到堆内存加锁分配，所以很显然，还没有达到一个更加合理的refillswaste和TLAB大小。

因此，系统运行过程中，会一边运行，一边动态调整这两个参数到一个更加合理的值。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/60174100_1640327445.png)