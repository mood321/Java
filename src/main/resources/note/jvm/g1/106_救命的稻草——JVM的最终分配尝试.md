本节内容：最后的救命稻草，对象分配的最后尝试流程

 

1、大概率会成功的快速+慢速尝试

一般来说，即使内存不够，扩展一下region，内存基本上就能够做对象分配了。实在是不够，才会尝试GC，GC之后再去做分配，其实百分之九十九点九的概率是可以成功分配的。极端情况下，才会尝试了好多次分配都最后都失败了。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/68914400_1640328001.png)

图中的1 2 3步就是拓展，回收的过程，很多情况下，就直接在1、3步就直接成功了。

比如，如果是通过TLAB去分配对象，那么其实拓展一个新的TLAB就基本成功了，不会走到垃圾回收这一步，如果不成功，那么就直接堆内存分配（此时就是慢速分配），拓展分区，还是不成功，才尝试触发ygc，再来一次，如果再来一次还是无法成功就只能返回失败了。前面的失败，经历的gc，都是先ygc，mixedgc，然后最终要进入拯救环节。

那么返回失败之后就直接OOM了吗？没有挽救的余地了吗？

2、慢速分配失败以后，G1会怎么拯救？

首先我们需要明确，在慢速分配，快速分配的过程中，肯定是会尝试去gc的，但是gc触发的要么是ygc要么是mixedgc，那就说明，还没有到山穷水尽的地步，因为还有一个full gc没有用！

所以说，很明显，肯定不是直接OOM的，而是有一个最终的兜底过程，这个过程要进入我们在JVM专栏里面讲过的，所说的最最恐怖的full gc过程，这个过程是极慢极慢的。

那具体这个过程到底做了什么呢，full gc在哪里触发，会执行几次？执行的过程中会做什么操作？

3、，full gc在哪里触发，会执行几次？执行的过程中会做什么操作？

其实很简单，上面的过程结束之后，还是没有返回一个对象，代表慢速分配也失败了。过程中进行的gc也无法腾出空间。那就会走向最后一步，由JVM进行的GC

这个GC过程会比较复杂，流程图如下：

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/70334100_1640328001.png)

（1）尝试扩展分区，成功了，就可以分配对象，然后返回了

（2）不成功的时候，会进行一个GC。注意，这次GC是Full GC，但是这次GC，不回收软引用，回收之后，再次分配对象，成功了，就OK了

（3）如果还是不成功，就进行Full GC，把软引用回收掉，然后再次尝试分配对象，成功了，就OK，如果不成功，就只能OOM了，神仙难救。

 

从上面的流程我们也可以看的出来，假如一次对象分配失败，造成了OOM，很有可能会出现大量的gc，这也和我们有时候看gc日志，发现，oom之前多了好几次莫名其妙的gc完全符合上了。

4、总结

总的来说，对象分配涉及到的GC过程不同阶段是不一样的。比如，我们使用TLAB进行快速分配的过程，第一次进入慢速分配，扩展空间失败的时候，就是ygc 或者 mixed gc，再次进入慢速分配，有可能还会执行gc，在分配过程中执行的这个ygc 或者 mixed gc，慢速分配也失败的时候，就会进入最终的尝试，最终尝试会执行两次full gc，一次不回收软引用，一次回收软引用。

另外，一般来说，对象分配都是走的快速分配。慢速分配的场景比较少，一般是TLAB大小不合理造成的短暂的慢速分配，或者是大对象的分配直接进入慢速分配。在慢速分配的过程中，因为要做很多扩展的处理，加锁的处理，甚至gc处理，所以过程所需要的时间非常长。