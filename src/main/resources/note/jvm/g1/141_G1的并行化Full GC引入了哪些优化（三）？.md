回顾：

1、计算对象的新地址做了哪些改进？

串行化的弊端——无法压缩出一个完全空闲的region，为什么不能搞一块完全空闲的region。

2048，它怎么去控制2048个分区，压缩出来一块儿空闲呢？Gc roots 本身在访问引用链的时候，肯定不可能是按照region的顺序一个个来访问，按照对象在哪个分区来处理。每次处理到哪个region，基本上可以认为是随机。

 

并行化的优化——通过对多个region的集中处理可以压缩出一个完整的region

2、如果压缩过程中出现了跨分区应该怎么办？

对象不允许跨分区存放，因此引入了G1FullGCCompactionPoint记录分区使用情况，以防止跨分区情况的出现。

 

本节内容：

1、计算新位置后的引用更新操作

前面的一系列操作完成后，就需要把引用更新到新的位置上去，对象头呢已经指向了新的位置了。

此时，就需要把所有的活跃对象遍历一遍，把对象间的引用，也指向到新的位置上去。也就是说，需要遍历所有活跃对象，以及活跃对象的字段，然后把所有对象之间的引用，更新到最新的位置上去，此过程更新的是存活对象引用的存活对象的新位置，也就是除了对象复制的工作，其他的引用位置，对象的新位置，都已经搞好了。注意看，假如有一个student对象引用了score对象，socre对象的新位置已经确定了，如下图所示。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/96433500_1641819210.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

在更新了引用之后，student引用的就是新位置的对象，如下图所示：

 

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/93556300_1641819210.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

然后下一步就会进入压缩处理，把所有的存活对象复制到新位置，然后把垃圾对象和复制后的旧对象全部清理掉。

 

2、移动对象完成压缩

在上述步骤完成之后，所有的对象新位置已经确定，所有对象的引用也更新到了最新的位置，那么接下来旧进入到对象移动，空间的压缩操作。

实际上对象的移动就是复制操作，把对象给复制到新的位置，然后把复制后的老对象，以及垃圾对象全部都回收掉。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/96056900_1641819210.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

经历了前面的完整操作以后，就有可能会空闲出来一些完整的空闲region，供程序继续使用。当然，此时Full GC还没有完全结束。

还需要一个非常关键的步骤。复制后的善后处理。

 

3、复制后的处理

我们可以看到，在前面步骤之后，其实垃圾对象已经完成了回收，由于并行化的操作做了一些优化，整体的效率会提升，而且完全有可能空闲出来一些完整的region可以给程序使用。在复制，回收这些工作，完成之后，会做一些调整操作。

（1）恢复对象头 对象没变位置，或者说一些锁信息

（2）遍历整个堆，然后重构RSet，因为对象的位置肯定已经发生了改变

（3）清除dirty card队列，并把所有的分区设置Old分区

（4）记录一些信息（本次GC相关的信息），同时新生代大小（YGC CSet的大小）重新设置，然后重新构建Eden，即对一些分区打上Eden区域的标识，支持下一次的对象分配，以及YGC等各种操作

4、关于并行化Full GC的一些优化点总结

（1）使用多线程进行垃圾回收

（2）标记过程采取多线程并行处理的方式进行标记

（3）采取了任务窃取策略，提升整体的效率

（4）采取了单个线程处理的那些分区做整体压缩的处理，提升空闲region的产生的可能性

 

强调一点，Full gc的优化不代表，它的性能就变好了。性能依然非常之差。我们在做优化的时候，目标还是一个，尽可能的避免Full GC的出现。