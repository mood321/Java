本节内容：

1、大对象分配会走TLAB吗？它属于快速分配还是慢速分配？

 

1、大对象分配会走TLAB吗？它属于快速分配还是慢速分配？

要知道大对象能不能走TLAB，我们得知道TLAB的大小是多大，可是我们之前讲解的TLAB原理，没有告诉我们到底它的上限是多大呀？

之所以没有讲，是因为，要结合大对象来讲解这个点。TLAB的大小和大对象是相关的。因为，大对象的定义就是大于regionSize 的一半。也就是ObjSize > regionSize/2的时候，就可以称它为大对象。

大对象的分配也有一个特点，它不走新生代分配。而是直接存储在大对象的分区中，在一些书里面，也是说，直接分配到老年代。思考一下，为什么它要直接存储在大对象的分区中？不走新生代？

（1）大对象太大，并且存活时间可能很长

（2）大对象数量少

上面这两条，是大对象的特点，结合这两个特点我们来思考一下，如果说，大对象在新生代，那在GC的时候会很被动，因为需要复制来复制去，并且占用的空间还大，每次GC大概率又回收不掉。而它本身数量相对来说比较少，那肯定是直接分配到一个单独的区域来管理才更合理呀。

所以，G1在设计TLAB的时候就考虑了这个点，大对象定义不是ObjSize > regionSize/2吗？同时我把TLAB的最大值，限定在最大为regionSize / 2，这样子，大对象就一定会大于TLAB的大小，就可以直接走慢速分配，到对应的region里面去

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/36920300_1640327935.png)

那么G1为什么要这么设定呢？一个系统产生的大对象一般是比较少的，一个大对象来了就占满TLAB，是不是会造成其他普通的对象需要进入慢速分配？明明你大对象量不大，但是你一个人就要导致直接需要占用多个TLAB，并且导致紧随其后的大量的对象可能需要直接走重新分配新的TLAB，降低系统的整体效率，是不是不太合适？另外，GC的时候，也不方便，一个大对象引用的东西可能比较多，引用它的可能也比较多，所以说GC的时候不太方便去标记，并且称为垃圾对象的概率也小，在GC过程中，复制来复制去，肯定不合适。

 

新生代GC不想管，并且管理起来影响效率，所以新生代最好是不管大对象的，所以，干脆让他直接走慢速分配，反而能提升一些效率。

 

所以，G1设定TLAB上限就是一半的region大小，这个设定其实会让大对象直接走慢速分配。

2、大对象的慢速分配有啥特点？和普通的慢速分配有没有啥区别？

大对象和TLAB中的慢速分配基本类似。区别就是大对象可能会有大小的区别，造成分配过程可能稍微有一些不同，以及大对象分配前，会尝试进行垃圾回收。步骤如下：

（1）不同点再于，大对象分配的时候，会先尝试进行垃圾回收（ygc 或者 mixed gc），同时启动并发标记。注意是尝试去判断是否需要GC，是否需要启动并发标记，需要才会启动。不需要的话就不启动。

（2）大对象大于HeapRegionSize的一半，但是小于一个分区的大小，此时一个完整的分区就能放得下，那就可以直接从一个空闲列表拿一个分区给他用。或者空闲列表里面没有，就分配一个新的堆分区 --- 扩展堆分区。

（3）如果占用的空间大于了一个完整分区的大小，此时就需要分配多个对分区给它用。

（4）如果上面的分配过程失败，就尝试垃圾回收，之后在分配

（5）最终成功分配，或者失败达到一定次数，则分配失败。

![picture.png](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/38301400_1640327935.png)

思考：我们一直提到的，如果失败了就GC，失败达到了某个次数就分配失败，失败了以后，JVM就直接OOM了吗？如果不是OOM，有没有什么方式补救？