回顾：

1、YGC的并行处理是什么？

2、GC roots并行标记及RSet并行更新？

3、对于YGC来说，它仅仅是做了标记吗？

4、那么初始标记完成了以后，还会做什么事儿？

上一步只是把所有的存活对象给复制了， 并且呢是所有强引用的对象。

本节内容：

1、YGC中的串行处理是什么？

2、YGC中的串行处理操作有哪些？

（1）软引用、弱引用、虚引用的处理。

（2）整理卡表

（3）Redirty操作

（4）释放分区

 

1、YGC中的串行处理是什么？

所谓的串行处理，其实就是要一步一步操作，否则可能会出现错乱的一些操作，当然也不完全是，只能说目前JVM是这么把这些操作使用了串行化的处理方式，可能是因为，前后影响，可能是因为，消耗的时间很少，其实不排除后面可能会优化成并行化处理。。上节课我们说，gc roots 追踪，RSet更新，从RSet追踪这些操作是可以并行进行的，因为基本上不会出现互相影响的情况。

但是，YGC的一些操作，是有可能会出现先后影响的。

 

2、YGC中的串行处理操作有哪些？

（1）软引用、弱引用、虚引用的处理。

这个操作，其实就是把这些引用中使用的存活对象也给复制到新的分区，否则就会出现错误。大家还记不记得我们前面有讲过一些关于软引用的回收时机？在第一次Full gc的时候，是不回收软引用的，只有在第二次full gc的时候，才会去回收软引用，对吧？其实在YGC的串行处理操作的时候，就会把新生代里面这类的引用引用到的对象放入survivor区里面。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/67753100_1641211293.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

（2）整理卡表

大家直到，卡表是一个全局卡表，对不对？那么新生代在回收之后，是不是有些空间里面的对象已经被回收了？同时，有些对象已经换了位置，从原本的eden区的region中，被复制到了survivor的region中，对吧？那清除掉的对象，是不是需要把卡表中的描述数据也给清除掉？

 

因为我们之前说过，卡表中是一个字节描述512字节的空间，此时空间被清除了，那么卡表的描述数据肯定也要清空，不然肯定会出错，对不对？所以这一步操作就是把已经清理过的分区对应的卡表清空。同时把对象复制后所在的分区卡表做一下修改。保证卡表中的描述数据一定是正确的。

这个过程其实也是很快的。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/64679500_1641211293.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

 

（3）Redirty操作 ——重构RSet

这一步的主要操作，其实就是重构一下Rset。我们在做完垃圾回收之后，对象因为复制，对象的地址已经变化了，那么老年代引用的新生代的对象 相关的RSet此时还没有修改，此时要做的就是把旧的RSet给清理一下，然后重新建立一个对象所在的新的Region的RSet。

 

（4）释放分区

在新生代gc之后，把所有的非survivor区的region都给清理掉，此时他们还是被标记为eden，或者survivor（原本就可能有一些垃圾对象）。那么回收之后，肯定是需要把这些region分区释放掉的，不然其他的分区比如老年代，大对象，如果需要分区的时候，就不够用了。所以这一步就是做把分区给释放掉。释放的意思，其实就是把这些分区的标记给清理掉，然后加入到自由分区列表中。

 

释放掉以后，就保持这个新生代的现状了？新生代region就只剩下survivor区？肯定也不是。预测模型，动态调整新生代region分区。

 

接下来，这些被释放的分区，就可以在下次作为新生代分区，或者作为老年代分区都是有可能的。

 

3、思考题

思考：如果我们是G1的开发者，在上面的流程结束之后我们需要做什么？

 

大家要牢记一点，G1本身的设计思路就是，要垃圾回收优先，要满足系统的停顿时间。那么我们在gc之后最最重要的事情是什么？

提示：

（1）停顿预测模型 和region数量分配有关

（2）RSet的处理，RSet处理的时候，是比较耗时的，**GC****开启的时候refine****线程就会暂停**，由GC线程来继续执行后续的操作，那么对于这个RSet 和 DCQ DCQS的处理，需要调整吗？

（3）扩展内存要不要搞一下？

 

希望大家结合前面的内容好好思考一下，如果我们作为设计者，要做一个比较合理的垃圾回收机制，并且是要满足停顿时间的垃圾回收机制，应该如何考虑上面的这些问题