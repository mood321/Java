回顾：

1、-XX:ParallelGCThreads 这个参数是指定并行 GC 线程的数量，一般最好和 CPU 核心数量相当，如果不设置的话，会自动推断。

2、参数ConcGCThreads，默认值为0。

3、-XX:HeapSizePerGCThread=，默认值为64。

4、参数-XX:-UseDynamicNumberOfGCThreads，默认为false。

5、-XX:G1SATBBufferSize=，默认值1K，表示每个SATB队列最多存放1000个灰色对象。G1SATBBufferSize这个值不是SATB queue set的大小。

6、参数-XX:G1OldCSetRegionThresholdPercent=，默认值是 Java 堆的 10%

7、参数-XX:GCDrainStackTargetSize=，默认值为64。这个参数表示并发标记阶段，一次最多能标记多少个对象。

 

本节内容：

1、-XX:-ForceDynamicNumberOfGCThreads,默认为false.这个参数和我们上节课见过的参数有类似的效果，-XX:-UseDynamicNumberOfGCThreads。不同的是这个参数是强制开启动态调整线程数。

2、MarkStackSize和MarkStackSizeMax，这个参数表示在并发标记阶段中用到的标记栈的大小。默认情况下，在32位JVM中为32K和4M，64位JVM中为4M和512M。当然，如果我们没有设置，G1是会按照自动推断的方式计算设置这些参数。这个参数的调优结果在测试中没有显示出很好的效果，前后同样的环境下，对系统的整体影响不大。

在某种特殊场景下，可以尝试调整此参数来尝试提升效率：

（1）当发现并发标记过程时间比较久，并且并发标记阶段的根对象的数量和对象字段的数量非常庞大，此时可以尝试调整此参数去提高并发标记阶段的速度。避免标记栈过小导致的其他问题。

注意：标记栈是有可能会溢出的，在溢出的时候，JVM会尝试停止标记操作，然后去尝试扩展这个标记栈。这个过程是会降低标记效率的。

如果使用的是CMS垃圾回收器的话，也会有类似的参数：

-XX:CMSMarkStackSize=8M，-XX:CMSMarkStackSizeMax=32M，这个参数主要的意义就是，并发标记阶段，标记栈到达给多大。对于G1来说，大家可以粗略的认为就是在标记存活对象过程中，把对象的一个个字段加入到一个栈中，这个栈就是我们MarkStackSize这个参数所设置的。一般情况下也不需要去设置，保持G1本身的默认值就可以。

这些冷门参数，一般情况下是不调整的。大多数情况下，只需要调整那些主流的参数其实满足大多数系统需求了。

3、G1MixedGCLiveThreshoudPercent，这个参数默认值是85。 表达的意思也很简单，用于判断回收的时候选择region加入CSet时的一个判定阈值。如果说region中的存活对象比例小于这个85%，就会把这个region加入到CSet里面去。这个其实就是判定，region是否有比较高的回收价值。

 

前面的课程我们也有提到过这个参数，这个参数其实一般情况下也不需要调整。即使要去调整，也要有大量的测试数据来支撑。

简单分析一下：如果说这个参数调整的太大，比如说95，也就是说，只要存活对象比例小于95%的region都会加入到CSet中去，10个region，50region，本来mixed GC，进行3次就完成回收，8次才完成回收。带来的收益是，在回收的时候，可能会有更多的对象会被回收掉。带来的负面影响是，会严重降低回收的效率。因为95%的存活比例，属于非常高的，回收一个region的时间/回收垃圾数量的这个比例会比较低。整体效率会比较低。

如果这个参数调整的太小，比如说，50%，也就是说小于50%的才会进入到CSet中去回收，那一次回收的垃圾对象数量会比较少，同时因为大量60%，50%+的使用率的region并没有被回收，可能会导致G1存在比较多的内存碎片，内存利用效率会比较低。可能回导致比较频繁的GC。

因此对于这个参数的调整还是需要综合考虑具体情况来具体分析。一般情况下，保持默认值不变即可。

4、参数G1ConcMarkStepDurationMillis，默认为10，这个参数表示每次并发标记阶段执行的时间要在10ms内完成。

并发标记，其实是一个限时操作。混合回收的时候，有可能会出现再次重新标记。可能会出现多次并发标记。

这个值的大小可以影响到并发标记的频率。对于G1的混合回收，并发标记并不是一次完整的混合回收，只进行一次并发标记，是有可能出现多次并发标记才能完成所有的标记任务。那么这个参数的大小其实就可以决定并发标记的频率，如果时间调整的比较小，意味着并发标记的频率会高一些，时间调整的比较大，并发标记的频率会低一些。

如何调优？什么时候调整这个参数？

如果要调优这个参数，我们需要知道，并发标记的频率会带来什么样的影响。如果说并发标记频率比较低，也就是说，并发标记单次的时间比较长，会造成什么影响？系统是会不断运行的，新对象是会不断产生，remark重新标记的时间也会比较长，假如说我们把并发标记的时间拉到10s，是不是10s钟内，就有可能直接触发full gc了？因为垃圾对象太多，而混合回收又卡在这个并发标记，remark重新标记这两步里面了。10ms一般来说是足够用了，如果说full gc比较频繁的时候，除了空间分配合理，还有一个可能就是：并发标记不够及时，混合回收不够及时，并发标记占用了过多时间，垃圾回收不及时。

所以如果说发现了频繁的full gc，通过各种比例的调整效果不好的时候，可以尝试减小这个并发标记的时间，提高并发标记的频率，减少remark的时间，尽可能早的完成混合回收。

 

5、G1UseConcMarkReferenceProcessing，默认为true，打开的意思是，可以在并发标记的时候处理软引用相关的对象。这个参数一般来说也是不需要动的，如果说系统里面使用的软引用比较多，比如反射用的非常多，可以考虑关闭这个参数。