回顾：

记忆集是什么？

标记对象怎么标记？

跨代引用带来的问题

怎么解决跨代引用的问题？

记忆集RSet里面记录了什么东西？哪些引用关系需要记录，哪些不需要记录？

 

本节内容：

1、引入位图可以干什么？

2、位图在对象引用方面的应用，会造成什么问题？

3、怎么优化位图？

4、什么是卡表？

5、卡表和位图到底是什么关系？

6、思考：卡表和Rset记忆集是怎么结合起来使用的？

 

1、引入位图可以干什么？

前面我们介绍过位图，其实就是把一个字节，里面8位， 01 用来标识一下某个内存区域的是否使用的一个状态。

 

一个简单的例子，假设有两个分区，分区1里面有一个对象student，分区2里面有一个对象score，并且student.score = score，此时这两个分区就有了引用关系了。那么问题来了，如果我要找到分区1是怎么引用的分区2，我应该怎么做？

（1）我对1分区的内存按照一个字一个字的遍历。（注意：一个字节8个位，在一个64位的电脑上，一个字是64位），为什么用一个字一个字的来遍历，是因为，计算机底层虽然存储单位是字节，但是因为JVM中对象会做对齐操作，所以不需要按照字节来移动。遍历的时候，再看看每个字里面的值是不是指向B分区。  这种方式很显然效率低，他要做的就是，遍历整个内存，然后步长是按照一个字来做，一个字就是8个字节，64位

（2）优化后的遍历，借助对象长度来遍历，每次遍历的时候，都按照当前遍历的对象的长度，一个一个对象去遍历。例如student长度为512K，那在遍历student的时候，下一次遍历就从512K之后开始遍历。student2 256K 这样子效率会高出很多。

上面两种方式虽然经过了优化，但是遍历这个操作，很明显，在内存越大，或者说region越大的时候效率会越低。很显然是不合适的，因为，找一个引用关系，要遍历一次。时间复杂度是o(n)，如果说，我要找10000个对象？遍历一万次region。

所以就有了第三种方式，借助额外的数据结构，位图。

（3）比如，我现在用bitmap记录A和B的内存块儿之间是否发生了引用，我在bitmap里面用一个位，描述一个字的是否引用的状态。

也就是说，我在A中维护一个bitmap，每一个位，记录以下，对B分区中的一个字，到底是否存在引用关系，如果有引用关系，bitmap的位就记为1，如果没有就记位0。所以说，它的这个时间复杂度，O(1)，这样子就可以直接通过位图来找到是否引用，而不用遍历整个A分区，才能确定是否存在引用。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/83036600_1640665752.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

思考：这种位图的方式，会造成什么问题？

 

2、位图在对象引用方面的应用，会造成什么问题？位图过大，描述内容很少。

（1）描述内容太少

因为位图，只有 0 1这样的标记，只能证明是否有引用关系，即，引用了，还是没引用。但是JVM在垃圾回收的时候不单单只需要引用，没引用这个信息，它会需要一些其它的一些描述信息，使用量，内存起始位置啊。否则GC可能因为信息缺乏，导致无法正常回收。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/83348800_1640665752.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

（2）内存问题

描述信息太少的话，就只能通过增加描述位来增加描述信息。比如说，我们不用一个位来描述一个字，而是使用一个字节来描述一个字（从使用1位二二进制位描述64位内存的信息，到使用8位二进制描述64位内存的信息），这样的话，就可以解决描述信息太少的问题。

但是新的问题来了：一个位图占用的内存过大了！

例如：我们一个region 1MB大小，如果用一个字节描述一个位，就意味着，我们需要1024 / 64 * 8 = 128KB来描述一个region，相当于占用12.5%的region空间，去描述另外一个region。这个内存占比太大了。如果是在32位的机器上，甚至需要25%的空间。如果说，我要描述一个region的内存情况，1MB的内存，需要用掉128KB额外内存，来描述。

1G，128MB，10G，1G多的描述数据，bitmap

所以，使用位图的方式，最大的问题，就是额外占用的内存空间太大了！

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/83195300_1640665752.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

从图中可以看出来，一个字节描述一个字，还是很耗费内存的。相当于把描述能力降低了8倍，把内存空间上升了8倍。

 

3、怎么优化位图？

既然我们发现了内存占用空间太大的问题，那么我们就可以考虑把它优化掉。大家想想看，对象一般情况下，肯定不可能只占用一个位这么小的空间，所以，我们直接把一个字节描述一个位的内存使用情况，优化成描述一个对象的空间，这样子不是好很多了吗？

但是对象本身又是不规则的，不一定多大，所以，肯定不能直接用对象的大小来作为描述的粒度。最终JVM确定的是，用一个字节来描述512字节的内存空间。即8位来描述512 * 8位的内存信息。

这样一来，就可以在内存占用上面大大缩减，也就是，2KB的位图就可以描述1MB的内存空间，同时也可以兼顾引用关系查找的速度，不用再采取遍历的方式来找到引用关系。直接在访问对象的时候，通过对象来访问这个位图里面对应的引用关系就OK了。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/84183500_1640665752.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

4、什么是卡表？

所谓的卡表，其实就是上面说的东西，就是把整个堆内存，按照512字节的粒度，拆分成一个一个card，然后搞一个全局的卡表，卡表中每8个字节描述512字节内存的引用关系，使用情况什么，这就是G1中的卡表。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/87617500_1640665752.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

5、卡表和位图到底是什么关系？

所以，卡表其实就是位图思想的一种实现方式。只是粒度不同罢了。位图用每一个位来描述对应数据的状态，卡表，其实就是按照位图的思想，用一个字节来描述512字节内存的状态，引用等相关数据。

总结来说就是，卡表是位图的增强版。

 

6、思考：卡表和Rset记忆集是怎么结合起来使用的？

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/88258100_1640665752.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

提示：Rset中存储的就是卡表地址。