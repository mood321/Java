回顾：

1、并发标记的漏标、错标问题
2、三色标记法结合SATB如何解决错标漏标问题

 

本节内容：

1、初始标记 STW

首先，一定会伴随一次YGC。在YGC的时候会做一个判断，是否需要开启并发标记，如果需要开启并发标记，那么本次YGC的整体过程，会额外做一些事情，把gc roots直接引用的老年代的对象也标记起来，作为并发标记的起始对象的一部分。

初始标记的时候会发生YGC，YGC结束之后，在survivor区的对象会作为一部分的并发标记的起始对象（根对象，可以理解为gc roots对象）

所以，在初始标记阶段中，必然会发生一次ygc。

 

2、并发标记

在YGC之后，根据判定条件，开启并发标记的线程，执行并发标记的任务。并发标记阶段，从survivor区存活的对象+gc roots引用的老年代的对象结合RSet来进行标记，并引入位图+三色标记法来做对象是否存活的标记，白色代表死亡、黑色代表存活、灰色代表存活但其子对象尚未遍历完全。

我们在做并发标记的时候，是不是也是按照分区来进行的。G1本身就是从分区出发来处理的。借助RSet才能找到所有分区内的存活对象。

引入了SATB+SATB队列+写屏障来做错标漏标的最终处理，多次并发标记的过程中，出现的引用变化，都会记录下来。

 

3、最终标记阶段 STW

最终标记阶段，主要是针对并发标记阶段由于系统运行造成的错标漏标情况做修正处理。本质就是把所有SATB队列里面的对象重新做遍历标记处理。最终把对象全部都标记为黑色，或者保持原本的白色。

这个过程，另外一个目的，就是为了结束整个标记过程，因为我们在并发标记阶段，是不会进行stw的，所以如果不引入这个重新标记阶段，stw把所有对象都标记完成，那么标记阶段就会随着系统运行需要持续不断的运行下去。

 

4、预回收阶段

我们在前面的课程中讲到，在最终标记阶段之后，是有一个存活对象计数的阶段的，也就是统计一下每一个region内部到底有多少对象存活，多少垃圾对象。那么实际上因为位图的存在，我们相当于在最终标记阶段之后，就可以根据位图中的标记数据，把存活对象根据位图统计出来。

实际上在mixed混合回收中，有这么一个预回收阶段的，这个阶段就包括了统计存活对象这么一个阶段。实际上这个阶段做的事情还是比较多的。

（1）RSet +BitMap 完成存活对象的统计工作。并把统计的结果用来排序region

（2）更新标记位图，即prevBitMap，为下一次并发标记做准备（如果回收成功，则忽略）

（3）重置RSet，老年代的分区已经完成标记，如果标记后的分区没有被对象引用，说明引用已经改变，此时就可以删除原来的RSet里面的引用关系。

（4）清理掉全部都是垃圾对象的分区，然后把分区放到空闲分区列表中

我们需要特别注意：这个阶段，所谓的清理，只会针对所有对象都是垃圾对象的分区，对于存在存活对象的分区，不会有任何操作。也就是说，很有可能在这个阶段结束之后，JVM的内存使用情况没有任何变化。

 

5、混合回收阶段

在这个阶段，JVM需要选择一些分区进行回收，这些被选中的分区，成为Cset（Collect Set），回收时被选中的这些分区。然后把这些分区中的存活对象复制到空闲的分区，复制完成之后，清理掉选中的region，同时把这些分区放入到空闲列表中。

需要注意的是，在选择CSet的时候，是按照一定的选择算法来选择CSet的。我们在上一个阶段，已经统计出来了Region的存活对象的数量，垃圾对象的数量，那么其实CSet的选择就是根据这个基础来做的。

 

6、Mixed回收的整体流程图

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/29279100_1641818179.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)