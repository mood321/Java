回顾：

1、案例背景回顾

案例的业务背景：一个提供订单数据分析的业务系统。

数据报表系统的配置：32G 16C，给报表系统的堆内存大小：20G

2、问题场景介绍

本次问题发生的场景是在一次需求之后，这次的需求是在订单数据分析系统上添加一个功能。这个功能简单来说就是，一个数据对比页面。比如价格环比，价格波动，订单量增涨率，增涨环比，平均价格，平均价格环比，中位数，离散分布图等等。

到月中，月末就会有大量的商家打开这个环比页面，导致吞吐量骤降至单台3K左右，于是就有部分用户反馈系统反应慢，偶尔出现超时的现像。

3、问题原因分析 --慢速分配 大对象分配

由于对象过大，导致大量走大对象分配的请求，直接拖慢了环比页面的速度。

又因为大量的大对象分配，导致MixedGC触发的频繁，导致了系统总吞吐量的下降。

5、解决思路

（1）减少大对象分配频率

（2）增大TLAB的大小

调优后的参数：

-XX:InitialHeapSize=20G -XX:MaxHeapSize=20G -Xss1M -XX:MinTLABSize=1M -XX:+UseG1GC -XX:SurvivorRatio=8 -XX:MaxGCPauseMillis=300 -XX:G1HeapRegionSize=16M -XX:MaxTenuringThreshold=15 -XX:InitiatingHeapOccupancyPercent=45

 

本节内容：

结合前面两节的内容，我们其实不难发现YGC真正容易出现性能问题的点，主要就是停顿时间，region大小相关的。基本上这两个参数设置合理之后，很少会出现比较大的性能问题。但是这个优化点主要针对的还是GC相关的问题。

对于对象分配效率这块儿其实也有一定的优化空间，比如上节课我们所说的region调大，TLAB调大，都是为了在分配对象的效率上能够有较大的提升。那么针对对象分配，最重要的点就是TLAB相关的参数。本节课我们就再对TLAB相关的参数做一些详解，提出一些优化思路。

需要注意的一点是：TLAB并不是G1的专属设计（再次强调），而是JVM本身就带有的功能。只不过在G1里面结合region又做了一些适配而已。

1、参数内容

（1）-XX:+UseTLAB 这个参数表示是否开启TLAB，默认情况下为true，我们一般不是特殊情况不要关闭这个选项。

（2）-XX:+ResizeTLAB，指是否允许TLAB大小动态调整。G1中TLAB会动态调整大小，主要是基于历史信息（每次分配大小、有多个少线程参与对象分配等），一般来说采取动态调整的模式，性能会更好。动态调整的模式性能在JVM的社区有人作过相关基准测试。感兴趣的同学可以看看这个基准测试的情况。

[https://umumble.com/blogs/java/how-does-jvm-allocate-objects%3F/](https://umumble.com/blogs/java/how-does-jvm-allocate-objects?/)

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/apppuKyPtrl1086/image/ueditor/64079400_1644392383.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

经过实验，在不开启ResizeTLAB的场景下，性能从少量线程，到多线程始终是弱于开启的情况的。并且不开启UseTLAB的情况下，性能会非常差。

 

（3）-XX:TLABSize 这两个参数分别指，设置TLAB的值（设置后会固定），并且不能动态调整。如果说我们直接设置了这个参数，会直接导致ResizeTLAB被禁用，很可能导致性能下降。

 

（4）-XX:MinTLABSize =64，指设置TLAB的最小值。在我们上节课的讲解中，由于我处理过的那个系统是大数据分析系统，所以设置了一个比较大的TLAB的值，在实际生产中，这个值需要经过一定的观测才能设置的比较合理。设置的比较合理的TLAB最小值，可以让系统更快的进入到内存碎片与分配效率的平衡。并且在一定程度上能提升对象分配的效率。正常来说，设置的值不要太过于奇葩，可以设置成4 8 32这样的值。一般来说设置64K，作为初始值，就是一个比较合理的值。至于为什么是64K，这个最好结合自己的系统情况去分析。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/apppuKyPtrl1086/image/ueditor/66580500_1644392383.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

这个1M的数据是一个非常夸张的数据，一般来说不可能设置这么大的值，因为设置这么大的值的同时，线程数量也比较多，很可能直接导致Eden区的占用率超过了默认的1%，设置了也没什么用。而且不经过实验就搞这么大的值，很有可能会导致大量的内存碎片。

TLAB的内存浪费造成的碎片如果过多，还是会导致性能下降的很厉害。

 

（6）-XX:TLABWasteTargetPercent = 1 这个参数指的是TLAB可以占用的Eden空间的百分比。默认值是1，也就是1%的Eden空间。增大这个值，可以分配更多的TLAB给线程使用。如果说实际系统运行的过程中，线程数量比较多，可以调大这个参数。上节课我们的那个例子中，因为是16C的机器，系统的压力虽然比较大，但是由于是大数据系统，线程数量相对来说会需要少一点，处理的时长会相对长一点。所以调整这个比例的效果，不如调整MinTLABSize。如果是正常QPS压力比较大，线程数量比较多的系统，则可以考虑调大这个参数，这样的话，每个线程的TLAB不至于太小。

 

（7）-XX:TLABRefillWasteFraction，指的是TLAB中浪费空间和TLAB块儿的比例，默认值64，即1/64。分配效率提升主要是TLAB分配的比例，如果过分追求分配效率，则有可能会导致内存碎片比较大，因为可能会产生大量可浪费的内存（最终会被dummy对象填充）。如果要调整此参数，需要着重观察TLAB日志中的waste中的slow和fast的值，如果这两个值非常大，就说明内存浪费严重，需要适当减少该值。

 

（8）-XX:TLABWasteIncreament 指的是动态的增加浪费空间的字节数，默认值是4，即每次动态增加的时候都增加4字节的浪费空间。一般来说不需要设置这个值。

 

（9）-XX:GCLockerRetryAllocationCount 这个参数代表了分配失败的次数阈值。如果超过了这个阈值之后，就会直接分配失败。默认值为2，这个值最好不要调整，因为分配2次还是失败的话，基本上说明普通的GC（ygc 和mixedgc）已经无法清理出足够的空间了。调大这个数字很有可能会导致多次无效的GC。造成停顿的同时，没有真正的解决问题。