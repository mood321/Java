回顾：

1、优化方向：串行变并行

2、并发标记的过程为什么可以并发？

3、总结

4、思考题

 

本节内容：

1、优化点之并行化处理

上节课我们已经讲了，G1的region分区结合RSet的机制，天然就支持并行处理。也就是说，多个线程可以各自负责一些分区的标记、整理、压缩这些过程。如下图所示：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/50551700_1641818985.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

因为每个分区对于某个线程来说，不需要找太多的东西就可以完成标记，压缩整理的工作。比如说，一个线程负责100个region的整理工作，整理完成后，继续再找100个region继续执行。多个线程之间，也不会发生冲突，整体效率肯定比单线程串行化处理要性能高上很多。

那么并行化Full GC到底有哪些步骤？

 

2、并行FGC开始前的前置工作

在Full GC开始之前，肯定还是要做一些准备操作。

（1）对象头、锁信息等信息的保存处理。

每一个对象都是有对象头的，里面保存了对象的位置信息，锁信息，GC标识等等信息，这些东西肯定都是需要预先保存起来的。因为这些信息对于对象恢复，数据恢复是很重要的。不能对象复制完成了，其对象头里面的信息，却丢失了是吧？所以第一步就是做一些保存的操作

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/50871100_1641818985.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

（2）在保存完一些对象头相关的信息之后，就要开始Full GC了

具体步骤和串行化的Full GC是类似的。

（1）标记存活对象

（2）计算对象的新地址

（3）更新引用对象的地址

（4）移动对象完成压缩（其实就是复制覆盖操作）

（5）对象移动后的后续处理

 

3、并行标记过程（STW）

FullGC变成并行过程之后，并行标记过程和串行化过程差别不是很大。都是要标记出来所有的存活的对象。

需要注意的是，因为是并行化处理，所以，多个线程在进行并行标记的时候，比起串行化处理，多使用了一个栈结构来给每个线程做一个标记栈，也就是把起始对象分成多份儿，每一个GC线程，持有一部分。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/51125500_1641818985.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

 

4、Full GC的并行标记过程和并发标记的区别

这个并行标记和MixedGC的并发标记，并不是一个概念，这个并行标记，是指，多个线程可以并行的执行标记任务，不会互相影响。而MixedGC的并发标记，是指GC标记过程和程序可以同时运行。如下图所示，在FULL GC的标记过程中，是会STW的。

![picture.jpeg](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/88815900_1641818985.jpeg?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

 

而对于标记任务本身来说，是并行同时去执行的。如下图所示：图中画绿圈的，就是可以多个线程并行同时去执行的任务。

![picture.jpeg](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/88048100_1641818985.jpeg?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

我们回想并发标记的过程，其实在并发标记的时候，会有一个非常重要的东西就是SATB及SATB队列，那么在Full GC里面需要这个队列吗？很显然是不需要的，因为我们不会出现前后不一致的情况，前后不一致，一个是，程序运行和GC标记同时进行造成的不一致，另外一个就是并发标记过程可能会中断，然后再次进入并发标记，导致标记不一致，或者说，有新的引用关系出现。

Full GC会对所有堆分区里面的对象都进行标记，而且系统程序会STW。

 

5、Full GC标记过程中的任务窃取

因为Full GC的标记过程，不存在正确性的的问题。因为STW，同时不同线程是针对的不同的分区进行的标记，所以正确性上肯定是不存在问题的。但是如果效率上可能会存在问题。

比如说，一个线程分配的region，因为引用关系简单，存活对象少，标记起来比较容易，速度很快，一个线程分配的region，因为引用关系复杂，存活对象多，标记起来比较麻烦，速度标记慢。此时需要做一些平衡操作，也就是，任务窃取！如图所示，此时线程1里面的所有gc roots引用的对象已经处理完了。（标记为肉黄色），而线程三连第一个还没有处理完成

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/90350300_1641818985.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

这个时候为了整体的性能，线程1就会从线程3那里窃取一些任务。如下图所示：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/93424500_1641818985.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

这样的话，就能尽可能的保证所有的线程都是一直处于工作状态的，即使有空闲的线程，也会去窃取任务来执行，如果无法窃取，那么就说明标记工作已经到了尾声。这样子的处理，能够充分发挥多核CPU的性能。

 

6、总结

（1）标记的前置工作

（2）并行标记的过程

（3）并行标记过程中的特殊数据结构（任务栈）

（4）并行标记的性能另一个性能优化点：任务窃取

提升了整体的性能：并行+任务窃取

7、思考：在FULL GC的其他环节，有没有优化的空间？如果是我们自己来做，应该怎么做，才能充分提升Full GC的从时间层面的效率？引入并行化之后，空间方面有没有优化的空间呢？

提示：串行处理，需要一个一个分区去处理。Gc roots遍历到哪个分区就处理哪个分区。并行化处理，一个线程可以处理多个分区。