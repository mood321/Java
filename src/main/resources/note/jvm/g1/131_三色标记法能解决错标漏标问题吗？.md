回顾：

1、三色标记法中的白、灰、黑

2、三色标记法的对象转换过程

经过并发标记的整个阶段以后，所有的对象要么是黑色，要么是白色，黑色的对象是存活对象，白色的对象代表可以被回收。

 

本节内容：

1、标记出现漏标、错标的条件

（1）系统程序在并发标记阶段中，在一个被标记成黑色的对象上面，添加了一个到白色对象的引用。因为黑色对象已经被标记，如果不重新扫描一下这个黑色对象，那么这个白色对象将会被漏标。程序运行会出现错误。

 

当然，如果说，还有灰色对象在引用这个白色对象，其实也无所谓，因为灰色对象的字段会被遍历，重新找到这个白色的对象，进行标记。这样还不会出错。怕就怕在，系统程序还会做别的操作，就是第二个条件：

（2）系统程序在并发标记阶段中，删除了所以灰色对象到这个白色对象的引用。

我们把这个场景演示一下，注意看：

最开始，E这个对象，没有任何引用，此时并发标记已经开始一段时间了，系统也在不断的运行。如下图所示：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/80091000_1641817866.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

假如我此时程序执行了一个操作：

F.g = null,
C.g = G

那么此时的引用关系会变成这样子：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/18125300_1641817867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

我们按照上面的思路分析一下，如果说，我们此时不对C进行重新处理，是不是就会出现G被漏标的情况？因为C已经是黑色了，说明是存活对象，而且已经完成了标记。此时F正在标记过程中，但是F已经不再引用G，那就会导致G一定会被漏标。最终造成程序错误。

所以，这个问题必须要解决，那么解决的思路之一就是利用三色标记法的状态转换来保证最终标记的正确性。我们一步一步来分析。

 

2、标记的信息存储在bitmap中

前面我们讲过，我们说G1引入了bitmap来标记对象的状态，其实这些黑色，白色，灰色的状态就是存储在bitmap中。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/20579000_1641817867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

并发标记结束的时候，所有为白色状态的对象都是可回收的对象。此时会有一个新的疑问，那并发标记阶段产生的新对象怎么标记？存储在哪里？其实就是在并发标记的下一个阶段，重新标记阶段，重新标记阶段，会把所有产生的新的对象做一个重新标记。并纠正在并发标记阶段造成的一些引用该表导致标记状态不正确的情况。

 

3、三色标记法到底是怎么解决错误问题的？

我们先来分析一下造成错标或者漏标的场景。

（1）并发运行造成的错标漏标

假如说，在并发标记过程中，我已经完成了C对象的标记了，但是此时，执行了一个C.e = E，那么此时E对象是不是也是一个可达对象？但是我们的并发标记过程却没有标记到，因为刚刚好错过了时间，并发标记标记完了C对象，然后去干其他事儿的时候，程序又执行了赋值操作。我们看下图：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/20364300_1641817867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

此时E对象已经可达了，但是却还是白色。如果这个问题不解决肯定会导致E对象被回收掉，而在使用C对象的时候，出现系统错误。

 

（2）并发运行造成的错标漏标

继承上一次并发标记的情况造成的错标漏标。

 

假如我们第一次并发标记在标记到C、D对象，并且F已经被访问，此时CD都是黑色，那么标记只能终止。我们就只能进入下一次并发标记。此时的标记状态：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/20749700_1641817867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

在下一次并发标记开始前，程序执行了D.e = E，此时E对象是可达的，但是D对象已经被标记成黑色，E对象的白色状态不会改变，在回收的时候就可能会被当作垃圾对象被回收掉。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/23271400_1641817867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

 

那到底应该怎么解决呢？

其实解决的方法非常简单。我们直接在程序修改一个对象的引用关系的时候，改变一下改对象的标记状态即可。比如，我在执行了D.e = E的时候，直接把D标记为灰色。

然后在后续的操作中，再把灰色的对象重新走一遍，这样不就OK了？

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/24732000_1641817867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

当最终把所有的灰色对象都重新遍历一遍之后，还产生了一些新的垃圾对象，此时最终的状态如下：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/25268800_1641817867.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

这样子就能保证最终标记的正确性。

 

4、思考题

SATB是怎么解决这个错标漏标的问题的？