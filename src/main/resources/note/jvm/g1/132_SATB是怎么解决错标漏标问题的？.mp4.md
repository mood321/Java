回顾：

1、标记出现漏标、错标的条件

（1）系统程序在并发标记阶段中，在一个被标记成黑色的对象上面，添加了一个到白色对象的引用。因为黑色对象已经被标记，如果不重新扫描一下这个黑色对象，那么这个白色对象将会被漏标。程序运行会出现错误。

 

当然，如果说，还有灰色对象在引用这个白色对象，其实也无所谓，因为灰色对象的字段会被遍历，重新找到这个白色的对象，进行标记。这样还不会出错。怕就怕在，系统程序还会做别的操作，就是第二个条件：

（2）系统程序在并发标记阶段中，删除了所以灰色对象到这个白色对象的引用。

我们把这个场景演示一下，注意看：

最开始，E这个对象，没有任何引用，此时并发标记已经开始一段时间了，系统也在不断的运行。如下图所示：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/53736500_1641817979.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

假如我此时程序执行了一个操作：

F.g = null,
C.g = G

那么此时的引用关系会变成这样子：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/53435200_1641817979.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

我们按照上面的思路分析一下，如果说，我们此时不对C进行重新处理，是不是就会出现G被漏标的情况？因为C已经是黑色了，说明是存活对象，而且已经完成了标记。此时F正在标记过程中，但是F已经不再引用G，那就会导致G一定会被漏标。最终造成程序错误。

所以，这个问题必须要解决，那么解决的思路之一就是利用三色标记法的状态转换来保证最终标记的正确性。我们一步一步来分析。

2、标记的信息存储在bitmap中

3、三色标记法到底是怎么解决错误问题的？

 

上节课我们分析了直接利用三色标记法是怎么解决错标漏标问题的，思路其实就是把某个引用改变了的对象重新置为灰色，然后在后续的阶段重新再处理一下这个对象的引用关系。

 

那么SATB是怎么解决的呢？

1、bitmap和几个指针保存的一份儿快照

大家还记不记得我们前面讲的prevBitMap，这个bitMap我们前面介绍说，它是用于被NextBitMap继承的。提升效率的。其实它还有另外一个作用。

由于它记录了上一次并发标记过程中的对象标记情况。那么在这个prevBitMap中标记的内容和对象直接的对应关系我们肯定是知道的，那么本次并发标记开始之前，以及开始之后，都有可能会对已经标记好的那些对象做一些引用关系的改动，其所对应的对象在这个引用关系改变之前的状态我们肯定是可以通过这个prevBitMap知道的。

在第二次并发标记开始之前，标记状态如下图所示：

 

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/53143400_1641817979.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

这个其实就是SATB快照的由来，实际上就是基于上一次并发标记标记出来的一份儿PrevBitMap，能够知道对象的标记状态而已。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/53485500_1641817979.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

2、SATB到底是怎么处理变化的引用关系的？

 

当执行了F.g = null,C.g = G操作的时候，引用关系就会发生变化，我们上节课的思路是，我把C这个对象置为灰色，重新从C出发，再标记一次。而SATB的方法是，我把G这个对象，存到一个地方，等到本轮次并发标记结束之后，再把这些保存的没有遍历标记到的对象，再重新标记一次。就可以了。大家看下图，此时会变成这个状态：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/55187200_1641817979.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

大家注意，此时引用关系已经变了，nextBitMap会自己继续干自己的事儿，继续往后标记。

这种做法，相当于是把G这个对象置为了灰色。而三色标记法，最终是需要把所有的对象标记成白色，或者是黑色的，所以灰色的对象是一定需要再重新处理一遍的。此时标记状态如下图：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/94053100_1641817979.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

当并发标记完成后，在重新标记阶段就可以把这些在SATB关联的队列里面的对象拿出来一个一个做可达性分析，因为CDF这些对象不需要重新标记，只需要把G是否可达分析一下就行了，所以直接看看这个队列里的对象是谁引用的，又引用了谁，就可以把这些对象全部都给正确标记上。

最终整体的标记状态，就会是这个样子：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/93192800_1641817979.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

所有的SATB队列已经清空，同时所有的存活对象，死亡对象也都被标记在NextBitMap中。

 

3、那STAB到底是怎么记录这个对象的呢？怎么把对象放入SATB队列中的呢？

 

其实也很简单，大家还记不记得我们前面讲过的写屏障？但是我们讲的是，在处理RSet变更的时候，用增强代码写到DCQ里面一条变更的消息对吧？

实际上这里也用到的写屏障，在执行一些引用更新操作的时候，把新的对象赋值给老对象的某个字段之前，会把这个新的对象写入到SATB队列中。

 

我们也可以理解成，这是一段增强代码。类似于AOP的思想，当然这种思想是通过写屏障来实现的。所以本质上F.g = null执行的时候（当这一步执行的时候，就代表引用关系可能会发生变化了，也就是第一步出现引用关系变化的时候，就会触发对象放入SATB队列这个操作），G这个对象，是会被写屏障试别到，然后写入到SATB队列中等待处理的。

 

我们看下面这张图：

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/93763800_1641817979.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

 

G1最终实现的方案，就是基于SATB这个方案来做的对象的重新标记。（也可以理解成校准操作）

其实也不完全是只有SATB，而是借助了bitmap+三色标记法+SATB快照+写屏障+SATB待处理对象队列，结合起来保证了整个对象的标记过程准确性。