回顾

1、运营场景业务分析

业务基本流程如下：

 

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/apppuKyPtrl1086/image/ueditor/54569000_1647077885.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

2、业务场景背景介绍

（1）分布式生成消息，即多台机器，针对同一个运营活动，把用户群体分成n个部分来生成消息

（2）batch推送消息，减少与消息中间件儿的网络通信

（3）运营消息推送平台内，使用多线程并发推送batch消息

（4）把一些大批量的查询借助一些其他的数据搜索引擎或者缓存来提升效率，比如，

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/apppuKyPtrl1086/image/ueditor/54617400_1647077885.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

 

3、问题现场及问题排查

subList + mq中间件儿网络抖动导致的bug

4、问题解决

subList使用的时候规范一下即可避免。

 

本节内容：

1、parnew + cms的full gc触发

ParNew + CMS触发的full gc的规则其实还是比较简单的。

总结来说，就是老年代不够用了。

当然老年代不够用的过程可能比较多，新生代晋升，大对象占用等等。但是不管怎么说，在使用parnew + cms的时候，新生代和老年代的比例往往都是比较均衡的。有些系统新生代甚至远大于老年代。

那么在这种场景下，full gc相对来说回收的空间，就不算太恐怖，毕竟回收的空间相对而言只有堆内存的1/2左右。

比较耗时的地方就是，全量标记，对象复制，压缩整理的过程，因此full gc即时偶尔发生一次（比如一天一次，或者几小时一次），其实完全可以接受。

 

并且，老年代对象的晋升，是有一系列的担保机制的，比如老年代的剩余内存大于新生代的存活对象，老年代的内存大于历次新生代晋升到老年代中的平均大小等等。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/apppuKyPtrl1086/image/ueditor/55607700_1647077885.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

因此，综合分析下来，parnew + cms触发full gc的时候，从空间上和处理算法（标记整理）上来说，偶尔一次还是能够接受的。

2、G1的full gc触发

前面我们已经讲了G1的full gc触发场景，基本上有两种：

（1）新生代晋升失败导致的full gc

有可能是因为晋升预留空间不够导致的，比如我们预留的晋升空间比例的参数G1ReservePercent调整为了5，而新生代区本次晋升的对象比较多，此时就会经常发生晋升失败导致的full gc，这种情况触发的full gc稍微好一点，因为老年代的实际使用量是

老年代大小 * （1 - --XX:G1ReservePercent%）。

并且，因为是晋升导致的full gc，所以此时新生代是刚刚执行完新生代回收的，基本上就回收相对比较小的区域即可。

即时如此full gc的效率依然还是很低很低的，因为中间涉及到大量的标记，压缩，整理，引用处理等等各种操作。

 

（2）对象分配失败导致的full gc

对象分配失败导致的full gc，就比较恐怖了。大家知道，我们在对象分配的时候，会经历TLAB->TLAB扩展->堆内存分配->region扩展->ygc->mixedgc->堆扩展->分配失败整个过程。

前面我们也给大家提到过，如果是这个过程造成的最终还是分配失败，那就意味着，整个堆内存的使用率非常非常高，即时经过了ygc ,mixedgc,扩展操作，还是无法成功分配。（这种场景，其实是包含了mixed gc不及时的情况的）

这个时候进入的full gc，大家几乎可以理解为，几乎大部分的内存都被占用了，连一个对象都无法成功分配。那么这种情况下，就说明full gc需要处理的region，几乎是整个堆内存里面的所有region。

 

并且结合我们前面见过的full gc的整个处理过程，从标记，对象头处理，到标记处理，到对象的移动，压缩，到清理，到Rset处理等等一系列操作，会非常非常耗时，这个情况下触发的full gc会非常之恐怖！

当然，如果没有乱调参数，正常情况下也不会进入到这么恐怖的full gc中。

 

比如说，我们第一点儿说的，如果ygc执行之后晋升失败，导致了full gc，那么就是reserve空间不够导致的。那换句话来说，分配对象失败，执行ygc之后，必然会发生晋升，此时有可能就会在晋升失败前触发full gc来清理了，基本上不会达到多次ygc,mixedgc之后，还无法分配成功的情况。

 

因为，有可能会出现，对象产生速度比较快，然后回收速度比较慢，虽然经历了N次GC，垃圾对象依然很多。

 

3、G1的full gc更加恐怖的原因总结

（1）G1通常来说要管理更大的堆内存空间，因此需要处理更多的对象。

（2）G1触发full gc的条件比较苛刻，在分配失败后进入full gc的时候，会几乎处理整个堆内存的空间

（3）G1在执行full gc过程中，需要针对更加复杂的Rset引用关系集合做更多复杂

处理。Region 对应 一个RSet