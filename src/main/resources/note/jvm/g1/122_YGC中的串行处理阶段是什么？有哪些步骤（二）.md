回顾：

1、YGC中的串行处理是什么？

2、YGC中的串行处理操作有哪些？

（1）软引用、弱引用、虚引用的处理。

（2）整理卡表

（3）Redirty操作 RSet

（4）释放分区 释放分区

 

本节内容：

1、尝试对大对象做一下回收

为什么要对大对象尝试做一下回收操作？大家要知道，大对象本身是占用很多空间的，最少最少也是需要占用 1/2 region。假如说，大对象能够回收，我顺带把它回收掉，我是不是就能腾出来一块儿非常可观的空间出来？

 

但是有人会问了，大对象回收起来不麻烦吗？其实不麻烦，大家知道，大对象创建的时候，是单独存储在一个分区（多个分区）的对吧？单独存储，那么对它是否存活应该怎么判断？其实很简单，我们对每一个region都维护了一个RSet，并且RSet里面存储的，是不是《谁引用了我》的信息？那我们在这个阶段看看大对象所在的region的RSet，是不是就能看到到底有没有其他对象在引用这个大对象？注意大对象所在分区的Region的RSet，不会有很多内容，顶多是两个对象被引用的关系对不对？

 

所以说，基本上我们只需要判断一下RSet里面有没有东西，其实就OK了。而且，如果说大对象横跨很多个分区，我们直接判断大对象所在的第一个分区就知道有没有引用了。这样性价比就会更高了。所以说要在这一步尝试一下对大对象做做回收。

 

从这里其实也能看出，G1的设计者，对性能和空间使用的压榨是非常尽力的。

 

2、尝试扩展内存

大家还记不记得，我们前面在讲新生代内存的时候，讲到过，可能会对堆内存进行扩展。其实这个地方就是那个扩展的时机之一。

 

在GC之后，因为我们有一个GC花费的时间，并且有一个在GC之前，系统的运行总时间。那么此时就需要看看，到底这个GC时间的长度和系统运行时间的长度，是不是一个比较合理的比例，如果不合理，那肯定要考虑扩展一下内存，如果合理，那就没必要扩展。

 

对应的参数：GCTimeRatio和G1ExpandByPercentOfAvailable20%这两个参数。其中GCTimeRatio是指程序运行时间 ：GC时间的比例，如果超过了10%，就说明需要扩展一下。为什么说，超过了10%就需要扩展一下。Gc的时间超过了10%，要么说明gc频繁，要么说明gc的时长太长。如果说，新生代空间足够大，加上G1会自己动态调整新生代分区的数量。

就是gc太频繁。Gc过于频繁，肯定会导致大量的对象实际上是存活的，其实变相拖慢新生代的gc.

 

新生代gc，真正耗时的，不是清理的大量的垃圾，而是标记的过程。存活对象越多，就会有越长的标记过程。

 

如果没有超过就暂时不需要扩展，扩展的内存大小和G1ExpandByPercentOfAvailable有关。

 

3、调整新生代分区的数目及refinement Zone的阈值

这个点是我们的一个重点。

因为，对于G1来说，控制停顿时间是非常非常重要的。那么如果要控制好停顿时间，只能在系统运行时间和GC过程中各个步骤的耗时上面做一个综合的考量，靠量之后，还需要做一下动态调整，才能保证停顿时间是可以被满足的。

那么首当其冲的就是我们在GC之后，要根据预测模型判断一下，我到底现在的gc耗时，gc能力能不能在下一次GC的时候，让我做到在预期停顿时间以内啊？如果不能的话，我得把新生代分区搞少一点，不然肯定不得行啊。

如果说，远远没有达到停顿预测时间的阈值。我就可以增大一些新生代的内存。

 

所以说，这一步，就会根据GC的执行时间和目标停顿时间，预测一下，我**下一次最多能够接受回收多少分区**？然后和当前新生代的总分区数做一个对比，如果差不多，我就不调了。如果发现我预测出来，下一次能回收1000个分区，我现在才有600个，那肯定要多搞几个分区加到新生代里面。不然放着多浪费，对不对？

 

另外还有一个点，我们之前说的DCQS，和refine线程，我们知道DCQ DCQS这块儿的处理，如果DCQ比较多，是需要启动多个refine线程来去处理的。并且，强调一点，在GC开始的时候，这些refine线程就会暂停，由GC线程接管refine线程的工作，处理后续的DCQ，那么假如GC处理DCQ的时间过多，代表了什么？

 

是不是代表了，refine线程的数量，或者说DQCS的四个区域设置的不合理？因为如果设置的合理的话，refine线程理论上，在对应的区域中，就可以满足DCQ的消息处理了。在GC这块儿顶多做一做少部分的收尾工作就OK了。现在到了我GC线程这里，还是需要大量的时间去搞，那说明要么这几个DCQS的阈值设置的过大了，要么就是refine线程太少了。

Refine线程理论上是不能在过程中动态调整上限的，那么我只能调整一下DCQS 的白绿黄红几个阈值的大小，去匹配refine线程的处理能力。

比如把DCQS的各个阈值给降下来，然后把总长度也降下来，让系统在运行过程中，系统线程帮忙处理处理DCQ，这样子就会让GC线程的压力小一点。

所以说，如果GC处理DCQ的时间过长，会导致DCQS的长度和几个阈值的动态减小。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/25186700_1641211405.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

 

4、尝试启动并发标记

这个过程也是一个尝试的过程。因为我们知道，新生代的回收是一直在进行的，老年代的对象也是一直在累积的，如果累计到一定程度，此时肯定是需要回收一部分老年代的垃圾的。不然内存的使用率就太高了。所以说，在老年代达到45%的内存使用率的时候，一次ygc结束之后就会开启一个并发标记过程。

大家注意，我们前面有一张ygc mixedgc full gc的关系图，这个地方的判断，就是判断是否要进入mixed gc + young gc的这个过程。

如果开启了标记，就意味着接下来要进入mixed gc了