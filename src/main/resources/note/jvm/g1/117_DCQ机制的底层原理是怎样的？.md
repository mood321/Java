回顾：

1、如果引用关系发生了改变，RSet是否需要更新，应该怎么更新？

2、每次引用关系变更都更新

3、Rset的更新操作应该什么时候做？

4、G1的脏数据队列异步消费，更新RSet

5、思考：异步消费是谁在消费？应该有多少个线程才不会损耗CPU大量的资源？如果到了最后垃圾回收的时候还是没有消费完毕，应该怎么办？

 

本节内容：

1、DCQ有多少个？

2、谁来消费DCQ？

3、消费线程的数量是怎么确定的？

4、说了这么多DCQ，DCQ到底是怎么写进去的？

 

1、异步消费是谁在消费？

在G1中，有一个refine线程的概念，refine线程，其主要的工作内容，就是去消费DCQ里面的消息，然后去更新RSet。

当然还有其他的作用，比如说，我们之前说过的新生代的动态扩展问题，它就会做新生代分区的抽样工作，在满足响应时间的这个前提下，根据抽样的数据（GC时间，垃圾数量，新生代region个数等），去调整新生代的region个数。

但是它的主要工作其实就是管理RSet，也就是去消费DCQ然后去更新RSet里面的引用关系。

Refine线程，它是有一个线程会一直做这个抽样的操作。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/34003300_1641210194.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

如果说Refine忙不过来了怎么办？DCQ中变更消息的数量很多，导致refine线程超负荷工作，还是无法全部消费，应该怎么处理？

 

2、多种类型的线程可能会共同消费DCQ里面的数据

因为平常只会有少量的Refine线程去消费DCQ里面的数据，当系统并发非常高的时候，DCQ里面的变更消息可能会非常非常多，那么refine线程肯定是忙不过来的，这个时候就需要有多个refine线程参与进来来一起处理这个引用变更数据了，甚至还有可能会有其他的线程一起处理。我们一步一步来看

关于refine线程的数量，可以自己去指定。其默认的数量是G1ConcRefinementThreads +1

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/35230100_1641210194.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

如果实在是忙不过来，那么就只能在指定参数的时候多设置几个refine线程了（因为G1一般是大内存，多核机器，所以设置4-5个线程其实也无所谓）。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/79066200_1641210194.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

如果说refine线程已经够多了，这个时候还是忙不过来怎么办？这个时候，其实G1会借助系统的工作线程，也就是说，你创建完对象之后，这个线程很可能还没有去等着接收其他的请求，而是帮忙去消费DCQ去了。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/80796300_1641210194.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

 

3、DCQ的长度是无限的吗？多个线程消费同一个DCQ，岂不是还是有并发问题？

对于这个问题，其实G1也有考虑，大家想啊，如果说一个队列，无限长，无限增加，单独一个DCQ，大家都往里面写，不管是写入，还是消费，其实都可能会遇到并发的瓶颈，毕竟你只有一个DCQ的话，肯定会有并发写，并发消费的问题啊！

所以，其实G1是设计了二级缓存来解决并发冲突的。

简单来说第一层缓存是在线程这一层，也就是说，DCQ其实是属于每一个线程的。也就是说，每一个工作线程都会关联一个DCQ，每个线程在执行了引用更新操作的时候，都会往自己持有的那个DCQ里面写入变更信息。DCQ的长度默认是256，如果写满了，就重新申请一个新的DCQ，并把这个老DCQ提交到第二级缓存，也就是一个DCQ Set里面去，我们叫这个二级缓存为DCQS。

这样的话，其实就解决了并发写的问题。因为每个线程只写自己持有的DCQ就OK了，写满了就提交到DCQS，顶多这个时候会加一个锁。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/80021300_1641210194.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

在线程持有的DCQ满了以后，就提交到DCQS中去。

那么当refine线程实在是忙不过来的时候，是怎么处理的呢？其实也很简单，因为refine线程是直接从DCQS取DCQ去消费的，那么如果说refine线程忙不过来的时候，也就是意味着，DCQS已经不能再放下更多的DCQ了，此时工作线程就会去判断，能不能提交到DCQS啊？不能提交啊，不能提交我就自己处理了。这个时候，工作线程就会自己去处理这个DCQ，更新RSet。

![picture.png](http://wechatapppro-1252524126.cdn.xiaoeknow.com/image/ueditor/80698100_1641210194.png?imageView2/2/q/80%7CimageMogr2/ignore-error/1)

4、我们说了一堆DCQ 、DCQS的事儿，那DCQ里面的数据到底是怎么写进去的呢？

这个问题其实很简单，G1给每个变更操作前都加了一层写屏障，注意，这个写屏障和内存屏障可不一样，这个写屏障是类似于增强代码，或者AOP切面的一个概念。

什么意思呢，其实就是说，我们在修改了内存值的时候（实际上就是往内存里面写东西的时候），额外执行一些操作。比如，判断是否需要写到DCQ啊（新生代与新生代的引用就不需要写），比如判断本次的写入操作是否改变了引用啊，比如发送一条消息到DCQ啊等等。

这么一层加强代码，就是所谓的写屏障。

那么这层加强代码到底由什么用呢？作用其实很大，因为不是任何写内存的操作都会改变引用关系什么的，如果没有改变引用关系，我们是不是就不需要写这么一条数据到DCQ里面了？

这样子其实可以大大减少后续refine线程处理DCQ的压力，同时也可以避免DCQ快速填满，导致refine线程被快速启动。

所以这个写屏障的作用主要有两点：第一过滤掉不需要写的引用变更操作，比如我新生代到新生代的引用，比如同一个分区内的引用等。第二就是，把正常的变更数据，写入一条到DCQ里面。

 

思考：DCQS到底啥时候算满？多少个refine线程去处理DCQS才合适？如果说，实在是到了GC的时候，还是没有处理完成，应该怎么办？