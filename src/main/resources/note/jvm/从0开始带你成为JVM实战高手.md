>和深入java 同样是jvm知识,但更多实战

### 01 
### 02 
### 03 
### 04
### 05 
### 06 
### 07
### 08
### 09 
### 10 
### 11 
### 12 
### 13
### 14 
### 15
### 16 
### 017、大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算法？
<li> 躲过15次GC之后进入老年代
<li> 动态对象年龄判断
<li> 大对象直接进入老年代
<li> Minor GC后的对象太多，无法放入Survivor区怎么办？
<li> 老年代空间分配担保规则
<li> 老年代垃圾回收算法

#### 四种进入老年的方法
  + 1、躲过15次GC之后进入老年代
   > 这个具体是多少岁进入老年代，可以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁
  + 2、动态对象年龄判断
    >这里跟这个对象年龄有另外一个规则可以让对象进入老年代，不用等待15次GC过后才可以。
    
    >他的大致规则就是，假如说当前放对象的Survivor区域里，一批对象的总大小大于了这块Survivor区域的内存大小的50%，
    那么此时大于等于这批对象年龄的对象，就可以直接进入老年代了。
  + 3、大对象直接进入老年代
    >有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把他的值设置为字节数，比如“1048576”字节，就是1MB。
    
    >他的意思就是，如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年
    代里去。压根儿不会经过新生代
  + 4、老年代空间分配担保规则
    >如果在Minor GC之后发现剩余的存活对象太多了，没办法放入另外一块Survivor区,这时候放到老年代
    
    + 担保流程
    >  在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小
        
     
   1. 第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor 区域即可。
   2.   第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小 的，此时就直接进入老年代即可。
   3.   第三种可能，很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内 存的大小。此时老年代都放不下这些存活对象了，
   + 3.1 检查“-XX:-HandlePromotionFailure”的参数是否设置了 , 老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。大于放入老年代
   + 3.2 判断失败或者没设置,这个时候就会触 发一次“Full GC”。
   4.   Full GC就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。因为这个时候必须得把老年代里的没人引用的对象给回收掉，然后才可能让Minor GC过后剩余的存活对象进入老年代 里面。
  
  如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的“OOM”内存溢出了
  
#### <b>老年代垃圾回收算法</b>
>对老年代触发垃圾回收的时机，一般就是两个：

+ 要不然是在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；
+ 要不然是在Minor GC之后，发现剩余对象太多放入老年代都放不下了。

>一般老年代采取的是标记整理算法

注意一点，这个老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况

### 018、大厂面试题：JVM中都有哪些常见的垃圾回收器，各自的特点是什么？

#### 小case 分析  看原来的
#### 老年代垃圾回收器
>常用的ParNew、CMS和G1三种垃圾回收器

>Serial和Serial Old垃圾回收器：分别用来回收新生代和老年代的垃圾对象

>工作原理就是单线程运行，垃圾回收的时候会停止我们自己写的系统的其他工作线程，让我们系统直接卡死不动，然后让他们垃圾回收，这个现在一般写后台Java系统几乎不用。

>ParNew和CMS垃圾回收器：ParNew现在一般都是用在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器，他们都是多线程并发的机制，性能更好，现在一般是线上生产系统的标配组合。下周会着重分析这两个垃圾回收器。

>G1垃圾回收器：统一收集新生代 和老年代，采用了更加优秀的算法和设计机制，

### 019、“Stop the World”问题分析：JVM最让人无奈的痛点！

> 为了维护回收时的引用关系,他会直接停止我们写的Java系统的所有工作线程，让我们写的代码不再运行！

>一旦垃圾回收完毕，就可以继续恢复我们写的Java系统的工作线程的运行了，然后我们的那些代码就可以继续运行，继续在Eden中创建新的对象

#### 不同的垃圾回收器的不同的影响
>不断的在优化垃圾回收器的机制和算法，就是尽可能的降低垃圾回收的过程对我们的系统运行的影响。

###  20 画出各种垃圾回收算法和垃圾回收器的原理图
 [![UixNAx.jpg](https://s1.ax1x.com/2020/07/06/UixNAx.jpg)](https://imgchr.com/i/UixNAx)
 
###  022、一步一图：深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！

#### 最常用的新生代垃圾回收器：ParNew
>新生代的ParNew垃圾回收器主打的就是多线程垃圾回收机制，另外一种Serial垃圾回收器主打的是单线程垃圾回收，他们俩都是回收新生代的，唯一的区别就是单线程和多线程的区别，但是垃圾回收算法是完全一样的。复制算法

>“-XX:+UseParNewGC” 表示使用ParNew 他默认给自己设置的垃圾回收线程的数量就是跟CPU的核数是一样的,也是可以的，也可以使用“-XX:ParallelGCThreads”设置线程的数量 不推荐

### 023、一步一图：那JVM老年代垃圾回收器CMS工作时，内部又干了些啥？

#### CMS垃圾回收的基本原理
>标记清理算法   标记方法去标记出哪些对象是垃圾对象，然后就把这些垃圾对象清理掉

>先通过追踪GC Roots的方法，看看各个对象是否被GC Roots给引用了，如果是的话，那就是存活对象，否则就是垃圾对象。先将垃圾对象都标记出来，然后一次性把垃圾对象都回收掉

> 缺点:内存碎片

基础回收算法是先停止一切工作线程，然后慢慢的去执行“标记-清理”算法，会导致系统卡死时间过长

所以CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的。

#### CMS在执行一次垃圾回收的过程一共分为4个阶段：
``` 
初始标记
并发标记
重新标记
并发清理   
````

- 第一个阶段，初始标记，虽然说要造成“Stop the World”暂停一切工作线程，但是其实影响不大，因为他的速度很快，仅仅标记GC Roots直接引用的那些对象罢了。

- 第二个阶段，是并发标记，这个阶段会让系统线程可以随意创建各种新对象，继续运行

    对老年代所有对象进行GC Roots追踪，其实是最耗时的
    
    他需要追踪所有对象是否从根源上被GC Roots引用了，但是这个最耗时的阶段，是跟系统程序并发运行的，所以其实这个阶段不会对系统运行造成影响的。

- 第三个阶段，重新标记阶段

    因为第二阶段里，你一边标记存活对象和垃圾对象，一边系统在不停运行创建新对象，让老对象变成垃圾 ,所以第二阶段结束之后，绝对会有很多存活对象和垃圾对象，是之前第二阶段没标记出来的
    
    这个重新标记的阶段，是速度很快的，他其实就是对在第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快
    
- 第四阶段：并发清理 

    这个阶段就是让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可。
    
    这个阶段其实是很耗时的，因为需要进行对象的清理，但是他也是跟系统程序并发运行的，所以其实也不影响系统程序的执行
    

 
