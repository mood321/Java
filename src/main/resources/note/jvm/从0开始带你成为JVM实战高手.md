>和深入java 同样是jvm知识,但更多实战

### 01 
### 02 
### 03 
### 04
### 05 
### 06 
### 07
### 08
### 09 
### 10 
### 11 
### 12 
### 13
### 14 
### 15
### 16 
### 017、大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算法？
<li> 躲过15次GC之后进入老年代
<li> 动态对象年龄判断
<li> 大对象直接进入老年代
<li> Minor GC后的对象太多，无法放入Survivor区怎么办？
<li> 老年代空间分配担保规则
<li> 老年代垃圾回收算法

#### 四种进入老年的方法
  + 1、躲过15次GC之后进入老年代
   > 这个具体是多少岁进入老年代，可以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁
  + 2、动态对象年龄判断
    >这里跟这个对象年龄有另外一个规则可以让对象进入老年代，不用等待15次GC过后才可以。
    
    >他的大致规则就是，假如说当前放对象的Survivor区域里，一批对象的总大小大于了这块Survivor区域的内存大小的50%，
    那么此时大于等于这批对象年龄的对象，就可以直接进入老年代了。
  + 3、大对象直接进入老年代
    >有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把他的值设置为字节数，比如“1048576”字节，就是1MB。
    
    >他的意思就是，如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年
    代里去。压根儿不会经过新生代
  + 4、老年代空间分配担保规则
    >如果在Minor GC之后发现剩余的存活对象太多了，没办法放入另外一块Survivor区,这时候放到老年代
    
    + 担保流程
    >  在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小
    
    >“-XX:HandlePromotionFailure”参数在JDK 1.6以后就被废弃了，所以现在一般都不会在生产环境里设置这个参数了。在JDK 1.6以后，只要判断“老年代可用空间”> “新生代对象总和”，或者“老年代可用空间”> “历次Minor GC升入老年代对象的平均大小”，两个条件满足一个，就可以直接进行Minor GC，不需要提前触发Full GC了。
        
     
   1. 第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor 区域即可。
   2.   第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小 的，此时就直接进入老年代即可。
   3.   第三种可能，很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内 存的大小。此时老年代都放不下这些存活对象了，
   + 3.1 检查“-XX:-HandlePromotionFailure”的参数是否设置了 , 老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。大于放入老年代
   + 3.2 判断失败或者没设置,这个时候就会触 发一次“Full GC”。
   4.   Full GC就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。因为这个时候必须得把老年代里的没人引用的对象给回收掉，然后才可能让Minor GC过后剩余的存活对象进入老年代 里面。
  
  如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的“OOM”内存溢出了
  
#### <b>老年代垃圾回收算法</b>
>对老年代触发垃圾回收的时机，一般就是两个：

+ 要不然是在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；
+ 要不然是在Minor GC之后，发现剩余对象太多放入老年代都放不下了。

>一般老年代采取的是标记整理算法

注意一点，这个老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况

### 018、大厂面试题：JVM中都有哪些常见的垃圾回收器，各自的特点是什么？

#### 小case 分析  看原来的
#### 老年代垃圾回收器
>常用的ParNew、CMS和G1三种垃圾回收器

>Serial和Serial Old垃圾回收器：分别用来回收新生代和老年代的垃圾对象

>工作原理就是单线程运行，垃圾回收的时候会停止我们自己写的系统的其他工作线程，让我们系统直接卡死不动，然后让他们垃圾回收，这个现在一般写后台Java系统几乎不用。

>ParNew和CMS垃圾回收器：ParNew现在一般都是用在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器，他们都是多线程并发的机制，性能更好，现在一般是线上生产系统的标配组合。下周会着重分析这两个垃圾回收器。

>G1垃圾回收器：统一收集新生代 和老年代，采用了更加优秀的算法和设计机制，

### 019、“Stop the World”问题分析：JVM最让人无奈的痛点！

> 为了维护回收时的引用关系,他会直接停止我们写的Java系统的所有工作线程，让我们写的代码不再运行！

>一旦垃圾回收完毕，就可以继续恢复我们写的Java系统的工作线程的运行了，然后我们的那些代码就可以继续运行，继续在Eden中创建新的对象

#### 不同的垃圾回收器的不同的影响
>不断的在优化垃圾回收器的机制和算法，就是尽可能的降低垃圾回收的过程对我们的系统运行的影响。

###  20 画出各种垃圾回收算法和垃圾回收器的原理图
 [![UixNAx.jpg](https://s1.ax1x.com/2020/07/06/UixNAx.jpg)](https://imgchr.com/i/UixNAx)
 
###  022、一步一图：深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！

#### 最常用的新生代垃圾回收器：ParNew
>新生代的ParNew垃圾回收器主打的就是多线程垃圾回收机制，另外一种Serial垃圾回收器主打的是单线程垃圾回收，他们俩都是回收新生代的，唯一的区别就是单线程和多线程的区别，但是垃圾回收算法是完全一样的。复制算法

>“-XX:+UseParNewGC” 表示使用ParNew 他默认给自己设置的垃圾回收线程的数量就是跟CPU的核数是一样的,也是可以的，也可以使用“-XX:ParallelGCThreads”设置线程的数量 不推荐

### 023、一步一图：那JVM老年代垃圾回收器CMS工作时，内部又干了些啥？

#### CMS垃圾回收的基本原理
>标记清理算法   标记方法去标记出哪些对象是垃圾对象，然后就把这些垃圾对象清理掉

>先通过追踪GC Roots的方法，看看各个对象是否被GC Roots给引用了，如果是的话，那就是存活对象，否则就是垃圾对象。先将垃圾对象都标记出来，然后一次性把垃圾对象都回收掉

> 缺点:内存碎片

基础回收算法是先停止一切工作线程，然后慢慢的去执行“标记-清理”算法，会导致系统卡死时间过长

所以CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的。

#### CMS在执行一次垃圾回收的过程一共分为4个阶段：
``` 
初始标记
并发标记
重新标记
并发清理   
````

- 第一个阶段，初始标记，虽然说要造成“Stop the World”暂停一切工作线程，但是其实影响不大，因为他的速度很快，仅仅标记GC Roots直接引用的那些对象罢了。

- 第二个阶段，是并发标记，这个阶段会让系统线程可以随意创建各种新对象，继续运行

    对老年代所有对象进行GC Roots追踪，其实是最耗时的
    
    他需要追踪所有对象是否从根源上被GC Roots引用了，但是这个最耗时的阶段，是跟系统程序并发运行的，所以其实这个阶段不会对系统运行造成影响的。

- 第三个阶段，重新标记阶段

    因为第二阶段里，你一边标记存活对象和垃圾对象，一边系统在不停运行创建新对象，让老对象变成垃圾 ,所以第二阶段结束之后，绝对会有很多存活对象和垃圾对象，是之前第二阶段没标记出来的
    
    这个重新标记的阶段，是速度很快的，他其实就是对在第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快
    
- 第四阶段：并发清理 

    这个阶段就是让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可。
    
    这个阶段其实是很耗时的，因为需要进行对象的清理，但是他也是跟系统程序并发运行的，所以其实也不影响系统程序的执行
    
### 024、动手实验：线上部署系统时，如何设置垃圾回收相关参数？
> CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统同时工作，但是大家发现没有，在并发标记和并发清理两个最耗时
  的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分
  
> CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）/ 4。

#### Concurrent Mode Failure问题
>这个阶段系统一直在运行，可能会随着系统运行让一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象是“浮动垃圾

>“-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是
92%。

>也就是说，老年代占用了92%空间了，就自动进行CMS垃圾回收，预留8%的空间给并发回收期间，系统程序把一些新对象放入老年代中。

如发生Concurrent Mode Failure，就是说并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。

此时就会自动用“Serial Old”垃圾回收器替代CMS，就是直接强行把系统程序“Stop the World”，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生

然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程

#### 内存碎片问题
> CMS不是完全就仅仅用“标记-清理”算法的，因为太多的内存碎片实际上会导致更加频繁的Full GC。

>CMS有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了
 他意思是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片
 连续内存空间，避免内存碎片。
 
> 还有一个参数是“-XX:CMSFullGCsBeforeCompaction”，这个意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认
  是0，意思就是每次Full GC之后都会进行一次内存整理。

### 025、案例实战：每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化？
+ 大促高峰期订单系统的内存使用模型估算
    >估算新生成对象大小
+ 内存到底该如何分配
    > 新生成对象是不用进老年代的
+ 新生代垃圾回收优化之一：Survivor空间够不够
 
    Survivor 注意两点
    > 1 Minor GC 对象大于Survivor 直接进入老年代
    
    > 2 Minor GC后,放在Survivor 因为这是一批同龄对象，直接超过了Survivor区空间的50%，此时也可能会导致对象进入老年代。
    
+ 新生代对象躲过多少次垃圾回收后进入老年代
    > “-XX:MaxTenuringThreshold”参数的默认值15次 ,具体看运行情况,可大可小
    
+ 多大的对象直接进入老年代？
    >-XX:PretenureSizeThreshold=1M  指定1M 足够
 
 + 指定垃圾回收器
    > -XX:+UseParNewGC -XX:+UseConcMarkSweepGC  常用ParNew和CMS
    
得到参数 “-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”
  
### 026、案例实战：每日请求上亿的电商系统，老年代的垃圾回收参数又该如何优化呢？

年轻代就是上面的参数
+ 什么时候对象会进入老年代？
    > -XX:MaxTenuringThreshold=5 这个参数会让在一两分钟内连续躲过5次Minor GC的对象迅速进入老年代中。  
    
    > 大对象,之前设为1M  ,应该少
    
    > Minor GC过后可能存活的对象超过200MB放不下Survivor了，或者是一下子占到超过Surviovr的50%，此时会有一些对象进入老年代中。 也在上面参数尽可能避免
    
+ 多久会触发一次Full GC
    
    Full GC的触发条件目前我们学习到的有以下4种
    + （1） 没有打开“ -XX:HandlePromotionFailure”选项，结果老年代可用内存最多也就1G，新生代对象总大小最多可以有1.8G
     
      那么会导致每次Minor GC前一检查，都发现“老年代可用内存” < “新生代总对象大小”，这会导致每次Minor GC前都触发Full GC。
      
      JDK 1.6以后的版本废弃了这个参数 所以1.8不存在
    
    + （2）每次Minor GC之前，都检查一下“老年代可用内存空间” < “历次Minor GC后升入老年代的平均对象大小”
    
    + （3）可能某次Minor GC后要升入老年代的对象有几百MB，但是老年代可用空间不足了
    
    + （4）设置了“-XX:CMSInitiatingOccupancyFaction”参数，比如设定值为92%，那么此时可能前面几个条件都没满足，但是刚好发现这个条件满足了，比如就是老年代空间使用超过92%了，此时就会自行触发Full GC
    
   
+ 老年代GC的时候会发生“Concurrent Mode Failure”吗？
     > 有可能, 但加上-XX:CMSInitiatingOccupancyFaction=92 在cms 清除的时候,按老年代上面的参数,留给它近200M, 全部沾满 几率不大,
     
+ CMS垃圾回收之后进行内存碎片整理的频率应该多高？
    在CMS完成Full GC之后，一般需要执行内存碎片的整理，可以设置多少次Full GC之后执行一次内存碎片整理，但是我们有必要修改这些参数吗？
    
    > 答案不大必要,对象大多在年轻代,full gc 几个小时才发生,性能足够
 
 得到参数  “-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0”
 
    
###  027、第4周作业：看看你们的线上系统是怎么设置的JVM垃圾回收参数？设置的合理吗？
   > 我们线上全是默认   分析有时间做

### 029、大厂面试题：最新的G1垃圾回收器的工作原理，你能聊聊吗？ 
    ````
    1、ParNew + CMS的组合让我们有哪些痛点？
    2、G1垃圾回收器
    3、G1是如何做到对垃圾回收导致的系统停顿可控的？
    4、Region可能属于新生代也可能属于老年代
    ````
#### ParNew + CMS的组合让我们有哪些痛点？
> Stop the World，这个是大家最痛的一个点！
    
#### G1垃圾回收器

 > 他最大的一个特点，就是把Java堆内存拆分为多个大小相等的Region,G1也会有新生代和老年代的概念，但是只不过是逻辑上的概念
 
 > G1最大的一个特点，就是可以让我们设置一个垃圾回收的预期停顿时间
 
 #### G1是如何做到对垃圾回收导致的系统停顿可控的？
> G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量(2048 )小Region，以及追踪每个Region中可以回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象。
 
 #### Region可能属于新生代也可能属于老年代
 >刚开始Region可能谁都不属于，然后接着就分配给了新生代，然后放了很多属于新生代的对象，接着就触发了垃圾回收这个Region

 >下一次同一个Region可能又被分配了老年代了，用来放老年代的长生存周期的对象

 >实际上新生代和老年代各自的内存区域是不停的变动的，由G1自动控制。
 
 ### 030、G1分代回收原理深度图解：为什么回收性能比传统GC更好？
 
 #### 设定G1对应的内存大小
 
 到底有多少个Region呢？每个Region的大小是多大呢？
 >VM启动的时候一旦发现你使用的是G1垃圾回收器，可以使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，此时会自动用堆大小除以2048

 > 因为JVM最多可以有2048个Region，然后Region的大小必须是2的倍数，比如说1MB、2MB、4MB之类的   -XX:G1HeapRegionSize 手动设置
 
 >刚开始的时候，默认新生代对堆内存的占比是5%，也就是占据200MB左右的内存，对应大概是100个Region，这个是可以通过“-XX:G1NewSizePercent”来设置新生代初始占比的，其实维持这个默认值即可。
 
 >因为在系统运行中，JVM其实会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”。
 
 >而且一旦Region进行了垃圾回收，此时新生代的Region数量还会减少
 
#### 新生代还有Eden和Survivor的概念吗？

>G1中虽然把内存划分为了很多的 Region，但是其实还是有新生代、老年代的区分 也有Eden和Survivor的划分的

>比如 -XX:SurvivorRatio=8”，新生代之前说刚开始初始的时候，有100个Region，那么可能80个Region就是Eden，两个Survivor各自占10个Region

#### G1的新生代垃圾回收
>既然G1的新生代也有Eden和Survivor的区分，那么触发垃圾回收的机制都是类似的

>随着不停的在新生代的Eden对应的Region中放对象，JVM就会不停的给新生代加入更多的Region，直到新生代占据堆大小的最大比例60%。

>一旦新生代达到了设定的占据堆内存的最大大小60%，比如都有1200个Region了，里面的Eden可能占据了1000个Region，每个Survivor是100个Region，而且Eden区还占满了对象

> 会触发新生代的GC，G1就会用之前说过的复制算法来进行垃圾回收，进入一个“Stop the World”状态 然后把Eden对应的Region中的存活对象放入S1对应的Region中，接着回收掉Eden对应的Region中的垃圾对象

>个过程跟之前是有区别的，因为G1是可以设定目标GC停顿时间的，也就是G1执行GC的时候最多可以让系统停顿多长时间，可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms

#### 对象什么时候进入老年代？

还是这么几个条件：

+ （1）对象在新生代躲过了很多次的垃圾回收，达到了一定的年龄了，“-XX:MaxTenuringThreshold”参数可以设置这个年龄，他就会进入老年代

+ （2）动态年龄判定规则，如果一旦发现某次新生代GC过后，存活对象超过了Survivor的50%
 
#### 大对象Region
> G1的大对象 有点不一样,G1提供了专门的Region来存放大对象，而不是让大对象进入老年代的Region中。
               
> 在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2MB，只要一个大对象超过了1MB，就会被放入大对象专门的Region中
               
> 而且一个大对象如果太大，可能会横跨多个Region来存放

 大对象的分配和回收
>比如新生代现在占据了1200个Region，但是一次垃圾回收之后，就让里面1000个Region都空了，此时那1000个Region就可以不属于新生代了，里面很多Region可以用来存放大对象

>新生代、老年代在回收的时候，会顺带带着大对象Region一起回收，所以这就是在G1内存模型下对大对象的分配和回收的策略。

### 031、动手实验：线上系统部署如果采用G1垃圾回收器，应该如何设置参数？

#### 什么时候触发新生代+老年代的混合垃圾回收？
>G1有一个参数，是”-XX:InitiatingHeapOccupancyPercent"，它的默认值是45%。意思是说，如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。

>G1整体是基于复制算法进行Region垃圾回收，不会出现内存碎片问题，不需要像CMS那样标记-清理之后再进行内存碎片的整理。 

>g1垃圾回收器新生代初始占比默认为5%，新生代最大占比默认为60%。

>如果堆内存为4G，此时除以2048，得出每个region的大小为2mb，刚开始新生代就占5%的region，可以认为新生代就是只有100个region，有200mb的内存空间。

>g1有一个参数"-XX:MaxGCPauseMills"，它的默认值是200ms

>一旦老年代频繁达到占用堆内存45%的阈值，那么就会频繁触发mixed gc。

#### G1垃圾回收的过程

+ 首先会触发一个“初始标记”的操作，这个过程是需要进入“Stop the World”的，仅仅只是标记一下GC Roots直接能引用的对象， 这个过程速度是很快的
  
+ 接着会进入“并发标记”的阶段，这个阶段会允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，

+ 然后在并发标记阶段，就会进行GC Roots追踪，会从GC Root对象直接关联的对象开始往下追踪

    这个并发标记阶段还是很耗时的，因为要追踪全部的存活对象。 但是是并行,影响不大,会对并发标记阶段对对象做出的一些修改记录起来，比如说哪个对象被新建了，哪个对象失去了引用。
+  然后是下一个阶段，最终标记阶段，这个阶段会进入“Stop the World”，系统程序是禁止运行的，但是会根据并发标记 阶段记录的那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象

+ 最后一个阶段，就是“混合回收“阶段，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。
  
  接着会停止系统程序，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我 们指定的范围内。
  
#### G1垃圾回收器的一些参数
>“-XX:G1MixedGCCountTarget”参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次

 意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反 复8次。
 
> “-XX:G1HeapWastePercent”，默认值是5%

他的意思就是说，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉

这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会 立即停止混合回收，意味着本次混合回收就结束了

>“-XX:G1MixedGCLiveThresholdPercent”，他的默认值是85%，

意思就是确定要回收的Region的时候，必须是存 活对象低于85%的Region才可以进行回收 ,否则要是一个Region的存活对象多余85%，你还回收他干什么？这个时候要把85%的对象都拷贝到别的Region


#### 回收失败时的Full GC
如果在进行Mixed回收的时候，无论是年轻代还是老年代都基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region里去

此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发 一次失败。

一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，这个过程是极慢极慢的。




