>和深入java 同样是jvm知识,但更多实战

>1-17 笔记是补的 可能没写全

### 01   开篇词：JVM 优化实战，广大 Java 工程师心中永远的痛！

### 02    一探究竟：我们写的Java代码到底是如何运行起来的？

javac  讲代码编译成字节码class 文件

类加载器加载
 
加载->验证->准备->解析->初始化->使用->卸载
  
  1. 加载:将编译好的".class"字节码文件加载到JVM中
  2. 验证:根据JVM规范，校验加载进来的".class"字节码文件
  3. 准备:给类和类变量分配一定的内存空间，且给类变量设置默认的初始值(0或者nul) 
  4. 解析:把符号引用替换为直接引用的过程
  5. 初始化:根据类初始化代码给类变量赋值 
### 03   面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？
#### JVM在什么情况下会加载一个类？
你的代码中用到这个类的时候。

#### 从实用角度出发，来看看验证、准备和初始化的过程
+ 验证 来校验你加载进来的“.class”文件中的内容，是否符合指定的规范。
+ 准备 就是给变量,类分配一定的内存空间
+ 解析阶段 实际上是把符号引用替换为直接引用的过程，其实这个部分的内容很复杂，涉及到JVM的底层

#### 核心阶段：初始化
在这个阶段，就会执行类的初始化代码，比如变量的赋值

另外一个类的static静态代码块，也会在这个阶段来执行。

此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类

#### 类加载器和双亲委派机制
+ （1）启动类加载器

    Bootstrap ClassLoader，他主要是负责加载我们在机器上安装的Java目录下的核心类的,的Java安装目录下，就有一个“lib”目录

+ （2）扩展类加载器

    Extension ClassLoader，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录
 
 + （3）应用程序类加载器
 
    Application ClassLoader，这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类,其实你大致就理解为去加载你写好的Java代码吧
    
 + （4）自定义类加载器
 
    除了上面那几种之外，还可以自定义类加载器，去根据你自己的需求加载你的类。
    
 + （5）双亲委派机制
 
    JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器
    
    假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器
    
    这就是所谓的双亲委派模型：先找父亲去加载，不行的话再由儿子来加载。
    
### 04    大厂面试题：JVM中有哪些内存区域，分别都是用来干嘛的？
#### 存放类的方法区
这个方法区是在JDK 1.8以前的版本里，代表JVM中的一块区域。主要是放从“.class”文件里加载进来的类，还会有一些类似常量池的东西放在这个区域里

在JDK 1.8以后，这块区域的名字改了，叫做“Metaspace”，可以认为是“元数据空间”这样的意思。当然这里主要还是存放我们自己写的各种类相关的信息。

1.8后常量池 移到了堆里面

#### 执行代码指令用的程序计数器
我们写好的Java代码会被翻译成字节码，对应各种字节码指令

现在Java代码通过JVM跑起来的第一件事情就明确了， 首先Java代码被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。

所以当JVM加载类信息到内存之后，实际就会使用自己的字节码执行引擎，去执行我们写的代码编译出来的代码指令

在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”

这个程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令。

#### Java虚拟机栈
JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是Java虚拟机栈

每个线程都有自己的Java虚拟机栈

如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧

栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西

#### Java堆内存

Java堆内存，这里就是存放我们在代码中创建的各种对象的地方

#### 核心内存区域的全流程串讲
<img src="https://s1.ax1x.com/2020/07/16/UrJY5j.jpg" alt="UrJY5j.jpg" border="0" />

首先，你的JVM进程会启动，就会先加载你的Kafka类到内存里。然后有一个main线程，开始执行你的Kafka中的main()方法。
main线程是关联了一个程序计数器的，那么他执行到哪一行指令，就会记录在这里

其次，就是main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里，压入一个main()方法的栈帧

然后会创建一个的对象实例分配在Java堆内存里，并且在main()方法的栈帧里的局部变量表引入一个变量，让他引用ReplicaManager对象在Java堆内存中的地址。

接着，main线程开始执行ReplicaManager对象中的方法，会依次把自己执行到的方法对应的栈帧压入自己的Java虚拟机栈

执行完方法之后再把方法对应的栈帧从Java虚拟机栈里出栈

#### 其他区域
在JDK很多底层API里，比如IO相关的，NIO相关的，网络Socket相关的

如果大家去看他内部的源码，会发现很多地方都不是Java代码了，而是走的native方法去调用本地操作系统里面的一些方法，可能调用的都是c语言写的方法，或者一些底层类库

比如下面这样的：public native int hashCode();

在调用这种native方法的时候，就会有线程对应的本地方法栈，这个里面也是跟Java虚拟机栈类似的，也是存放各种native方法的局部变量表之类的信息。

还有一个区域，是不属于JVM的，通过NIO中的allocateDirect这种API，可以在Java堆外分配内存空间。然后，通过Java虚拟机里的DirectByteBuffer来引用和操作堆外内存空间。

### 05 JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？
#### 对象的分配与引用
对象都是放在堆

方法执行都是 虚拟机栈里面的引用堆里面的对象

#### 一个方法执行完毕之后会怎么样？
方法执行完毕,栈帧会弹出虚拟机栈 ,这是没有任何一个变量指向Java堆内存里的 原来方法引用实例对象了。

#### 我们创建的Java对象其实都是占用内存资源的

我们在Java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。

#### 不再需要的那些对象应该怎么处理？
JVM的垃圾回收机制

JVM本身是有垃圾回收机制的，他是一个后台自动运行的线程

你只要启动一个JVM进程，他就会自带这么一个垃圾回收的后台线程。

这个线程会在后台不断检查JVM堆内存中的各个实例对象


### 06   第1周作业：不借助任何资料，画出JVM整体运行原理图！
> 看下上面那个图

### 07   第1周答疑：本周问题统一答疑
> 


### 08  聊聊JVM分代模型：年轻代、老年代、永久代
大部分对象都是存活周期极短的

少数对象是长期存活的

#### JVM分代模型：年轻代和老年代
其实根据你写代码方式的不同，采用不同的方式来创建和使用对象，其实对象的生存周期是不同的。

所以JVM将Java堆内存划分为了两个区域，一个是年轻代，一个是老年代。

年轻代，顾名思义，就是把第一种代码示例中的那种，创建和使用完之后立马就要回收的对象放在里面

然后老年代呢，就是把第二种代码示例中的那种，创建之后需要一直长期存在的对象放在里面

#### 为什么要分成年轻代和老年代？
这跟垃圾回收有关，对于年轻代里的对象，他们的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法

对于老年代里的对象，他们的特点是需要长期存在，所以需要另外一种垃圾回收算法，所以需要分成两个区域来放不同的对象。

#### 什么是永久代？

其实就是所谓的永久代，你可以认为永久代就是放一些类信息的。

### 009、大厂面试题：你的对象在JVM内存中如何分配？如何流转的？
大部分正常对象都优先在新生代分配内存( 大对象不会)

#### 到底什么情况下会触发新生代的垃圾回收？
新生代内存空间的垃圾回收，也称之为“Minor GC”，有的时候我们也叫“Young GC”

分配新的对象的时候，发现新生代内存空间不足，就会触发一次垃圾回收，然后就把所有垃圾对象给干掉，腾出大量的内存空间

#### 长期存活的对象会躲过多次垃圾回收
(默认)如果一个实例对象在新生代中，成功的在15次垃圾回收之后，还是没被回收掉，就说明他已经15岁了。

对象的年龄，每垃圾回收一次，如果一个对象没被回收掉，他的年龄就会增加1。

大于设定年龄 他会被转移到Java堆内存的老年代中去，顾名思义，老年代就是放这些年龄很大的对象。

#### 老年代会垃圾回收吗？
答案是肯定的，因为老年代里的对象也有可能随着代码的运行，不再被任何人引用了，就需要被垃圾回收。


### 010、动手实验：亲自感受一下线上系统部署时如何设置JVM内存大小？

在JVM内存分配中，有几个参数是比较核心的，如下所示。
````
-Xms：Java堆内存的大小
-Xmx：Java堆内存的最大大小
-Xmn：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了
-XX:PermSize：永久代大小
-XX:MaxPermSize：永久代最大大小
-Xss：每个线程的栈内存大小
````

### 011、案例实战：每日百万交易的支付系统，如何设置JVM堆内存大小？
每秒钟每台机器需要处理多少笔订单，每笔订单要耗时多久处理，每秒钟会对JVM占据多大内存空间，根据这个横向扩展预估整个系统每秒需要占据多大内存空间。

+ 假设每天高峰期大概是几个小时，用100万平均分配到几个小时里，那么大概是每秒100笔订单左右，咱们就以每秒100笔订单

+ 3台机器 应该是每台机器一秒钟接收到30笔支付订单的请求，然后在JVM的新生代里创建了30个支付订单的对象

+ 一般来说，比如支付订单这种核心类，你就按20个实例变量来计算，然后一般大概一个对象也就在几百字节的样子
  
  我们算他大一点好了，就算一个支付订单对象占据500字节的内存空间，不到1kb。
  
+ 那么30个支付订单，大概占据的内存空间是30 * 500字节 = 15000字节，大概其实也就15kb而已


每秒30个支付请求，创建30个支付订单对象，也就占据kb级别的内存空间而已

然后接着1秒过后，这30个对象就没有人引用了，就成了新生代里的垃圾了。

下一秒请求过来，我们的系统持续的创建支付订单对象，不停在新生代里放入30个支付订单，然后新生代里的对象会持续的累积和增加。

直到有一刻，发现可能新生代里都有几十万个对象了，此时占据了几百MB的空间了，可能新生代空间就快满了。

然后就会触发Minor GC，就把新生代里的垃圾对象都给回收掉了，腾出内存空间，然后继续来在内存里分配新的对象。

### 012、案例实战：每日百万交易的支付系统，JVM栈内存与永久代大小又该如何设置？
> 上面的例子

#### 大促期间，瞬时访问量增加十倍
#### 少数请求需要几十秒处理，导致老年代内存占用变大
设你每秒1000笔交易，那么每秒钟系统对内存的占用增加到10MB以上

很快新生代继续被填满，再次触发Minor GC，然后少数几十MB的对象还在，此时多次之后后，就会被转移到老年代去

一旦老年代的垃圾对象越来越多，迟早会满，然后就会触发老年代的垃圾回收，而且这个老年代被占满的频率还很快，可能就会频繁触发老年代的垃圾回收。


### 013、第2周作业：看看你们的线上系统是如何设置JVM内存大小的？
> 都是默认

### 014、第2周答疑：本周问题答疑，上周作业点评
> 
### 015、大厂面试题：什么情况下JVM内存中的一个对象会被垃圾回收？
####  什么时候会触发垃圾回收？
新生代 分配时,内存不够了

#### 被哪些变量引用的对象是不能回收的？
JVM中使用了一种可达性分析算法来判定哪些对象是可以被回收的，哪些对象是不可以被回收的。

Java 中可作为 “GC Root” 的对象：
+ 栈中（本地变量表中的reference）
    + 虚拟机栈中，栈帧中的本地变量表引用的对象；
    + 本地方法栈中，JNI 引用的对象（native方法）；
+ 方法区中
    + 类的静态属性引用的对象；
    + 常量引用的对象；
    
#### Java中对象不同的引用类型
强引用、软引用、弱引用和虚引用
+ 强引用： 像 Object obj = new Object() 这种，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
+ 软引用： 用来引用还存在但非必须的对象。对于软引用对象，在 OOM 前，虚拟机会把这些对象列入回收范围中进行第二次回收，如果这次回收后，内存还是不够用，就 OOM。实现类：SoftReference。
+ 弱引用： 被弱引用引用的对象只能生存到下一次垃圾收集前，一旦发生垃圾收集，被弱引用所引用的对象就会被清掉。实现类：WeakReference。
+ 虚引用： 幽灵引用，对对象没有半毛钱影响，甚至不能用来取得一个对象的实例。它唯一的用途就是：当被一个虚引用引用的对象被回收时，系统会收到这个对象被回收了的通知。实现类：PhantomReference。

#### finalize()方法的作用
回收的环节了，假设没有GC Roots引用的对象，是一定立马被回收吗？

假如这个对象重写了Object类中的finialize()方法

此时会先尝试调用一下他的finalize()方法，看是否把自己这个实例对象给了某个GC Roots变量，比如说代码中的某个静态变量。

如果重新让某个GC Roots变量引用了自己，那么就不用被垃圾回收了

### 016、大厂面试题：JVM中有哪些垃圾回收算法，每个算法各自的优劣？

#### 基础：标记 - 清除算法
+ 算法描述：
    +先标记出所有需要回收的对象（图中深色区域）；
    + 标记完后，统一回收所有被标记对象（留下狗啃似的可用内存区域……）。
+ 不足：
    + 效率问题：标记和清理两个过程的效率都不高。
    + 空间碎片问题：标记清除后会产生大量不连续的内存碎片，导致以后为较大的对象分配内存时找不到足够的连续内存，会提前触发另一次 GC。

#### 解决效率问题：复制算法
+ 算法描述：
    + 将可用内存分为大小相等的两块，每次只使用其中一块；
    + 当一块内存用完时，将这块内存上还存活的对象复制到另一块内存上去，将这一块内存全部清理掉。
+ 不足： 
    + 可用内存缩小为原来的一半，适合GC过后只有少量对象存活的新生代。

+ 节省内存的方法：
    + 新生代中的对象 98% 都是朝生夕死的，所以不需要按照 1:1 的比例对内存进行划分；
    + 把内存划分为：
        + 1 块比较大的 Eden 区；
        + 2 块较小的 Survivor 区；
    + 每次使用 Eden 区和 1 块 Survivor 区；
    + 回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空；
    + JVM 参数设置：-XX:SurvivorRatio=8 表示 Eden 区大小 / 1 块 Survivor 区大小 = 8。

#### 解决空间碎片问题：标记 - 整理算法
+ 算法描述：
    + 标记方法与 “标记 - 清除算法” 一样；
    + 标记完后，将所有存活对象向一端移动，然后直接清理掉边界以外的内存。
+ 不足：
    + 存在效率问题，适合老年代。

+ 进化：分代收集算法
    + 新生代： GC 过后只有少量对象存活 —— 复制算法
    + 老年代： GC 过后对象存活率高 —— 标记 - 整理算法

### 017、大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算法？
<li> 躲过15次GC之后进入老年代
<li> 动态对象年龄判断
<li> 大对象直接进入老年代
<li> Minor GC后的对象太多，无法放入Survivor区怎么办？
<li> 老年代空间分配担保规则
<li> 老年代垃圾回收算法

#### 四种进入老年的方法
  + 1、躲过15次GC之后进入老年代
   > 这个具体是多少岁进入老年代，可以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁
  + 2、动态对象年龄判断
    >这里跟这个对象年龄有另外一个规则可以让对象进入老年代，不用等待15次GC过后才可以。
    
    >他的大致规则就是，假如说当前放对象的Survivor区域里，一批对象的总大小大于了这块Survivor区域的内存大小的50%，
    那么此时大于等于这批对象年龄的对象，就可以直接进入老年代了。
  + 3、大对象直接进入老年代
    >有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把他的值设置为字节数，比如“1048576”字节，就是1MB。
    
    >他的意思就是，如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年
    代里去。压根儿不会经过新生代
  + 4、老年代空间分配担保规则
    >如果在Minor GC之后发现剩余的存活对象太多了，没办法放入另外一块Survivor区,这时候放到老年代
    
    + 担保流程
    >  在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小
    
    >“-XX:HandlePromotionFailure”参数在JDK 1.6以后就被废弃了，所以现在一般都不会在生产环境里设置这个参数了。在JDK 1.6以后，只要判断“老年代可用空间”> “新生代对象总和”，或者“老年代可用空间”> “历次Minor GC升入老年代对象的平均大小”，两个条件满足一个，就可以直接进行Minor GC，不需要提前触发Full GC了。
        
     
   1. 第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor 区域即可。
   2.   第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小 的，此时就直接进入老年代即可。
   3.   第三种可能，很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内 存的大小。此时老年代都放不下这些存活对象了，
   + 3.1 检查“-XX:-HandlePromotionFailure”的参数是否设置了 , 老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。大于放入老年代
   + 3.2 判断失败或者没设置,这个时候就会触 发一次“Full GC”。
   4.   Full GC就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。因为这个时候必须得把老年代里的没人引用的对象给回收掉，然后才可能让Minor GC过后剩余的存活对象进入老年代 里面。
  
  如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的“OOM”内存溢出了
  
#### <b>老年代垃圾回收算法</b>
>对老年代触发垃圾回收的时机，一般就是两个：

+ 要不然是在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；
+ 要不然是在Minor GC之后，发现剩余对象太多放入老年代都放不下了。

>一般老年代采取的是标记整理算法

注意一点，这个老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。如果系统频繁出现老年代的Full GC垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况

### 018、大厂面试题：JVM中都有哪些常见的垃圾回收器，各自的特点是什么？

#### 小case 分析  看原来的
#### 老年代垃圾回收器
>常用的ParNew、CMS和G1三种垃圾回收器

>Serial和Serial Old垃圾回收器：分别用来回收新生代和老年代的垃圾对象

>工作原理就是单线程运行，垃圾回收的时候会停止我们自己写的系统的其他工作线程，让我们系统直接卡死不动，然后让他们垃圾回收，这个现在一般写后台Java系统几乎不用。

>ParNew和CMS垃圾回收器：ParNew现在一般都是用在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器，他们都是多线程并发的机制，性能更好，现在一般是线上生产系统的标配组合。下周会着重分析这两个垃圾回收器。

>G1垃圾回收器：统一收集新生代 和老年代，采用了更加优秀的算法和设计机制，

### 019、“Stop the World”问题分析：JVM最让人无奈的痛点！

> 为了维护回收时的引用关系,他会直接停止我们写的Java系统的所有工作线程，让我们写的代码不再运行！

>一旦垃圾回收完毕，就可以继续恢复我们写的Java系统的工作线程的运行了，然后我们的那些代码就可以继续运行，继续在Eden中创建新的对象

#### 不同的垃圾回收器的不同的影响
>不断的在优化垃圾回收器的机制和算法，就是尽可能的降低垃圾回收的过程对我们的系统运行的影响。

###  20 画出各种垃圾回收算法和垃圾回收器的原理图
 [![UixNAx.jpg](https://s1.ax1x.com/2020/07/06/UixNAx.jpg)](https://imgchr.com/i/UixNAx)
 
###  022、一步一图：深入揭秘JVM的年轻代垃圾回收器ParNew是如何工作的！

#### 最常用的新生代垃圾回收器：ParNew
>新生代的ParNew垃圾回收器主打的就是多线程垃圾回收机制，另外一种Serial垃圾回收器主打的是单线程垃圾回收，他们俩都是回收新生代的，唯一的区别就是单线程和多线程的区别，但是垃圾回收算法是完全一样的。复制算法

>“-XX:+UseParNewGC” 表示使用ParNew 他默认给自己设置的垃圾回收线程的数量就是跟CPU的核数是一样的,也是可以的，也可以使用“-XX:ParallelGCThreads”设置线程的数量 不推荐

### 023、一步一图：那JVM老年代垃圾回收器CMS工作时，内部又干了些啥？

#### CMS垃圾回收的基本原理
>标记清理算法   标记方法去标记出哪些对象是垃圾对象，然后就把这些垃圾对象清理掉

>先通过追踪GC Roots的方法，看看各个对象是否被GC Roots给引用了，如果是的话，那就是存活对象，否则就是垃圾对象。先将垃圾对象都标记出来，然后一次性把垃圾对象都回收掉

> 缺点:内存碎片

基础回收算法是先停止一切工作线程，然后慢慢的去执行“标记-清理”算法，会导致系统卡死时间过长

所以CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式来处理的。

#### CMS在执行一次垃圾回收的过程一共分为4个阶段：
``` 
初始标记
并发标记
重新标记
并发清理   
````

- 第一个阶段，初始标记，虽然说要造成“Stop the World”暂停一切工作线程，但是其实影响不大，因为他的速度很快，仅仅标记GC Roots直接引用的那些对象罢了。

- 第二个阶段，是并发标记，这个阶段会让系统线程可以随意创建各种新对象，继续运行

    对老年代所有对象进行GC Roots追踪，其实是最耗时的
    
    他需要追踪所有对象是否从根源上被GC Roots引用了，但是这个最耗时的阶段，是跟系统程序并发运行的，所以其实这个阶段不会对系统运行造成影响的。

- 第三个阶段，重新标记阶段

    因为第二阶段里，你一边标记存活对象和垃圾对象，一边系统在不停运行创建新对象，让老对象变成垃圾 ,所以第二阶段结束之后，绝对会有很多存活对象和垃圾对象，是之前第二阶段没标记出来的
    
    这个重新标记的阶段，是速度很快的，他其实就是对在第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快
    
- 第四阶段：并发清理 

    这个阶段就是让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可。
    
    这个阶段其实是很耗时的，因为需要进行对象的清理，但是他也是跟系统程序并发运行的，所以其实也不影响系统程序的执行
    
### 024、动手实验：线上部署系统时，如何设置垃圾回收相关参数？
> CMS垃圾回收器有一个最大的问题，虽然能在垃圾回收的同时让系统同时工作，但是大家发现没有，在并发标记和并发清理两个最耗时
  的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分
  
> CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）/ 4。

#### Concurrent Mode Failure问题
>这个阶段系统一直在运行，可能会随着系统运行让一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象是“浮动垃圾

>“-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是
92%。

>也就是说，老年代占用了92%空间了，就自动进行CMS垃圾回收，预留8%的空间给并发回收期间，系统程序把一些新对象放入老年代中。

如发生Concurrent Mode Failure，就是说并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。

此时就会自动用“Serial Old”垃圾回收器替代CMS，就是直接强行把系统程序“Stop the World”，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生

然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程

#### 内存碎片问题
> CMS不是完全就仅仅用“标记-清理”算法的，因为太多的内存碎片实际上会导致更加频繁的Full GC。

>CMS有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了
 他意思是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片
 连续内存空间，避免内存碎片。
 
> 还有一个参数是“-XX:CMSFullGCsBeforeCompaction”，这个意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认
  是0，意思就是每次Full GC之后都会进行一次内存整理。

### 025、案例实战：每日上亿请求量的电商系统，年轻代垃圾回收参数如何优化？
+ 大促高峰期订单系统的内存使用模型估算
    >估算新生成对象大小
+ 内存到底该如何分配
    > 新生成对象是不用进老年代的
+ 新生代垃圾回收优化之一：Survivor空间够不够
 
    Survivor 注意两点
    > 1 Minor GC 对象大于Survivor 直接进入老年代
    
    > 2 Minor GC后,放在Survivor 因为这是一批同龄对象，直接超过了Survivor区空间的50%，此时也可能会导致对象进入老年代。
    
+ 新生代对象躲过多少次垃圾回收后进入老年代
    > “-XX:MaxTenuringThreshold”参数的默认值15次 ,具体看运行情况,可大可小
    
+ 多大的对象直接进入老年代？
    >-XX:PretenureSizeThreshold=1M  指定1M 足够
 
 + 指定垃圾回收器
    > -XX:+UseParNewGC -XX:+UseConcMarkSweepGC  常用ParNew和CMS
    
得到参数 “-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”
  
### 026、案例实战：每日请求上亿的电商系统，老年代的垃圾回收参数又该如何优化呢？

年轻代就是上面的参数
+ 什么时候对象会进入老年代？
    > -XX:MaxTenuringThreshold=5 这个参数会让在一两分钟内连续躲过5次Minor GC的对象迅速进入老年代中。  
    
    > 大对象,之前设为1M  ,应该少
    
    > Minor GC过后可能存活的对象超过200MB放不下Survivor了，或者是一下子占到超过Surviovr的50%，此时会有一些对象进入老年代中。 也在上面参数尽可能避免
    
+ 多久会触发一次Full GC
    
    Full GC的触发条件目前我们学习到的有以下4种
    + （1） 没有打开“ -XX:HandlePromotionFailure”选项，结果老年代可用内存最多也就1G，新生代对象总大小最多可以有1.8G
     
      那么会导致每次Minor GC前一检查，都发现“老年代可用内存” < “新生代总对象大小”，这会导致每次Minor GC前都触发Full GC。
      
      JDK 1.6以后的版本废弃了这个参数 所以1.8不存在
    
    + （2）每次Minor GC之前，都检查一下“老年代可用内存空间” < “历次Minor GC后升入老年代的平均对象大小”
    
    + （3）可能某次Minor GC后要升入老年代的对象有几百MB，但是老年代可用空间不足了
    
    + （4）设置了“-XX:CMSInitiatingOccupancyFaction”参数，比如设定值为92%，那么此时可能前面几个条件都没满足，但是刚好发现这个条件满足了，比如就是老年代空间使用超过92%了，此时就会自行触发Full GC
    
   
+ 老年代GC的时候会发生“Concurrent Mode Failure”吗？
     > 有可能, 但加上-XX:CMSInitiatingOccupancyFaction=92 在cms 清除的时候,按老年代上面的参数,留给它近200M, 全部沾满 几率不大,
     
+ CMS垃圾回收之后进行内存碎片整理的频率应该多高？
    在CMS完成Full GC之后，一般需要执行内存碎片的整理，可以设置多少次Full GC之后执行一次内存碎片整理，但是我们有必要修改这些参数吗？
    
    > 答案不大必要,对象大多在年轻代,full gc 几个小时才发生,性能足够
 
 得到参数  “-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0”
 
    
###  027、第4周作业：看看你们的线上系统是怎么设置的JVM垃圾回收参数？设置的合理吗？
   > 我们线上全是默认   分析有时间做

### 029、大厂面试题：最新的G1垃圾回收器的工作原理，你能聊聊吗？ 
    ````
    1、ParNew + CMS的组合让我们有哪些痛点？
    2、G1垃圾回收器
    3、G1是如何做到对垃圾回收导致的系统停顿可控的？
    4、Region可能属于新生代也可能属于老年代
    ````
#### ParNew + CMS的组合让我们有哪些痛点？
> Stop the World，这个是大家最痛的一个点！
    
#### G1垃圾回收器

 > 他最大的一个特点，就是把Java堆内存拆分为多个大小相等的Region,G1也会有新生代和老年代的概念，但是只不过是逻辑上的概念
 
 > G1最大的一个特点，就是可以让我们设置一个垃圾回收的预期停顿时间
 
 #### G1是如何做到对垃圾回收导致的系统停顿可控的？
> G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量(2048 )小Region，以及追踪每个Region中可以回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象。
 
 #### Region可能属于新生代也可能属于老年代
 >刚开始Region可能谁都不属于，然后接着就分配给了新生代，然后放了很多属于新生代的对象，接着就触发了垃圾回收这个Region

 >下一次同一个Region可能又被分配了老年代了，用来放老年代的长生存周期的对象

 >实际上新生代和老年代各自的内存区域是不停的变动的，由G1自动控制。
 
 ### 030、G1分代回收原理深度图解：为什么回收性能比传统GC更好？
 
 #### 设定G1对应的内存大小
 
 到底有多少个Region呢？每个Region的大小是多大呢？
 >VM启动的时候一旦发现你使用的是G1垃圾回收器，可以使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，此时会自动用堆大小除以2048

 > 因为JVM最多可以有2048个Region，然后Region的大小必须是2的倍数，比如说1MB、2MB、4MB之类的   -XX:G1HeapRegionSize 手动设置
 
 >刚开始的时候，默认新生代对堆内存的占比是5%，也就是占据200MB左右的内存，对应大概是100个Region，这个是可以通过“-XX:G1NewSizePercent”来设置新生代初始占比的，其实维持这个默认值即可。
 
 >因为在系统运行中，JVM其实会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”。
 
 >而且一旦Region进行了垃圾回收，此时新生代的Region数量还会减少
 
#### 新生代还有Eden和Survivor的概念吗？

>G1中虽然把内存划分为了很多的 Region，但是其实还是有新生代、老年代的区分 也有Eden和Survivor的划分的

>比如 -XX:SurvivorRatio=8”，新生代之前说刚开始初始的时候，有100个Region，那么可能80个Region就是Eden，两个Survivor各自占10个Region

#### G1的新生代垃圾回收
>既然G1的新生代也有Eden和Survivor的区分，那么触发垃圾回收的机制都是类似的

>随着不停的在新生代的Eden对应的Region中放对象，JVM就会不停的给新生代加入更多的Region，直到新生代占据堆大小的最大比例60%。

>一旦新生代达到了设定的占据堆内存的最大大小60%，比如都有1200个Region了，里面的Eden可能占据了1000个Region，每个Survivor是100个Region，而且Eden区还占满了对象

> 会触发新生代的GC，G1就会用之前说过的复制算法来进行垃圾回收，进入一个“Stop the World”状态 然后把Eden对应的Region中的存活对象放入S1对应的Region中，接着回收掉Eden对应的Region中的垃圾对象

>个过程跟之前是有区别的，因为G1是可以设定目标GC停顿时间的，也就是G1执行GC的时候最多可以让系统停顿多长时间，可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms

#### 对象什么时候进入老年代？

还是这么几个条件：

+ （1）对象在新生代躲过了很多次的垃圾回收，达到了一定的年龄了，“-XX:MaxTenuringThreshold”参数可以设置这个年龄，他就会进入老年代

+ （2）动态年龄判定规则，如果一旦发现某次新生代GC过后，存活对象超过了Survivor的50%
 
#### 大对象Region
> G1的大对象 有点不一样,G1提供了专门的Region来存放大对象，而不是让大对象进入老年代的Region中。
               
> 在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2MB，只要一个大对象超过了1MB，就会被放入大对象专门的Region中
               
> 而且一个大对象如果太大，可能会横跨多个Region来存放

 大对象的分配和回收
>比如新生代现在占据了1200个Region，但是一次垃圾回收之后，就让里面1000个Region都空了，此时那1000个Region就可以不属于新生代了，里面很多Region可以用来存放大对象

>新生代、老年代在回收的时候，会顺带带着大对象Region一起回收，所以这就是在G1内存模型下对大对象的分配和回收的策略。

### 031、动手实验：线上系统部署如果采用G1垃圾回收器，应该如何设置参数？

#### 什么时候触发新生代+老年代的混合垃圾回收？
>G1有一个参数，是”-XX:InitiatingHeapOccupancyPercent"，它的默认值是45%。意思是说，如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。

>G1整体是基于复制算法进行Region垃圾回收，不会出现内存碎片问题，不需要像CMS那样标记-清理之后再进行内存碎片的整理。 

>g1垃圾回收器新生代初始占比默认为5%，新生代最大占比默认为60%。

>如果堆内存为4G，此时除以2048，得出每个region的大小为2mb，刚开始新生代就占5%的region，可以认为新生代就是只有100个region，有200mb的内存空间。

>g1有一个参数"-XX:MaxGCPauseMills"，它的默认值是200ms

>一旦老年代频繁达到占用堆内存45%的阈值，那么就会频繁触发mixed gc。

#### G1垃圾回收的过程

+ 首先会触发一个“初始标记”的操作，这个过程是需要进入“Stop the World”的，仅仅只是标记一下GC Roots直接能引用的对象， 这个过程速度是很快的
  
+ 接着会进入“并发标记”的阶段，这个阶段会允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，

+ 然后在并发标记阶段，就会进行GC Roots追踪，会从GC Root对象直接关联的对象开始往下追踪

    这个并发标记阶段还是很耗时的，因为要追踪全部的存活对象。 但是是并行,影响不大,会对并发标记阶段对对象做出的一些修改记录起来，比如说哪个对象被新建了，哪个对象失去了引用。
+  然后是下一个阶段，最终标记阶段，这个阶段会进入“Stop the World”，系统程序是禁止运行的，但是会根据并发标记 阶段记录的那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象

+ 最后一个阶段，就是“混合回收“阶段，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。
  
  接着会停止系统程序，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我 们指定的范围内。
  
#### G1垃圾回收器的一些参数
>“-XX:G1MixedGCCountTarget”参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次

 意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反 复8次。
 
> “-XX:G1HeapWastePercent”，默认值是5%

他的意思就是说，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉

这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会 立即停止混合回收，意味着本次混合回收就结束了

>“-XX:G1MixedGCLiveThresholdPercent”，他的默认值是85%，

意思就是确定要回收的Region的时候，必须是存 活对象低于85%的Region才可以进行回收 ,否则要是一个Region的存活对象多余85%，你还回收他干什么？这个时候要把85%的对象都拷贝到别的Region


#### 回收失败时的Full GC
如果在进行Mixed回收的时候，无论是年轻代还是老年代都基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region里去

此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发 一次失败。

一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，这个过程是极慢极慢的。


### 032-33 案例实战：百万级用户的在线教育平台，如何基于G1垃圾回收器优化性能

#### 系统的运行压力
>核心点就是搞明白在晚上两三小时高峰期内，每秒钟会有多少请求，每个请求会连带产生多少对象，占用多少内存，每个请求要处理多长时间。

#### G1垃圾回收器的默认内存布局

我们对机器上的JVM，分配4G给堆内存，其中新生代默认初始占比为5%，最大占比为60%，每个Java线程的栈内存为1MB，元数据区域（永久代）的内存为256M，此时JVM参数如下：
````
“-Xms4096M -Xmx4096M  -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseG1GC“
“-XX:G1NewSizePercent”参数是用来设置新生代初始占比的，不用设置，维持默认值为5%即可。
“-XX:G1MaxNewSizePercent”参数是用来设置新生代最大占比的，也不用设置，维持默认值为60%即可。
````

#### GC停顿时间如何设置
> “-XX:MaxGCPauseMills”，他的默认值是200毫秒

#### 多长时间会触发新生代GC？

>G1它本身是这样的一个运行原理，他会根据你预设的gc停顿时间，给新生代分配一些Region，然后到一定程度就触发gc，并且把gc时间控制在预设范围内，尽量避免一次性回收过多的Region导致gc停顿时间超出预期。

#### 新生代gc如何优化？

个人觉得G1 优化 能做的不多

> “-XX:MaxGCPauseMills”参数

>如果这个参数设置的小了，那么说明每次gc停顿时间可能特别短，此时G1一旦发现你对几十个Region占满了就立即触发新生代gc，然后gc频率特别频繁，虽然每次gc时间很短。

>大了呢  那么可能G1会允许你不停的在新生代理分配新的对象，然后积累了很多对象了，再一次性回收几百个Regio

#### mixed gc如何优化？

mixed gc的触发，老年代在堆内存里占比超过45%就会触发。

> 进入老年代的几个条件了，要不然是新生代gc过后存活对象太多没法放入Survivor区域，要不然是对象年龄太大，要不然是动态年龄判定规则。

核心的点，还是“-XX:MaxGCPauseMills”这个参数。

> 太小 ,年龄增长过快, 太大  一次存活的对象太多 最直接进入老年代

### 034、第一阶段复习：当你开发完一个系统准备部署上线时，如何设置JVM参数？
> 个人理解 G1 适合大内存服务器, 他会自己检测 Y GC, ParNew+ CMS 到达阈值触发 ,STW 时间太长

> 参数设置 有时间写

### 036、糟糕！运行着的线上系统突然卡死无法访问，万恶的JVM GC！

#### 基于JVM运行的系统最怕什么？
> STW 不解释  不管Mintor 还是old  gc 都会系统停顿

#### 年轻代gc到底多久一次对系统影响不大？
> 新生代采用的复制算法效率极高，因为新生代里存活的对象很少，只要迅速标记出这少量存活对象，移动到Survivor区，然后回收掉其他全部垃圾对象即可，速度很快。

> 大内存机器上 ParNew 会在Eden 没有内存时候触发, 如果内存太大 ,影响就大了,如果几十g 可能能停顿好几秒

#### 解决大内存机器的新生代GC过慢的问题？
用G1垃圾回收器
>G1基于他的Region内存划分原理，就可以在运行一段时间之后，比如就针对2G内存的Region进行垃圾回收，此时就仅仅停顿20ms，然后回收掉2G的内存空间，腾出来了部分内存，接着还可以继续让系统运行。

#### 要命的频繁老年代gc问题

新生代gc一般问题不会太大，但是真正问题最大的地方，在于频繁触发老年代的GC。

进入老年代的条件
````
第一个，对象年龄太大了，这种对象一般很少，都是系统中确实需要长期存在的核心组件，他们一般不需要被回收掉，所以在新生代熬过默认15次垃圾回收之后就会进入老年代。

第二个，动态年龄判定规则，如果一次新生代gc过后，发现Survivor区域中的几个年龄的对象加起来超过了Survivor区域的50%，比如说年龄1+年龄2+年龄3的对象大小总和，超过了Survivor区域的50%，此时就会把年龄3以上的对象都放入老年代。

第三个，新生代垃圾回收过后，存活对象太多了，无法放入 Surviovr中，此时直接进入老年代。
````
ps:补一手动态年龄判断

Survivor区的对象年龄从小到大进行累加，当累加到 X 年龄时的总和大于50%（可以使用XX:TargetSurvivorRatio=? 来设置保留多少空闲空间，默认值是50），那么比X大的和X都会晋升入老年代 这是>=

老年代gc通常来说都很耗费时间，无论是CMS垃圾回收器还是G1垃圾回收器，因为比如说CMS就要经历初始标记、并发标记、重新标记、并发清理、碎片整理几个环节，过程非常的复杂，G1同样也是如此

主要还是在Survivor  太大,edne小 容易走第一个,太小 容易第二 第三

#### JVM性能优化到底在优化什么？

系统真正最大的问题，就是因为内存分配、参数设置不合理，导致你的对象频繁的进入老年代，然后频繁触发老年代gc，导致系统频繁的每隔几分钟就要卡死几秒钟

### 037、大厂面试题：解释一下什么是Young GC和Full GC？

#### Minor GC / Young GC
年轻代GC

#### Full GC？Old GC？傻傻分不清楚
 字面意思  一个全部,一个老年代 ,但事实上他们几乎是等价的 ,面试要精确的话 一定要问清楚
 
 Full GC
 > Full GC指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为Full GC。

#### Major GC

Major GC跟Old GC等价起来，认为他就是针对老年代的GC，也有人把Major GC和Full GC等价起来，认为他是针对JVM全体内存区域的GC,这个是混淆的

#### Mixed GC
 G1 里面的概念,混合,等价于Full 吧
 
 
 ### 038、大厂面试题：Young GC和Full GC分别在什么情况下会发生？
 这章算总结,虽然前面也有
 
 #### Young GC的触发时机
 > Young GC其实一般就是在新生代的Eden区域满了之后就会触发，采用复制算法来回收新生代的垃圾
 
 > G1 还有个,停顿控制时间 检测
 
 #### Old GC和Full GC的触发时机  (CMS)
 
 + （1）发生Young GC之前进行检查，如果“老年代可用的连续内存空间” < “新生代历次Young GC后升入老年代的对象总和的平均大小”，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间此时必须先触发一次Old GC给老年代腾出更多的空间，然后再执行Young GC
 + （2）执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必 须立即触发一次Old GC
 + （3）老年代内存使用率超过了92%，也要直接触发Old GC，当然这个比例是可以通过参数调整的
#### Mixed   (G1)
  + 老年代频繁达到占用堆内存45%的阈值，那么就会频繁触发mixed gc。参数可设置

老年代空间也不够了，没法放入更多对象了，这个时候务必执行OldGC对老年代进行垃圾回收 ,老年代会带着Young GC 一起

#### 永久代
假如存放类信息、常量池的永久代满了之后，就会触发一次Full GC ,但一般这个区能回收很少,还是没有 会内存不够的异常
 
### 039、案例实战：每秒10万并发的BI系统是如何频繁发生Young GC的？
>所谓BI，英文全称是“Business Intelligence”，也就是“商业智能”  就是把一些商家平时日常经营的数据收集起来进行分析，然后把各种数据报表展示给商家的一套系统。

#### 技术痛点：实时自动刷新报表 + 大数据量报表
> js 会频繁请求, 实时刷新数据

#### 没什么大影响的频繁Young GC

假如 每秒5M , eden 1G, 需要200s 大概3分钟,gc时间在十几ms 可以接受

#### 提升机器配置：运用大内存机器
越来越多的商家来使用，并发压力越来越大，甚至高峰期会有每秒10万的并发压力,每秒几千请求,eden 加到了16G

这时再去Young GC 就可能到达秒级别的停顿

#### 用G1来优化大内存机器的Young GC性能
 上面这种就用G1 G1设置一个预期的GC停顿时间，比如100ms，让G1保证每次Young GC的时候最多停顿100ms，避免影响终端用户的使用。
 
 ### 040、案例实战：每日百亿数据量的实时分析引擎，为啥频繁发生Full GC ？
 
 >这个数据计算系统会不停的通过SQL语句和其他方式，从各种数据存储中提取数据到内存中来进行计算，大致当时的生产负载是每分钟大概需要执行500次数据提取和计算的任务。
 
 >每次会提取大概1万条左右的数据到内存里来计算，平均每次计算大概需要耗费10秒左右的时间，然后每台机器是4核8G的配置，JVM内存给了4G，其中新生代和老年代分别是1.5G的内存空间
 
 #### 系统到底多块会塞满新生代？
 
 > 一万数据,一条算1k ,10M, Edne算1.2G 一两分钟 塞满
 
#### 触发Minor GC的时候会有多少对象进入老年代？
     
> 计算要10秒, 不停地话 会有20次计算存活,200M ,Survivor 默认150M 不够,进老年代

#### 系统运行多久，老年代大概就会填满？

> 一分钟一次Young ,200M, Minor检测, 前七次,old 内存都够,  但七次已经装满了

#### 这个系统运行多久，老年代会触发1次Full GC？
> 第八次,会Full GC  ,假设 old 都是计算的对象 ,不算其他的,就是七八分钟一次

#### 该案例应该如何进行JVM优化？
> 把Young 给大点,2g ,Survivor 200m 能装下每次存活的对象,几乎不会进入老年代  

#### 如果该系统的工作负载再次扩大10倍呢？
> 计算方式一样,两分钟大概三次左右

#### 使用大内存机器来优化上述场景
> 加机器 ,假如也是10倍, gc间隔时间还是差不多 ,一两分钟一次,但执行时间很长,16g的eden 算1秒

>要G1吗, 后台程序没必要

### 041、第6周作业：打开脑洞！如果你的线上系统压力增长100倍，会有频繁GC问题吗？

> 有时间补上

### 042、第6周答疑：本周问题答疑汇总！
````
  g1回收器。
    1.如果新生代未达60%，老年代未达45%，系统照常运行，不会触发回收 
    2.如果新生代达60%，此后如果如有新对象生成，跑到新生代，会触发ygc.
    （1）开启了空间担保机制，ygc先判断是否需要fgc,如果每次回收后对象少于老年代空闲大小，则不用fgc,否则要
    （2）不用触发，但ygc后的对象大于老年代空闲大小，无法直接进入老年代，触发fgc.
    （3）触发混合回收，先通过gcroot初始标记哪些不是垃圾对象(此过程会stw,不过很快)，然后并发标记(用户线程和标记线程并行)，接
    着最终标记(会stw，标记并发标记过程中可能新产生的垃圾对象)，最后混合回收(此过程采用复制算法，不会产生垃圾碎片，所以不用
    在回收完去整理内存碎片
    g1会按照我们给定的时间去stw并回收，争取回收性价比的对象，如果回收次数少于8次，则再次混合回收。不过，在回收中空闲
    region大小达到堆5%，会提前结束。)如果回收失败，则转换采用serialold回收器。 
    3.当老年代代达45%会触发上面那个混合过程。

````
### 043、动手实验：自己动手模拟出频繁Young GC的场景体验一下！

````
    -XX:NewSize=5242880 -XX:MaxNewSize=5242880 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC
    上述参数都是基于JDK 1.8版本来设置的，不同的JDK版本对应的参数名称是不太一样的，但是基本意思是类似的。
    上面“-XX:InitialHeapSize”和“-XX:MaxHeapSize”就是初始堆大小和最大堆大小，“-XX:NewSize”和“-XX:MaxNewSize”是初始新生代大小和最大新生代大小，“-XX:PretenureSizeThreshold=10485760”指定了大对象阈值是10MB。
````

#### 如何打印出JVM GC日志？
````
    -XX:+PrintGCDetils：打印详细的gc日志
    
    -XX:+PrintGCTimeStamps：这个参数可以打印出来每次GC发生的时间
    
    -Xloggc:gc.log：这个参数可以设置将gc日志写入一个磁盘文件
````

-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log


### 044、高级工程师的硬核技能：JVM的Young GC日志应该怎么看？

#### 程序运行采用的默认JVM参数如何查看？
> 打印gc日志的参数，就可以在这里看到他默认会给你的JVM进程分配多大的内存空间了

#### 一次GC的概要说明
````
  java代码
       byte[] arr = new byte[1024 * 1024];
        arr = new byte[1024 * 1024];
        arr = new byte[1024 * 1024];
        
        byte[] arr2 = new byte[2*1024 * 1024];
 gc 日志     
    0.268: [GC (Allocation Failure) 0.269: [ParNew: 4030K->512K(4608K), 0.0015734 secs] 4030K->574K(9728K), 0.0017518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
````
GC (Allocation Failure) 分配失败 GC

耗时 0.268 

ParNew: 4030K->512K(4608K), 0.0015734 secs 年轻代ParNew ,4608KB 是可用,4030K 已用,512K gc之后 已用 ,耗时0.0015734

4030K->574K(9728K), 0.0017518 secs 是整个堆

#### GC过后的堆内存使用情况
````
    Heap
    
    par new generation   total 4608K, used 2601K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)
    
     eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)
    
     from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)
    
     to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)
    
    concurrent mark-sweep generation total 5120K, used 62K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
    
    Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
    
     class space    used 300K, capacity 386K, committed 512K, reserved 1048576K
````
JVM退出的时候打印出来的当前堆内存的使用情况，其实也很简单

````
par new generation   total 4608K, used 2601K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)

 eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)

 from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)

 to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)
 ````
 这是par new 负责的年轻代,eden,from ,to,使用情况  
 
 ````
 concurrent mark-sweep generation total 5120K, used 62K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
 
 Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
 
  class space    used 300K, capacity 386K, committed 512K, reserved 1048576K
  
 ````
CMS 负责的老年代 ,Metaspace元数据空间和Class空间 使用情况
 
### 045-46、动手实验：自己动手模拟出对象进入老年代的场景体验一下

#### 动态年龄判定规则
1. 躲过15次gc，达到15岁高龄之后进入老年代；
2. 动态年龄判定规则，如果Survivor区域内年龄1+年龄2+年龄3+年龄n的对象总和大于Survivor区的50%，此时年龄n以上的对象会进入
老年代，不一定要达到15岁
3. 如果一次Young GC后存活对象太多无法放入Survivor区，此时直接计入老年代
4. 大对象直接进入老年代

配置参数
>“-XX:NewSize=10485760 -XX:MaxNewSize=10485760 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -
 XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -
 XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log

新生代我们通过“-XX:NewSize”设置为10MB了         然后其中Eden区是8MB，每个Survivor区是1MB，Java堆总大小是20MB，老年代是10MB，大对象必须超过10MB才会直接进入老年代
 
 代码
````
        byte[] arr = new byte[2*1024 * 1024];
        arr = new byte[2*1024 * 1024];
        arr = new byte[2*1024 * 1024];
        arr = null;
        byte[] arr2 = new byte[128 * 1024];
        byte[] arr3 = new byte[2*1024 * 1024];
````

日志
````
 0.297: [GC (Allocation Failure) 0.297: [ParNew: 7260K->715K(9216K), 0.0012641 secs] 7260K->715K(19456K), 0.0015046
 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
 Heap
 par new generation total 9216K, used 2845K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K, 26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)
  from space 1024K, 69% used [0x00000000ff500000, 0x00000000ff5b2e10, 0x00000000ff600000)
  to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 concurrent mark-sweep generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
 Metaspace used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
  class space used 300K, capacity 386K, committed 512K, reserved 1048576K
````

#### 部分代码的GC日志分析

连续申请3个 2M的对象,6m eden 8m ,后面又申请128k  ,在申请2m  肯定不够 gc

通过日志可以清晰看出，此时From Survivor区域被占据了69%的内存，大概就是700KB左右，这就是一次Young GC后存活下来的对象，他们都进入From Survivor区了。

同时Eden区域内被占据了26%的空间，大概就是2MB左右，这就是byte[] array3 = new byte[2 * 1024 * 1024];，这行代码在gc过后分配在Eden区域内的数组

此时from 内的对象 年龄应该是1 ,gc 后剩余715k 应该全部进入from, from 1m ,大于一半,所以应比他大的都在old


代码修改
````
        byte[] arr = new byte[2*1024 * 1024];
        arr = new byte[2*1024 * 1024];
        arr = new byte[2*1024 * 1024];
        arr = null;
        byte[] arr2 = new byte[128 * 1024];
        byte[] arr3 = new byte[2*1024 * 1024];

        arr3 = new byte[2*1024 * 1024];
        arr3 = new byte[2*1024 * 1024];
        arr3 = new byte[128 * 1024];
         arr3=null;
        byte[] arr4 = new byte[2*1024 * 1024];
````

#### 在分析下

 第一次gc 完毕, from 715k ,eden 2m
 
 然后申请 2个2m 1个 128K, null ,在申请2m ,不够 进入第二次par new  gc
 
 日志
 ````
    0.269: [GC (Allocation Failure) 0.269: [ParNew: 7260K->713K(9216K), 0.0013103 secs] 7260K->713K(19456K), 0.0015501
    secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
    0.271: [GC (Allocation Failure) 0.271: [ParNew: 7017K->0K(9216K), 0.0036521 secs] 7017K->700K(19456K), 0.0037342 secs]
    [Times: user=0.06 sys=0.00, real=0.00 secs]
    Heap
    par new generation total 9216K, used 2212K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
     eden space 8192K, 27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000)
     from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
     to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
    concurrent mark-sweep generation total 10240K, used 700K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
    Metaspace used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
     class space used 300K, capacity 386K, committed 512K, reserved 1048576K
````

第一次上面说了  第二次 7017K->0K  年轻代0k  eden 27% ,这个是刚申请的arr4 的2m,那其他对象呢

其实此时会发现Survivor区域中的对象都是存活的，而且总大小超过50%了，而且年龄都是1岁

此时根据动态年龄判定规则：年龄1+年龄2+年龄n的对象总大小超过了Survivor区域的50%，年龄n以上的对象进入老年代。

此时eden 是arr4  ,老年是arr2和其他对象


#### Survivor区域放不下，就直接进入老年代

参数和上面一样

代码
````
   byte[] arr = new byte[2*1024 * 1024];
   arr = new byte[2*1024 * 1024];
   arr = new byte[2*1024 * 1024];
   
    byte[] arr2 = new byte[128 * 1024];
    arr2 = null;
    byte[] arr3 = new byte[2*1024 * 1024];
````

日志

````

0.421: [GC (Allocation Failure) 0.421: [ParNew: 7260K->573K(9216K), 0.0024098 secs] 7260K->2623K(19456K), 0.0026802 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap

par new generation   total 9216K, used 2703K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

 eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)
 from space 1024K,  55% used [0x00000000ff500000, 0x00000000ff58f570, 0x00000000ff600000)
 to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

concurrent mark-sweep generation total 10240K, used 2050K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K
````

逻辑和上面第一个一致 ,但他gc后 ,活下来一个2m 的对象, 和其他对象( 这部分应该是573k)  ,servivor 1m ,肯定是放不下的

而通过日志也能看到 2m那个,在old ,573的在survicor  

#### 结论

在这种场景下，有部分对象会留在Survivor中，有部分对象会进入老年代的。


### 047、高级工程师的硬核技能：JVM的Full GC日志应该怎么看？

参数
> “-XX:NewSize=10485760 -XX:MaxNewSize=10485760 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=3145728 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log”

新生代我们通过“-XX:NewSize”设置为10MB了         然后其中Eden区是8MB，每个Survivor区是1MB，Java堆总大小是20MB，老年代是10MB

注意  PretenureSizeThreshold   大对象设为3m  

代码

````
      byte[] arr = new byte[4*1024 * 1024];
      arr=null;
      byte[] arr2 = new byte[2*1024 * 1024];
      byte[] arr3 = new byte[2*1024 * 1024];
      byte[] arr4 = new byte[2*1024 * 1024];
      byte[] arr5 = new byte[128* 1024];
         
      byte[] arr6 = new byte[2*1024 * 1024];
````

日志
````
    “0.308: [GC (Allocation Failure) 0.308: [ParNew (promotion failed): 7260K->7970K(9216K), 0.0048975 secs]0.314: [CMS: 8194K->6836K(10240K), 0.0049920 secs] 11356K->6836K(19456K), [Metaspace: 2776K->2776K(1056768K)], 0.0106074 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
    Heap
    
    par new generation   total 9216K, used 2130K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
     eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)
     from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
     to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
    
    concurrent mark-sweep generation total 10240K, used 6836K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
    Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
     class space    used 300K, capacity 386K, committed 512K, reserved 1048576K”
     
     [CMS: 8194K->6836K(10240K), 0.0049920 secs] 11356K->6836K(19456K), [Metaspace: 2776K->2776K(1056768K)], 0.0106074 secs]
````


#### 分析
>基于执行arr6 的时候 ,申请 2m

1 arr 是大对象,直接进old ,  3个2m 的对象+128  在申请会gc

2 但这几个对象都是强引用,收不掉, 放到survivor  放不下,

3 这时old 有4m ,放6m+128  一定放不下,担保,ParNew 强引用,还是存活,会触发FULL GC 清掉 4m 大对象

````
    [CMS: 8194K->6836K(10240K), 0.0049920 secs] 11356K->6836K(19456K), [Metaspace: 2776K->2776K(1056768K)], 0.0106074 secs]
````

4 CMS   8194K->6836K 从哪来的?   他会先放2个2m 不够gc,最后放后面   4+2+2-4+2+其他(包括那128) =6836K

5 eden 放入 arr6 ,eden 占用2m 

#### 总结
1 FULL 触发,忘了看下前面画的图
2 还有一个，就是老年代被使用率达到了92%的阈值，也会触发Full GC。

### 048、第7周作业：自己尝试着分析一把你们线上系统的JVM GC日志

> 2020/7/8  我专门试了下测试机,  表现打分不及格


### 049、第7周答疑：本周问题答疑汇总

1 补手动态年龄, 是>= 进入old  ,每次Minor GC过后就会触发动态年龄判定机制的


### 050、动手实验：使用 jstat 摸清线上系统的JVM运行状况
> 他可以轻易的让你看到当前运行中的系统，他的JVM内的Eden、Survivor、老年代的内存使用情况，还有Young GC和Full gC的执行次数以及耗时

常用 jstat -gc PID
````
  S0C：这是From Survivor区的大小
  
  
  S1C：这是To Survivor区的大小
  
  S0U：这是From Survivor区当前使用的内存大小
  
  S1U：这是To Survivor区当前使用的内存大小
  
  EC：这是Eden区的大小
  
  EU：这是Eden区当前使用的内存大小
  
  OC：这是老年代的大小
  
  OU：这是老年代当前使用的内存大小
  
  MC：这是方法区（永久代、元数据区）的大小
  
  MU：这是方法区（永久代、元数据区）的当前使用的内存大小
  
  YGC：这是系统运行迄今为止的Young GC次数
  
  YGCT：这是Young GC的耗时
  
  FGC：这是系统运行迄今为止的Full GC次数
  
  FGCT：这是Full GC的耗时
  
  GCT：这是所有GC的总耗时
````

其他的jstat命令
````
    除了上面的jstat -gc命令是最常用的以外，他还有一些命令可以看到更多详细的信息，如下所示：
    
    jstat -gccapacity PID：堆内存分析
    
    jstat -gcnew PID：年轻代GC分析，这里的TT和MTT可以看到对象在年轻代存活的年龄和存活的最大年龄
    
    jstat -gcnewcapacity PID：年轻代内存分析
    
    jstat -gcold PID：老年代GC分析
    
    jstat -gcoldcapacity PID：老年代内存分析
    
    jstat -gcmetacapacity PID：元数据区内存分析
````

jstat -gc PID 1000 10

 主要功能 (可以配合gc 日志)
>这行命令，他的意思就是每隔1秒钟更新出来最新的一行jstat统计信息，一共执行10次jstat统计

+ 能动态推测占用问题   ,新生代对象增长的速率
+ Young GC的触发频率和每次耗时
+ 每次Young GC后有多少对象是存活和进入老年代
+ Full GC的触发时机和耗时

### 051、动手实验：使用jmap和jhat摸清线上系统的对象分布

>使用jmap了解系统运行时的内存区域

#### map -heap PID
> 堆占用状态

#### jmap -histo PID

>jvm中的对象对内存占用的情况，只要直接用jmap -histo命令即可，非常好用

#### 使用jmap生成堆内存转储快照
>jmap -dump:live,format=b,file=dump.hprof PID

#### 使用jhat在浏览器中分析堆转出快照
> jhat dump.hprof -port 7000    去分析堆快照了，jhat内置了web服务器，他会支持你通过浏览器来以图形化的方式分析堆转储快照

### 052、从测试到上线：如何分析JVM运行状况及合理优化？
>优化思路其实简单来说就一句话：

>尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。

#### 对线上系统进行JVM监控
+ 第一种方法会“low”一些，其实就是每天在高峰期和低峰期都用jstat、jmap、jhat等工具去看看线上系统的JVM运行是否正常，有没有频繁Full GC的问题。

+ 第二种方法在中大型公司里会多一些，大家都知道，很多中大型公司都会部署专门的监控系统，比较常见的有Zabbix、OpenFalcon、Ganglia，等等。

### 053、案例实战：每秒10万并发的BI系统，如何定位和解决频繁Young GC问题？
> 还是服务于百万级商家的BI系统

> 可以用while(true)  模拟
####  技术痛点：实时自动刷新报表 + 大数据量报表
> 频繁请求数据,和大数据 都和一直生成大量对象

> 用jstat 分析运行轨迹和 gc 次数,时间


### 054、案例实战：每日百亿数据量的实时分析引擎，如何定位和解决频繁Full GC问题？

> 计算系统的特点 ,持续不断的 计算,数据提取和计算的任务。 都会生成行的对象

> 占用和运行逻辑 和上面一样,这儿主要写 优化处理

参数      (大对象20m)
````
    -XX:NewSize=104857600 -XX:MaxNewSize=104857600 -XX:InitialHeapSize=209715200 -XX:MaxHeapSize=209715200 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=20971520 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log
````

模拟代码

````
    public static void main(String[] args) {
           Thread.sleep(30000);
           while (true) {
               loadData();
           }
       }
       private static void loadData() {
           byte[] data = null;
           for (int i = 0; i < 4; i++) {
               data = new byte[10 * 1024 * 1024];
           }
           data=null;
           byte[] data1 = new byte[10 * 1024 * 1024];
           byte[] data2 = new byte[10 * 1024 * 1024];
           byte[] data3 = new byte[10 * 1024 * 1024];
           data3 = new byte[10 * 1024 * 1024];
           Thread.sleep(1000);
       }
````

大概意思其实就是，每秒钟都会执行一次loadData()方法，他会分配4个10MB的数组，但是都立马成为垃圾，但是会有data1和data2两个10MB的数组是被变量引用必须存活的，此时Eden区已经占用了六七十MB空间了，接着是data3变量依次指向了两个10MB的数组，这是为了在1s内触发Young GC的。

#### 分析

老年代总共就100MB左右，gc 每次存活30M ,survivor 放不下,直接进入old ,加上其他对象,两三次Young 就需要一次FULL 

还有一点,每次Full GC都是由Young GC触发的，因为Young GC过后存活对象太多要放入老年代，老年代内存不够了触发Full GC，所以必须得等Full GC执行完毕了，Young GC才能把存活对象放入老年代，才算结束。这就导致Young GC也是速度非常慢。



#### 优化
-XX:NewSize=209715200 -XX:MaxNewSize=209715200 -XX:InitialHeapSize=314572800 -XX:MaxHeapSize=314572800 -XX:SurvivorRatio=2  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=20971520 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log

把堆大小调大为了300MB，年轻代给了200MB，同时“-XX:SurvivorRatio=2”表明，Eden:Survivor:Survivor的比例为2:1:1，所以Eden区是100MB，每个Survivor区是50MB，老年代也是100MB。


### 055、第8周作业
> 公司实战,恩........

### 056、第8周答疑：本周问题答疑汇总
> ...

### 057、案例实战：每秒十万QPS的社交APP 如何优化GC性能提升3倍？

>一个有高峰期每秒十万QPS的社交APP 这类APP，在晚上高峰期，流量最大的一个模块，其实就是个人主页模块 qps 很高


 高并发查询导致对象快速进入老年代  年轻代的Eden区会迅速的被填满，并且频繁的触发Young GC ,每次很多对象是需要存活下来的 ,经常会出现Young GC过后存活对象较多，在Survivor区中放不下的问题,会导致大量的对象快速的进入老年代中

老年代必然会触发频繁GC 会导致个人主页服务对应的JVM频繁的发生老年代的GC

#### 优化前的线上系统JVM参数
>最核心的优化点，主要应该是增加机器，尽量让每台机器承载更少的并发请求，减轻压力。

>同时，给年轻代的Survivor区域更大的内存空间，让每次Young GC后的存活对象务必停留在Survior中，别进入老年代

>-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5

在每5次 CMS后 执行一次老年代的内存整理

上述两个参数“-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5”是设置的5次Full GC之后才会进行一次压缩操作，解决内存碎片的问题，空出来大片的连续可用内存空间。

#### 优化方案
+  判断出来每次Young GC后存活对象有多少，然后就是增加Survivor区的内存，避免对象快速进入老年代。 减少FULL GC

+ 在降低了Full GC频率之后，务必设置如下参数“-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0”，每次Full GC后都整理一下内存碎片。

> 如果有很多内存碎片，  也许第一次Full GC是一小时才有，第二次Full GC也许是40分钟之后，第三次Full GC可能就是20分钟之后，要是不解决CMS内存碎片问题，必然导致Full GC慢慢变得越来越频繁。

### 058、案例实战：垂直电商APP后台系统，如何对Full GC进行深度优化？

>其实现在除了淘宝、京东、天猫、唯品会这些超大型的电商平台之外，国内还是有很多中小型的垂直类电商公司的。 他们做的主要是一些细分领域的电商业务，比如说有的APP专门做消费分期类的电商业务，在他们的APP里你主要是进行购物，然后可以分期付费。

#### 垂直电商APP的JVM性能问题
> 默认的JVM参数是系统负载逐渐增高的时候一个最大的问题,因为 这种默认survivor,eden 给都不大, 会大量对象进old ,频繁FULL 

#### 公司级别的JVM参数模板
4核8G  还有其他进程
> -Xms4096M -Xmx4096M -Xmn3072M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0


#### 优化每次Full GC的性能？

> -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark

>一个参数是“-XX:+CMSParallelInitialMarkEnabled”，这个参数会在CMS垃圾回收器的“初始标记”阶段开启多线程并发执行。

大家应该还记得初始标记阶段，是会进行Stop the World的，会导致系统停顿，所以这个阶段开启多线程并发之后，可以尽可能优化这个阶段的性能，减少Stop the World的时间。



>另外一个参数是“-XX:+CMSScavengeBeforeRemark”，这个参数会在CMS的重新标记阶段之前，先尽量执行一次Young GC。

主要作用就是让Young GC 先执行,CMS 在CMS的重新标记阶段就可以少扫描一些对象，此时就可以提升CMS的重新标记阶段的性能，减少他的耗时。


### 059、案例实战：新手工程师不合理设置JVM参数，是如何导致频繁Full GC的？

####  问题的产生
>某天团队里一个新手工程师大概是心血来潮，觉得自己网上看到了某个JVM参数，以为学会了绝世武功秘籍，于是就在当天上线一个系统的时候，自作主张设置了一个JVM参数

#### 查看GC日志
在日志里，看到了一个“Metadata GC Threshold”的字样，类似于如下日志：
>【Full GC（Metadata GC Threshold）xxxxx, xxxxx】

#### 一个综合性的分析思路
这个很明显是系统在运行过程中，不停的有新的类产生被加载到Metaspace区域里去，然后不停的把Metaspace区域占满，接着触发一次Full GC回收掉Metaspace区域中的部分类。

然后这个过程反复的不断的循环，进而造成Metaspace区域反复被占满，然后反复导致Full GC的发生

#### 到底是什么类不停的被加载？
> “-XX:TraceClassLoading -XX:TraceClassUnloading”

开启类加载,卸载的追踪日志

堆日志，里面显示类似如下的内容：
>【Loaded sun.reflect.GeneratedSerializationConstructorAccessor from __JVM_Defined_Class】

#### JVM创建的奇怪类有什么玄机？
这种JVM自己创建的奇怪的类，他们的Class对象都是SoftReference，也就是软引用的。

那么SoftReference对象到底在GC的时候要不要回收是通过什么公式来判断的呢？
>是如下的一个公式：clock - timestamp <= freespace * SoftRefLRUPolicyMSPerMB。

这个公式的意思就是说，“clock - timestamp”代表了一个软引用对象他有多久没被访问过了，freespace代表JVM中的空闲内存空间，SoftRefLRUPolicyMSPerMB代表每一MB空闲内存空间可以允许SoftReference对象存活多久。

举个例子，假如说现在JVM创建了一大堆的奇怪的类出来，这些类本身的Class对象都是被SoftReference软引用的。然后现在JVM里的空间内存空间有3000MB，SoftRefLRUPolicyMSPerMB的默认值是1000毫秒，那么就意味着，此时那些奇怪的SoftReference软引用的Class对象，可以存活3000 * 1000 = 3000秒，就是50分钟左右。

当然上面都是举例而已，大家都知道，一般来说发生GC时，其实JVM内部或多或少总有一些空间内存的，所以基本上如果不是快要发生OOM内存溢出了，一般软引用也不会被回收。

#### 为什么JVM创建的奇怪的类会不停的变多？
> 因为文章开头那个新手工程师不知道从哪里扒出来了SoftRefLRUPolicyMSPerMB这个JVM启动参数，他直接把这个参数设置为0了。

实际上一旦这个参数设置为0之后，直接导致clock - timestamp <= freespace * SoftRefLRUPolicyMSPerMB这个公式的右半边是0，就导致所有的软引用对象，比如JVM生成的那些奇怪的Class对象，刚创建出来就可能被一次Young GC给带着立马回收掉一些。

也许下一次gc又会回收掉一些奇怪的类，但是马上JVM还会继续生成这种类，最终就会导致Metaspace区域被放满了，一旦Metaspace区域被占满了，就会触发Full GC，然后回收掉很多类，接着再次重复上述循环

#### 如何解决这个问题？
>XX:SoftRefLRUPolicyMSPerMB=0

这个参数设置大一些即可，千万别让一些新手同学设置为0，可以设置个1000，2000，3000，或者5000毫秒，都可以 

### 060、案例实战：一次线上系统每天数十次Full GC导致频繁卡死的优化实战！

#### 未优化前的JVM性能分析
> jvm 自带jstat

> Zabbix、Ganglia、Open-Falcon、Prometheus之类的可视化监控平台，其实接入都非常简单，如果把线上系统接入了这些平台，可以直接图形化看到JVM的表现。

````
机器配置：2核4G

JVM堆内存大小：2G

系统运行时间：6天

系统运行6天内发生的Full GC次数和耗时：250次，70多秒

系统运行6天内发生的Young GC次数和耗时：2.6万次，1400秒
````
综合分析一下，就可以知道，大致来说每天会发生40多次Full GC，平均每小时2次，每次Full GC在300毫秒左右；

#### 未优化前的线上JVM参数
> -Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=5 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=68 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC

其实基本上跟我们之前看到的参数没多大的不同，一个4G的机器上，给JVM的堆内存是设置了1.5G的大小，其中新生代是给了512M，老年代是1G。

比较关键的是“-XX:SurvivorRatio”设置为了5，也就是说，Eden:Survivor1:Survivor2的比例是5:1:1

所以此时Eden区域大致为365M，每个Survivor区域大致为70MB。

而且这里有一个非常关键的参数，那就是“-XX:CMSInitiatingOccupancyFraction”参数设置为了68

所以一旦老年代内存占用达到68%，也就是大概有680MB左右的对象时，就会触发一次Full GC

#### 根据线上系统的GC情况倒推运行内存模型

+ 每分钟会发生3次Young GC，说明系统运行20秒就会让Eden区满，也就是产生300多MB的对象，平均下来系统每秒钟会产生15~20MB的对象，

+ 每小时2次Full GC推断出，30分钟会触发一次Full GC, -XX:CMSInitiatingOccupancyFraction=68 ,系统运行30分钟就会导致老年代里有600多MB的对象      

结论:
+ 每隔20秒会让300多MB的Eden区满触发一次Young GC，一次Young GC耗时50毫秒左右。

+ 每隔30分钟会让老年代里600多MB空间占满，进而触发一次CMS的GC，一次Full GC耗时300毫秒左右。

#### 老年代里到底为什么会有那么多的对象？

一般来说，每次Young GC过后大概就存活几十MB而已，那么Survivor区域因为就70MB，所以经常会触发动态年龄判断规则，导致偶尔一次Young GC过后有几十MB对象进入老年代。

但这不足让600M 老年代,快速填满

这个时候我们通过jstat运行的时候就观察到一个现象，就是老年代里的内存占用在系统运行的时候，不知道为什么系统运行着运行着，就会突然有几百MB的对象占据在里面，大概有五六百MB的对象，一直占据在老年代中

#### 定位系统的大对象

dump内存快照。通过内存快照的分析，直接定位出来那个几百MB的大对象，就是几个Map之类的数据结构，这是什么东西？直接让负责写那个系统代码的几个同学分析了一下，明显是从数据库里查出来的！

#### 优化

+ 第一步，让开发同学解决代码中的bug，避免一些极端情况下SQL语句里不拼接where条件，务必要拼接上where条件，不允许查询表中全部数据。彻底解决那个时不时有几百MB对象进入老年代的问题。

+ 第二步，年轻代明显过小，Survivor区域空间不够，因为每次Young GC后存活对象在几十MB左右，如果Survivor就70MB很容易触发动态年龄判定，让对象进入老年代中。所以直接调整JVM参数如下：
>-Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=5 -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=92 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC

直接把年轻代空间调整为700MB左右，每个Surivor是150MB左右，此时Young GC过后就几十MG存活对象，一般不会进入老年代。

反之老年代就留500MB左右就足够了，因为一般不会有对象进入老年代。

而且调整了参数“-XX:CMSInitiatingOccupancyFraction=92”，避免老年代仅仅占用68%就触发GC，现在必须要占用到92%才会触发GC。

最后，就是主动设置了永久代大小为256MB，因为如果不主动设置会导致默认永久代就在几十MB的样子，很容易导致万一系统运行时候采用了反射之类的机制，可能一旦动态加载的类过多，就会频繁触发Full GC。


### 061、案例实战：电商大促活动下，严重Full GC导致系统直接卡死的优化实战

>有一次一个新系统上线，平时都还算正常，结果有一次大促活动的时候，这个系统就直接卡死不动了

首先使用jstat去看一下系统运行情况，令人吃惊的事情是：JVM几乎每秒都执行一次Full GC，每次都耗时几百毫秒。

#### 问题
> System.gc()  显式调用了FULL GC

#### 解决
>-XX:+DisableExplicitGC。这个参数的意思就是禁止显式执行GC，不允许你来通过代码触发GC。

### 062、第9周作业
> 总结 

### 063、第9周答疑以及学员思考题总结汇总
> 


### 064、案例实战：一次线上大促营销活动导致的内存泄漏和Full GC优化
>一次我们线上推了一个大促销活动，大致就是类似于在某个特定节日里，突然给所有用户发短信、邮件、APP Push消息，说现在有个特别优惠的活动，如果参与的话肯定可以得到很大的实惠！


#### 初步排查CPU负载过高的原因
+ 第一个场景，是你自己在系统里创建了大量的线程，这些线程同时并发运行，而且工作负载都很重，过多的线程同时并发运行就会导致你的机器CPU负载过高。

+ 第二个场景，就是你的机器上运行的JVM在执行频繁的Full GC，Full GC是非常耗费CPU资源的，他是一个非常重负载的过程

#### 初步排查频繁Full GC的问题
一般可能性有三个：

+ 内存分配不合理，导致对象频繁进入老年代，进而引发频繁的Full GC；

+ 存在内存泄漏等问题，就是内存里驻留了大量的对象塞满了老年代，导致稍微有一些对象进入老年代就会引发Full GC；

+ 永久代里的类太多，触发了Full GC

还有一种显式调用  但少

#### 对线上系统导出一份内存快照
>jmap -dump:format=b,file=文件名 [服务进程ID]

#### 分析
> 用mat 分析内存泄露的情况

### 065、案例实战：百万级数据误处理导致的频繁Full GC问题优化
> 一次版本升级 所有用户全部看到的是一片空白和错误信息。线上系统所在机器的CPU负载非常高，持续走高，甚至直接导致机器都宕机了。

#### CPU负载高原因分析
> jstat Full GC 频繁,且耗时

#### Full GC频繁的原因分析
> 这个系统因为主要是用来进行大量数据处理然后提供数据给用户查看的，所以当时可是给JVM的堆分配了20G的内存，其中10G给了年轻代，10G给了老年代

#### 以前那套GC优化策略还能奏效吗？
> 难,新生对象多且大 ,survivor 加大,也会放不下

#### 分析
> 用mat 分析大对象, 查看调用链,看他的调用

### “String.split()”会造成内存泄漏？
 > 大量调用会 生成大量对象
 
 #### 代码如何进行优化？
 > 比较核心的思路，就是开启多线程并发处理大量的数据，尽量提升数据处理完毕的速度，这样到触发Young GC的时候避免过多的对象存活下来。
 
 ### 066、阶段性复习：JVM运行原理和GC原理你真的搞懂了吗？

#### JVM和GC的运行原理，你都能搞懂了吗？
>年轻代、老年代、Metaspace（也就是以前的永久代）。 

+ 我们写好的系统会不停的运行，运行的时候是不是就会不停的在年轻代的Eden区域中创建各种对象？
+ 一般创建对象都是在各种方法里执行的，一旦方法运行完毕，方法局部变量引用的那些对象就会成为Eden区里的垃圾对象，就是可以被回收的状态
+ 随着Eden区不断的创建对象，就会逐步的塞满，当然这个时候可能塞满Eden区的对象里大多数都是垃圾对象。一旦Eden区塞满之后，就会触发一次Young GC。然后把存活对象都放入第一个Survivor区域中
+ 垃圾回收器就会直接回收掉Eden区里剩余的全部垃圾对象，在整个这个垃圾回收的过程中全程会进入Stop the Wold状态，也就是暂停系统工作线程，系统代码全部停止运行，不允许创建新的对象只有这样，才能让垃圾回收器专心工作，找出来存活对象，回收掉垃圾对象
+ 一旦垃圾回收全部完毕之后，也就是存活对象都进入了Survivor区域，然后Eden区都清空了，那么Young GC执行完毕，此时系统恢复工作，继续在Eden区里创建对象

负责Young GC的垃圾回收器有很多种，但是常用的就是ParNew垃圾回收器

#### 对象什么时候进入老年代？
对象进入老年代区域中
1. 一个对象在年轻代里躲过15次垃圾回收，年龄太大了，寿终正寝，进入老年代
2. 对象太大了，超过了一定的阈值，直接进入老年代，不走年轻代
3. 一次Young GC过后存活对象太多了，导致Survivor区域放不下了，这批对象会进入老年代
4. 可能几次Young GC过后，Surviovr区域中的对象占用了超过50%的内存，此时会判断如果年龄1+年龄2+年龄N的对象总和超过了Survivor区域的50%，此时年龄N以及之上的对象都进入老年代，这是动态年龄判定规则

#### 老年代的GC是如何触发的？
1. 老年代自身可以设置一个阈值，有一个JVM参数可以控制，一旦老年代内存使用达到这个阈值，就会触发Full GC，一般建议调节大一些，比如92%
2. 在执行Young GC之前，如果判断发现老年代可用空间小于了历次Young GC后升入老年代的平均对象大小的话，那么就会在YoungGC之前触发Full GC，先回收掉老年代一批对象，然后再执行Young GC。
3. 如果Young GC过后的存活对象太多，Survivor区域放不下，就要放入老年代，要是此时老年代也放不下，就会触发Full GC，回收老年代一批对象，再把这些年轻代的存活对象放入老年代中

#### 正常情况下的系统
会有一定频率的Young GC，一般在几分钟一次Young GC，或者几十分钟一次Young GC，一次耗时在几毫秒到几十毫秒的样子，都是正常的。

### 067、阶段性复习：JVM性能优化到底该怎么做？
#### 一个新系统开发完毕之后如何设置JVM参数？
+ 首先大家应该估算一下自己负责的系统每个核心接口每秒多少次请求，每次请求会创建多少个对象，每个对象大概多大，每秒钟会使用多少内存空间？
+ 然后就可以估算出来多长时间会发生一次Young GC，而且可以估算一下发生Young GC的时候，会有多少对象存活下来，会有多少对象升入老年代里，老年代对象增长的速率大概是多少，多久之后会触发一次Full GC。

原则就是：尽可能让每次Young GC后存活对象远远小于Survivor区域，避免对象频繁进入老年代触发Full GC。

#### 在压测之后合理调整JVM参数
压测，此时在模拟线上压力的场景下，可以用jstat等工具去观察JVM的运行内存模型：
````
Eden区的对象增长速率多块？
Young GC频率多高？
一次Young GC多长耗时？
Young GC过后多少对象存活？
老年代的对象增长速率多高？
Full GC频率多高？
一次Full GC耗时？
````

#### 线上系统的监控和优化
>高大上的做法就是通过Zabbix、Open-Falcon之类的工具来监控机器和JVM的运行，频繁Full GC就要报警。

> 差一点的做法，就是在机器上运行jstat，让其把监控信息写入一个文件，每天定时检查一下看一看。

#### 线上频繁Full GC的几种表现

表现如下：
````
机器CPU负载过高；
频繁Full GC报警；
系统无法处理请求或者处理过慢
````
所以一旦发生上述几个情况，大家第一时间得想到是不是发生了频繁Full GC。

#### 频繁Full GC的几种常见原因
+ 系统承载高并发请求，或者处理数据量过大，导致Young GC很频繁，而且每次Young GC过后存活对象太多，内存分配不合理，Survivor区域过小，导致对象频繁进入老年代，频繁触发Full GC。
+ 系统一次性加载过多数据进内存，搞出来很多大对象，导致频繁有大对象进入老年代，必然频繁触发Full GC
+ 系统发生了内存泄漏，莫名其妙创建大量的对象，始终无法回收，一直占用在老年代里，必然频繁触发Full GC
+ Metaspace（永久代）因为加载类过多触发Full GC
+ 误调用System.gc()触发Full GC

其实常见的频繁Full GC原因无非就上述那几种，所以大家在线上处理Full GC的时候，就从这几个角度入手去分析即可，核心利器就是jstat。

#### 一个统一的JVM参数模板
> 通过机器大概配置,整理一个 参数模板

### 068、如何为你的面试准备自己负责的系统中的JVM优化案例？
#### 面试中回答JVM生产优化问题？
比较常见的做法，就是把之前学习过的知识，归纳总结出来一套通用的方法付论，然后面试的时候就聊这套通用方法论即可

#### 如果你的系统访问量和数据量暴增10倍或者100倍

应该把频繁Full GC问题和你自己的业务系统结合起来，自己深度思考，自己整理出来几个自己系统可能发生的JVM性能问题，然后整理出一套解决方案出来。

#### JVM的优化注意点
 少用一些奇怪的参数 ,很容易中招
 
### 070、第10周答疑汇总

####  新学到参数：
````
      -XX:+CMSParallelInitialMarkEnabled表示在初始标记的多线程执行，减少STW；
      -XX:+CMSScavengeBeforeRemark：在重新标记之前执行minorGC减少重新标记时间；
      -XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，降低STW；
      -XX：CMSInitiatingOccupancyFraction=92和-XX:+UseCMSInitiatingOccupancyOnly配套使用，如果不设置后者，jvm第一
      次会采用92%但是后续jvm会根据运行时采集的数据来进行GC周期，如果设置后者则jvm每次都会在92%的时候进行gc；
      -XX:+PrintHeapAtGC:在每次GC前都要GC堆的概况输出
````
#### fullgc的发生情况：
1. 老年代可用内存小于新生代全部对象的大小，又没有开启空间担保，就会直接触发fullgc。
2. 如果新生代存活大小大于老年代空间，并且老年代空间小于历次晋升的平均内存大小，也会执行fullgc。
3. 大对象或者动态年龄进入老年代，而老年代空间不足，也会执行fullgc。
4. 如果是cms回收器，那么老年代内存使用到92%之后，就会触发fullgc，因为并发清除阶段需要给用户线程预留内存空间。

#### 一个类从加载到使用，一般会经历哪些过程
答：加载->验证->准备->解析->初始化->使用->卸载

1. 加载:将编译好的".class"字节码文件加载到JVM中
2. 验证:根据JVM规范，校验加载进来的".class"字节码文件
3. 准备:给类和类变量分配一定的内存空间，且给类变量设置默认的初始值(0或者nul) 
4. 解析:把符号引用替换为直接引用的过程
5. 初始化:根据类初始化代码给类变量赋值 


### 071、Java程序员的梦魇：线上系统突然挂掉，可怕的OOM内存溢出！
#### Java程序员平时最常遇到的故障：系统OOM
通常而言，内存溢出这个问题可能对你的系统是毁灭性的打击，他代表你的JVM内存不足以支撑你的代码的运行

所以一旦发生这个情况，就会导致你的系统直接停止运转，甚至会导致你的JVM进程直接崩溃掉，进程都没了！

### 072、大厂面试题：什么是内存溢出？在哪些区域会发生内存溢出？
#### 运行一个Java系统就是运行一个JVM进程
     
第一步就是这份“.java”源代码文件必须先编译成一个“.class”字节码文件，这个字节码文件才是可以运行的

字节码文件，比如HelloWorld.class，如果里面包含了main方法，接下来我们就可以用“java命令”来在命令行执行这个字节码文件了

运行一个Java系统，本质上就是启动一个JVM进程，这个JVM进程负责来执行你写好的一大堆代码。只要你的Java系统中包含一个main方法，接着JVM进程就会从你指定的这个main方法入手

#### 到底执行哪些代码：JVM得加载你写的类
首先当然得把你写好的类加载到内存里来啊！ 有一块区域叫做永久代，当然JDK 1.8以后都叫做Metaspace了,存放你系统里的各种类的信息的，包括JDK自身内置的一些类的信息

Metaspace 是有可能 OOM的

#### Java虚拟机栈：让线程执行各种方法
方法执行，都必须依赖JVM进程中的某个线程去执行，你可以理解为线程才是执行我们写的代码的核心主体。

JVM进程启动之后默认就会有一个main线程，这个main线程就是专门负责执行main()方法的。

一个线程只要执行一个方法，就会为方法创建一个栈桢，将栈桢放入自己的虚拟机栈里去，然后在这个栈桢里放入方法中定义的各种局部变量

我们可以设置JVM中每个线程的虚拟机栈的内存大小的，一般是设置为1MB(看机器)。

第二块可能发生OOM的区域，就是每个线程的虚拟机栈内存。

#### 堆内存：放我们创建的各种对象
执行方法会频繁的创建各种各样的对象，这些对象都是放在堆内存里的 ,JVM中分配给堆内存的空间其实一般是固定的

所以,第三块可能发生内存溢出的区域，就是堆内存空间！

### 073、Metaspace区域是如何因为类太多而发生内存溢出的？

#### Metaspace区域是如何触发内存溢出的？
这两个参数就是用来设置Metaspace区域大小的：
````
-XX:MetaspaceSize=512m
-XX:MaxMetaspaceSize=512m
````
一旦JVM不停地加载类，加载了很多很多的类，然后Metaspace区域放满了

Metaspace区域满就会触发Full GC，Full GC会带着一块 进行Old GC就是回收老年代的，也会带着回收年轻代的Young GC。当然，Full GC的时候，必然会尝试回收Metaspace区域中的类

无用的类：同时满足以下 3 个条件的类。
+ 该类的所有实例已被回收，Java 堆中不存在该类的任何实例；
+ 加载该类的 Classloader 已被回收；
+ 该类的 Class 对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。

#### 到底什么情况下会发生Metaspace内存溢出？
一般都是因为两个原因：
+ 第一种原因，很多工程师他不懂JVM的运行原理，在上线系统的时候对Metaspace区域直接用默认的参数，即根本不设置其大小

    这会导致默认的Metaspace区域可能才几十MB而已，此时对于一个稍微大型一点的系统，因为他自己有很多类，还依赖了很多外部的jar包有有很多的类，几十MB的Metaspace很容易就不够了

+ 第二种原因，就是很多人写系统的时候会用cglib之类的技术动态生成一些类，一旦代码中没有控制好，导致你生成的类过于多的时候，就很容易把Metaspace给塞满，进而引发内存溢出

### 074、无限制的调用方法是如何让线程的栈内存溢出的？

#### 一个线程调用多个方法的入栈和出栈

方法的调用,局部变量等都是放在栈帧里面的, 方法执行完毕之后,从栈里面弹出

#### 一个重要的概念：每次方法调用的栈桢都是要占用内存的
每次方法调用的栈桢实际上也是会占用内存的！

#### 到底什么情况下会导致JVM中的栈内存溢出？
既然一个线程的虚拟机栈内存大小是有限的，比如1MB，那么假设你不停的让这个线程去调用各种方法，然后不停的把方法调用的栈桢压入栈中

自然会溢出, 典型就是递归

#### 一般什么情况下会发生栈内存溢出？
> 典型就是递归

一般来说，其实引发栈内存溢出，往往都是代码里写了一些bug才会导致的，正常情况下发生的比较少。

### 075、对象太多了！堆内存实在是放不下，只能内存溢出！
#### 从对象在Eden区分配开始
系统运行的时候一直不停的创建对象，然后大量的对象会填满Eden区

一旦Eden区满之后，就会触发一次Young GC，然后存活对象进入S区。

#### 高并发场景下导致ygc后存活对象太多
一旦出现了高并发场景，导致ygc后很多请求还没处理完毕，存活对象太多，可能就在Survivor区域放不下了，此时就只能进入到老年代里去了，老年代很快就会放满了 ,一旦老年代放满了就会触发Full GC

ygc过后有一批存活对象，Survivor放不了，此时就等着要进入老年代里，然后老年代也满了，那么就得等着老年代进行CMS GC，必须回收掉一批对象，才能让年轻代里存活下来的一批对象进去。

Full GC 还是放不下 ,就OOM了

#### 什么时候会发生堆内存的溢出？
一般来说发生内存溢出有两种主要的场景：
+ 系统承载高并发请求，因为请求量过大，导致大量对象都是存活的，所以要继续放入新的对象实在是不行了，此时就会引发OOM系统崩溃
+ 系统有内存泄漏的问题，就是莫名其妙弄了很多的对象，结果对象都是存活的，没有及时取消对他们的引用，导致触发GC还是无法回收，此时只能引发内存溢出，因为内存实在放不下更多对象了

因此总结起来，一般引发OOM，要不然是系统负载过高，要不然就是有内存泄漏的问题

### 076、动手实验：自己模拟出JVM Metaspace内存溢出的场景体验一下！
<img src="https://s1.ax1x.com/2020/07/15/U01YPf.jpg" alt="U01YPf.jpg" border="0" />

#### Metaspace内存溢出原理
如果我们在程序里不停的动态生成类，就会导致不停的加载类到Metaspace区域里去，而且这些动态生成的类必须还得是不能被回收掉的。

接着一旦Metaspace区域满了，就会触发Full GC连带着回收Metaspace中的类，但是此时大量的类是不能被回收的。

因此即使触发过Full GC过后，Metaspace区域几乎还是不能放下任何一个类，此时必然会触发Metaspace区域的内存溢出，导致JVM也是崩溃掉，无法继续运行了

#### 到底什么是动态生成类？
借助一些方法在系统运行的时候，通过程序动态的生成出更多的类了 比如cglib ,asm,javassit

#### 动态生成类的代码示例
 
 看下原来的 javassit和asm 吧
 
#### 限制Metaspace大小看看内存溢出效果
 
我们把这个程序的JVM中的Metaspace区域设置为仅仅10m：
>-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m 
 
 一直while 循环动态生成
 
 异常中有如下的一个：
 
 >Caused by: java.lang.OutOfMemoryError: Metaspace。
 
 这个OutOfMemoryError就是经典的内存溢出的问题，而且他明确告诉你，是Metaspace这块区域内存溢出了。
 
 而且大家可以看到，一旦内存溢出，本来在运行的JVM进程直接会崩溃掉，你的程序会退出，这就是真实的内存溢出的日志。
 
 ### 077、动手实验：自己模拟出JVM栈内存溢出的场景体验一下！
 #### 原理
 一般发生这种情况，只有一个原因，就是你的代码有bug，出现了死循环调用，或者是无限制的递归调用，最后连续调用几万次之后，栈内存就溢出了，没法放入更多的方法栈桢了。
 
 #### 模拟
写个递归,不要结束

会看到如下所示的打印输出：

目前是第5675次调用方法
>java.lang.StackOverflowError

也就是说，当这个线程调用了5675次方法之后，他的栈里压入了5675个栈桢，最终把1MB的栈内存给塞满了，引发了栈内存的溢出。大家看到StackOverflowError，就知道是线程栈内存溢出了。

### 079、案例实战：一个超大数据量处理系统是如何不堪重负OOM的？
> 还是那个超大数据量处理系统的案例  一个非常复杂的PB级数据计算系统，远比很多流行的开源技术要强悍，架构上也非常复杂，同时处理的数据量也特别大。

> 这个系统会不停的加载数据到内存里来计算，每次少则加载几十万条数据，多则加载上百万条数据，所以系统的内存负载压力是非常大的。

>这个系统每次加载数据到内存里计算完毕之后，就需要将计算好的数据推送给另外一个系统，两个系统之间的数据推送和交互，最适合的就是基于消息中间件来做
因此当时就选择了将数据推送到Kafka，然后另外一个系统从Kafka里取数据

#### 针对Kafka故障设计的高可用场景
刚开始负责这块的工程师选择了一个思考欠佳的技术方案。一旦发现Kafka故障，就会将数据都留存在内存里，不停的重试，直到Kafka恢复才可以

这个时候就有一个隐患了，万一真的遇上Kafka故障，那么一次计算对应的数据必须全部驻留内存，无法释放，一直重试等待Kafka恢复，这是绝对不合理的一个方案设计。

然后数据计算系统还在不停的加载数据到内存里来处理，每次计算完的数据还无法推送到Kafka，全部得留存在内存里等着，如此循环往复，必然导致内存里的数据越来越多

#### 无法释放的内存最终导致OOM
内存里的数据必然越来越多，每次Eden区塞满之后，大量存活的对象必须转入老年代中，而且这些老年代里的对象还是无法释放掉的。

老年代最终一定会满，而且最终一定会有一次Eden区满之后，一大批对象要转移到老年代，结果老年代即使Full gc之后还是没有空间可以放的下，最终就会导致内存溢出。然后线上收到报警说内存溢出

#### 方案
取消了Kafka故障下的重试机制，一旦Kafka故障，直接丢弃掉本地计算结果，允许释放大量数据占用的内存。

将这个机制优化为一旦Kafka故障，则计算结果写本地磁盘，允许内存中的数据被回收。

### 080、案例实战：两个新手工程师误写代码是如何导致OOM的？
#### 第一个案例：一时迷糊写出了一个无限循环调用
> 一个代码上的bug导致线上系统出现栈内存溢出的场景。

代码
````
    try{
        // 业务逻辑
        log();
    } catch (Exceptin e){
        log();
    }
    public void log(){
        try{
            // 写入日志
        }catch(Exception e){
            log();
        }
    }
````


#### 第二个案例：没有缓存的动态代理
无缓存
<a href="https://imgchr.com/i/U0tYin"><img src="https://s1.ax1x.com/2020/07/15/U0tYin.jpg" alt="U0tYin.jpg" border="0" /></a>

有缓存
<img src="https://s1.ax1x.com/2020/07/15/U0t0LF.jpg" alt="U0t0LF.jpg" border="0" />

其实这个类只要生成一次就可以了，下次来直接用这个动态生成的类创建一个对象就可以了。

### 081、如何对对线上系统的OOM异常进行监控和报警！
#### 最佳的解决方案
最佳的OOM监控方案，其实说白了也很简单，之前一直给大家强调，公司最好是应该有一种监控平台，比如Zabbix、Open-Falcon之类的监控平台。

有监控平台的话，就可以接入系统异常的一些监控和报警，你可以设置一旦系统出现了OOM异常，就发送报警给对应的开发人员，通过邮件、短信或者钉钉之类的IM工具。

一般来说我们都对线上系统有以下几个层面的监控：

    机器（CPU、磁盘、内存、网络）资源的负载情况，JVM的GC频率和内存使用率，系统自身的业务指标，系统的异常报错
   
#### 一个比较成熟的系统监控体系的建议
线上机器最容易出问题的主要三大块
+ 一个是CPU，必须要对CPU的使用率做一个监控，如果CPU负载过高，比如长期使用率超过90%，就得报警了；

+ 一个是内存，同样得监控内存的使用率，如果机器内存长期使用率超过了一定的阈值，比如长期使用率超过90%，那肯定是有问题的，随时机器内存可能就不够了；

+ 一个是JVM的Full GC问题，假设5分钟内发生了10次Full GC，那一定是频繁Full GC了。

另外比较常见的就是对系统的业务指标的监控，比如你可以在每次系统创建一个订单就上报一次监控，然后监控系统会收集你1分钟内的订单数量。然后你可以设定一个阈值，比如1分钟内要是订单数量超过了100就报警。

因为可能订单过多涉及到了一些刷单之类的行为，这就是业务系统的指标监控，这个都是你自己去进行指标上报的。

最后一个，就是系统所有的try catch中的异常报错，必须要接入报警，一旦有异常，都需要上报到监控平台，然后监控平台会告诉你，最近有一次异常，只要系统报错，你立马可以收到报警。

因此非常核心的一点，就是要对线上系统的异常进行监控，一旦JVM有OOM之类的问题可以立马感知到。

#### 一种比较Low的JVM OOM问题的被动发现方法

被动发现OOM问题，主要靠两个：

+ 第一个是线上系统假设因为OOM突然挂掉，此时一定会导致用户无法使用，然后迅速反馈到客服，客服反馈给你，你就知道自己的系统挂掉了。

+ 第二个就是你必须去检查一下系统的线上日志，一般来说，系统有异常的时候，必须通过log4j之类的日志框架写入本地日志文件，如果这个都不做，那实在是没办法说什么了。只要你检查日志，就会发现之前给大家演示过的OOM问题。

### 082、一个关键问题：如何在JVM内存溢出的时候自动dump内存快照？
#### 解决OOM问题的一个初步思路
首先第一个问题，假设发生OOM了，必然说明系统中某个区域的对象太多了，塞满了那个区域，而且一定是无法回收掉那些对象，最终才会导致内存溢出的。

首先就得知道到底是什么对象太多了最终导致OOM的？所以你想知道什么对象太多导致OOM的，就必须得有一份JVM发生OOM时的dump内存快照

#### 在OOM的时候自动dump内存快照
VM的启动参数中加入如下的一些参数：
 ````
-XX:+HeapDumpOnOutOfMemoryError  
-XX:HeapDumpPath=/usr/local/app/oom
  ````
第一个参数意思是在OOM的时候自动dump内存快照出来，第二个参数是说把内存快照放到哪儿去

只要你加入了这两个参数，在JVM OOM崩溃的时候，无论你是立马主动收到一个报警，还是被动让客服通知了你，立马就可以去找OOM时候的内存快照了。

#### 迄今为止我们可以得出的一份JVM参数模板
````
    -Xms4096M -Xmx4096M -Xmn3072M -Xss1M  -XX:MetaspaceSize=256M 
    -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC 
    -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection 
    -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelInitialMarkEnabled 
    -XX:+CMSScavengeBeforeRemark -XX:+DisableExplicitGC -XX:+PrintGCDetails 
    -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/usr/local/app/oom”
````
首先是各个内存区域的大小分配，这个是需要你精心调优的

其次是两种垃圾回收器的指定，接着是一些常规性的CMS垃圾回收的参数，可以帮助优化偶尔发生的Full GC性能。

最重要的，就是平时要打印出来GC日志，GC日志可以配合你用jstat工具分析GC频率和性能的时候用，jstat可以分析出来GC的频率，但是对每次具体的GC情况，可以结合GC日志来看。

还有就是在OOM的时候需要自动dump内存快照，这样即使突然发生OOM，你只要得知了这个事，立马就可以去分析内存快照了

### 083、动手实验：Metaspace区域内存溢出的时候，应该如何解决？
> 还是动态生态类 溢出的模拟
````
-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC
-XX:MetaspaceSize=10m
-XX:MaxMetaspaceSize=10m
-XX:+PrintGCDetails
-Xloggc:gc.log
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=./
````

#### 分析GC日志
````
0.771: [Full GC (Metadata GC Threshold) 0.771: [CMS: 0K->2161K(349568K), 0.0721349 secs] 20290K->2161K(506816K),
[Metaspace: 9201K->9201K(1058816K)], 0.0722612 secs] [Times: user=0.12 sys=0.03, real=0.08 secs]
````
不看ParNew GC，这就是Full GC了，而且通过“Metadata GC Threshold”清晰看到，是Metaspace区域满了，所以触发了FullGC

这个时候看下面的日志，20290K->2161K(506816K)，这个就是说堆内存（年轻代+老年代）一共是500MB左右，然后有20MB左右
的内存被使用了，这个必然是年轻代用的。

然后Full GC必然会带着一次Young GC，因此这次Full GC其实是执行了ygc了，所以回收了很多对象，剩下了2161KB的对象，这个大
概就是JVM的一些内置对象了。

然后直接就把这些对象放入老年代，为什么呢，因为下面的日志：[CMS: 0K->2161K(349568K), 0.0721349 secs]
这里明显说了，Full GC带着CMS进行了老年代的Old GC，结果人家本来是0KB，什么都没有，然后从年轻代转移来了2161KB的对
象，所以老年代变成2161KB了。

接着看日志： [Metaspace: 9201K->9201K(1058816K)]
此时Metaspace区域已经使用了差不多9MB左右的内存了，此时明显是发现离我们限制的10MB内存很接近了，所以触发了Full GC，
但是对Metaspace GC后发现类全部存活了，因此还是剩余9MB左右的类在Metaspace里。
````
0.843: [Full GC (Last ditch collection) 0.843: [CMS: 2161K->1217K(349568K), 0.0164047 secs] 2161K->1217K(506944K),
[Metaspace: 9201K->9201K(1058816K)], 0.0165055 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]
````
接着又是这次Full GC，人家也说的很清晰了，Last ditch collection

就是说，最后一次拯救的机会了，因为之前Metaspace回收了一次但是没有类可以回收，所以新的类无法放入Metaspace了。

所以再最后试一试Full GC，能不能回收掉一些
结果如下：[Metaspace: 9201K->9201K(1058816K)], 0.0165055 secs]

Metaspace区域还是无法回收掉任何的类，几乎还是占满了我们设置的10MB左右。
 ````
0.860: [GC (CMS Initial Mark) [1 CMS-initial-mark: 1217K(349568K)] 1217K(506944K), 0.0002251 secs] [Times: user=0.00
sys=0.00, real=0.00 secs]
0.860: [CMS-concurrent-mark-start]
0.878: [CMS-concurrent-mark: 0.003/0.018 secs] [Times: user=0.05 sys=0.01, real=0.02 secs]
0.878: [CMS-concurrent-preclean-start]
Heap
par new generation total 157376K, used 6183K [0x00000005ffe00000, 0x000000060a8c0000, 0x0000000643790000)
 eden space 139904K, 4% used [0x00000005ffe00000, 0x0000000600409d48, 0x00000006086a0000)
 from space 17472K, 0% used [0x00000006086a0000, 0x00000006086a0000, 0x00000006097b0000)
 to space 17472K, 0% used [0x00000006097b0000, 0x00000006097b0000, 0x000000060a8c0000)
concurrent mark-sweep generation total 349568K, used 1217K [0x0000000643790000, 0x0000000658cf0000,
0x00000007ffe00000)
Metaspace used 9229K, capacity 10146K, committed 10240K, reserved 1058816K
 class space used 794K, capacity 841K, committed 896K, reserved 1048576K
````
接着就直接JVM退出了，退出的时候就打印出了当前内存的一个情况，年轻代和老年代几乎没占用，但是Metaspace的capacity是
10MB，使用了9MB左右，无法再继续使用了，所以触发了内存溢出。

此时就会在控制台打印出如下的一行东西：
```Caused by: java.lang.OutOfMemoryError: Metaspace
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
... 11 more
````
明确抛出异常，说OutOfMemoryError，原因就是Metaspace区域满了导致的。

#### 分析内存快照

分析内存快照文件 ,会发现实例最多的就是AppClassLoader

解决这个问题的办法也很简单，直接对Enhancer做一个缓存，只有一个，不要无限制的去生成类就可以了。

### 084、动手实验：JVM栈内存溢出的时候，应该如何解决？
> 还是原来栈溢出 的模拟

参数
````
-XX:ThreadStackSize=1m
-XX:+PrintGCDetails
-Xloggc:gc.log
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=./
-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC
````

#### 运行代码后分析异常报错信息的调用栈
     
报错，如下：
````
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
at com.limao.demo.jvm.Demo2.work(Demo2.java:13)
  ````
  直接去日志文件里看到是栈内存溢出：Exception in thread "main" java.lang.StackOverflowError。

  此时心里就有数了，然后直接看一下对应报错的方法就可以了。知道是哪个方法，直接去代码中定位问题即可。
  
  
 ### 085、动手实验：JVM堆内存溢出的时候，应该如何解决？
 > 还是循环 生成对象的模拟
 
 参数
 ````
 -Xms10m
 -Xmx10m
 -XX:+PrintGCDetails
 -Xloggc:gc.log
 -XX:+HeapDumpOnOutOfMemoryError
 -XX:HeapDumpPath=./
 -XX:+UseParNewGC
 -XX:+UseConcMarkSweepGC
 ````
 
 #### 运行后的观察
 日志
 ````
 java.lang.OutOfMemoryError: Java heap space
 Dumping heap to ./java_pid1023.hprof ...
 Heap dump file created [13409210 bytes in 0.033 secs]
 Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
 ````
  这个就很明显告诉我们，是Java堆内存溢出了，而且他还给我们导出了一份内存快照
  
#### 分析
先看占用内存最多的对象是谁，然后分析那个线程的调用栈，接着就可以看到是哪个方法引发的内存溢出了。接着优化代码即可。


### 086、案例实战：每秒仅仅上百请求的系统为什么会因为OOM而崩溃？
#### 系统发生OOM的生产现场
一旦JVM发生了OOM，将会导致系统直接崩溃掉，因为OOM代表的是JVM本身已经没办法继续运行了！

第一件事情：一定是登录到线上机器去看日志，而不是做别的事情。
当时在机器的日志文件中看到类似下面的一句话：
>Exception in thread "http-nio-8080-exec-1089" java.lang.OutOfMemoryError: Java heap space

但凡对Tomcat的底层工作原理有一定了解的朋友，应该立马就会反映过来了，这里的“http-nio-8080-exec-1089”说的其实就是Tomcat的工作线程。

而后面的“java.lang.OutOfMemoryError: Java heap space”大家如果认真学习了之前的内容，都很清楚，指的是堆内存溢出的问题。

所以连起来看，这段日志的意思，就是Tomcat的工作线程在处理请求的时候需要在堆内存里分配对象，但是发现堆内存塞满了，而且根本没办法回收任何一点多余的对象，此时实在没办法在堆内存里放下更多对象了，报了这个异常

#### Tomcat的底层原理
Tomcat自己就是一个JVM进程，我们写好的系统只不过是一些代码而已

这些代码就是一个一个的类，这些类被Tomcat加载到内存里去，然后由Tomcat来执行我们写的类。

Tomcat有自己的工作线程，大家务必要对Tomcat的工作线程这个概念有一个认识，即Tomcat有很多自己的工作线程，少则一两百个，多则三四百个也是可以的。

然后从8080端口上收到的请求都会均匀的分配给这些工作线程去进行处理，而这些工作线程收到请求之后，就负责调用Spring MVC框架的代码，Spring MVC框架又负责调用我们自己写好的代码，比如一些Controller类之类的

#### 异常日志
Tomcat工作线程，因为是他负责调用Spring MVC以及我们写的Controller、Service、DAO等一大堆的代码的，所以他发现运行的时候堆内存不够了，就会抛出来堆内存溢出的异常了。

#### 不要忘了一个关键的JVM参数
查错主要有两点：

1、看看到底是堆内存溢出？还是栈内存溢出？或者是Metaspace内存溢出？首先得确定一下具体的溢出类型

2、看看是哪个线程运行代码的时候内存溢出了。因为Tomcat运行的时候不光有自己的工作线程，我们写的代码也可能会创建一些线程出来

这时候务必得设置一个参数：
>-XX:+HeapDumpOnOutOfMemoryError

#### 对内存快照进行分析
可以继续查看一下这个数组是被谁引用的，大致可以发现是Tomcat的类引用的，具体来说是类似下面的这个类：
>org.apache.tomcat.util.threads.TaskThread

这个类一看就是Tomcat自己的线程类，因此可以认为是Tomcat的线程创建了大量的byte[]数组，占据了8G的内存空间。


之前的文章给大家提到过，MAT中可以查看具体有哪些线程存在，其实MAT使用很方便，也并不难，大家在实际使用的时候，自己多摸索，多点一点，多尝试，就会逐渐摸熟他的使用方式 。最关键的，是掌握分析的思路。

此时我们发现Tomcat的工作线程大致有400个左右，也就是说每个Tomcat的工作线程会创建2个byte[]数组，每个byte[]数组是10MB左右

最终就是400个Tomcat工作线程同时在处理请求，结果创建出来了8G内存的byte[]数组，进而导致了内存溢出。

#### 系统每秒QPS才只有100？！！
明明每秒才100个请求，怎么可能Tomcat的400个线程都处于工作状态？

说明每个请求处理需要4秒钟的时间！

Tomcat的配置文件有一个配置：
>max-http-header-size: 10000000

这个东西，导致Tomcat工作线程在处理请求的时候会创建2个数组，每个数组的大小如上面配置就是10MB。

#### 为什么处理一个请求需要4秒钟？
通过RPC调用其他系统的时候突然出现了大量的请求超时，立马翻看一下系统的RPC调用超时的配置，惊讶的发现，负责这个系统的工程师居然将服务RPC调用超时时间设置为了刚好是4秒！

#### 对系统进行优化
最核心的问题就是那个超时时间设置的实在太长了，因此立马将超时时间改为1秒即可。

另外一个，对Tomcat的那个参数，max-http-header-size，可以适当调节的小一些就可以了，这样Tomcat工作线程自身为请求创建的数组，不会占据太大的内存空间的。

### 087、案例实战：Jetty 服务器的 NIO 机制是如何导致堆外内存溢出的？

#### 案例发生现场
日志中发现了如下的一些信息：
````
nio handle failed java.lang.OutOfMemoryError: Direct buffer memory
at org.eclipse.jetty.io.nio.xxxx
at org.eclipse.jetty.io.nio.xxxx
at org.eclipse.jetty.io.nio.xxxx   
````

Direct buffer memory，而且在下面我们还看到一大堆的jetty相关的方法调用栈

#### 初步分析事故发生的原因
Direct buffer memory，就是直接内存的意思。但是如果我们叫他直接内存，又显得非常的奇怪，所以通常更好的称呼就是“堆外内存”。

Jetty本身也是Java写的，我们如果写好了一个系统，可以打包后放入Jetty，启动Jetty即可。

Jetty启动之后，本身就是一个JVM进程，他会监听一个端口号，比如说9090

然后你就向Jetty监听的9090端口发送请求，Jetty会把请求转交给你用的Spring MVC之类的框架，Spring MVC之类的框架再去调用写好的Controller之类的代码。

基本可以推测出来，Jetty服务器可能在不停的使用堆外内存，然后堆外内存空间不足了，没法使用更多的堆外内存了，此时就会抛出内存溢出的异常。


####  堆外内存是如何申请的，又是如何释放的？
如果在Java代码里要申请使用一块堆外内存空间，是使用DirectByteBuffer这个类，你可以通过这个类构建一个DirectByteBuffer的对象，这个对象本身是在JVM堆内存里的。

但是你在构建这个对象的同时，就会在堆外内存中划出来一块内存空间跟这个对象关联起来

当你的DirectByteBuffer对象没人引用了，成了垃圾对象之后，自然会在某一次young gc或者是full gc的时候把DirectByteBuffer对象回收掉。

还有可以通过反射,手动清理

#### 为什么会出现堆外内存溢出的情况？
如果你创建了很多的DirectByteBuffer对象，占用了大量的堆外内存，然后这些DirectByteBuffer对象还没有GC线程来回收掉，那么就不会释放堆外内存！

有一种可能，就是系统承载的是超高并发，复杂压力很高，瞬时大量请求过来，创建了过多的DirectByteBuffer占用了大量的堆外内存，此时再继续想要使用堆外内存，就会内存溢出了！

明显不是！因为这个系统的负载其实没有想象中的那么高，不会有瞬时大量的请求过来。

#### 真正的堆外内存溢出原因分析
老年代里的DirectByteBuffer其实很多都是可以回收的状态了，但是因为老年代一直没塞满，所以没触发full gc，也就自然不会回收老年代里的这些DirectByteBuffer了！当然老年代里这些没有被回收的DirectByteBuffer就一直关联占据了大量的堆外内存空间了！

直到最后，当你要继续使用堆外内存的时候，结果所有堆外内存都被老年代里大量的DirectByteBuffer给占用了，虽然他们可以被回收，但是无奈因为始终没有触发老年代的full gc，所以堆外内存也始终无法被回收掉。

最后就会导致内存溢出问题的发生！

#### 难道Java NIO就没考虑过这个问题吗？

他知道可能很多DirectByteBuffer对象也许没人用了，但是因为没有触发gc就导致他们一直占据着堆外内存。

所以在Java NIO的源码中会做如下处理，他每次分配新的堆外内存的时候，都会调用System.gc()去提醒JVM去主动执行以下gc去回收掉一些垃圾没人引用的DirectByteBuffer对象，释放堆外内存空间。

只要能触发垃圾回收去回收掉一些没人引用的DirectByteBuffer，就会释放一些堆外内存，自然就可以分配更多的对象到堆外内存去了。

但是我们又在JVM中设置了如下参数：
>-XX:+DisableExplicitGC

导致这个System.gc()是不生效的，因此就会导致上述的情况。

#### 最终对问题的优化

问题有两个，一个是内存设置不合理，导致DirectByteBuffer对象一直慢慢进入老年代，导致堆外内存一直释放不掉

另外一个是设置了-XX:+DisableExplicitGC导致Java NIO没法主动提醒去回收掉一些垃圾DIrectByteBuffer对象，同样导致堆外内存无法释放。

因此最终对这个项目做的事情就是：

+ 一个是合理分配内存，给年轻代更多内存，让Survivor区域有更大的空间
+ 另外一个就是放开-XX:+DisableExplicitGC这个限制，让System.gc()生效。

做完优化之后，DirectByteBuffer一般就不会不断进入老年代了。只要他停留在年轻代，随着young gc就会正常回收释放堆外内存了。

另外一个，只要你放开-XX:+DisableExplicitGC的限制，Java NIO发现堆外内存不足了，自然会通过System.gc()提醒JVM去主动垃圾回收，可以回收掉一些DirectByteBuffer释放一些堆外内存。

### 088、案例实战：一次微服务架构下的RPC调用引发的OOM故障排查实践
> 一般线上系统OOM，都不是简单的由你的代码导致的，可能是因为你系统使用的某个开源技术的内核代码有一定的故障和缺陷，
  这时你要解决OOM问题，就必须深入到开源技术的源码中去分析
  
#### 系统架构介绍
采用的是基于Thrift框架自己封装出来的一个RPC框架，可能很多朋友对Thrift之类的东西都没概念，那就不要过多的关注这个了。

大家只需要知道当时我们自己封装了一个RPC框架就可以了，然后在一个系统中，就是基于这个RPC框架去进行通信。

#### 故障发生现场
平时是服务A通过RPC框架去调用服务B，但是有一天，负责服务A的工程师更新了一些代码，然后将服务A重新上线之后，服务A自己倒是没什么，结果反而是服务B却突然宕机了！

当时我们立马登录到服务B的机器去查看服务B的日志，结果在里面赫然发现了OOM异常：
>java.lang.OutOfMemoryError Java heap space

#### 初步查找内存溢出的故障发生点

发OutOfMemory异常的，居然就是我们自研的那个RPC框架！
当时大致来说你可以看到的一个异常信息如下所示：
````
java.lang.OutOfMemoryError: Java heap space
xx.xx.xx.rpc.xx.XXXClass.read()
xx.xx.xx.rpc.xx.XXXClass.xxMethod()
xx.xx.xx.rpc.xx.XXXClass.xxMethod()
````
#### 分析内存快照找到占用内存最大的对象
此时把OOM的时候自动导出的内存快照打开分析，发现占用内存最大的是一个超大的byte[]数组！

当时我们一台机器给的堆内存也不过就是4GB而已，而在内存快照中发现，居然一个超大的byte[]数组就占据了差不多4GB的空间

#### 通过分析源代码找出原因
通过mat等 找到引用关系 ,定位代码

首先在服务A发送请求的时候，会对你传输过来的对象进行序列化。这个序列化，简单来说，就是把你的类似Request的对象变成一个byte[]数组

他首先会根据我们自定义的序列化协议（当时用的是Protobuf，很多人可能不了解这个，先别管这个了），对发送过来的数据进行反序列化

接着把请求数据读取到一个byte[]缓存中去，然后调用业务逻辑代码处理请求，最后请求处理完毕，清理byte[]缓存。

#### RPC框架的一个bug：过大的默认值！
这里RPC框架我们有一个bug，就是一旦发现对方发送过来的字节流反序列化的时候失败了，这个往往是因为服务A对Request类做了修改，但是服务B不知道这次修改，Request还是以前的版本。

结果比如服务A的Request类有15个字段，序列化成字节流给你发送过来了，服务B的Request类只有10个字段，有的字段名字还不一样，那么反序列化的时候就会失败。

当时代码中写的逻辑是，一旦反序列化失败了，此时就会开辟一个byte[]数组，默认大小是4GB，然后把对方的字节流原封不动的放进去。

所以最终的问题就出在这里了，当时服务A的工程师修改了很多Request类的字段，结果没告诉服务B的工程师。


#### 最终的解决方案
其实解决这个问题的办法很简单，把RPC框架中那个数组的默认值从4GB调整为4MB即可，一般请求都不会超过4MB，不需要开辟那么大的数组。

另外就是让服务A和服务B的Request类定义保持一致即可。

### 089、案例实战：一次没有WHERE条件的SQL语句引发的OOM问题排查实践！
#### 案例背景引入
在使用mybatis写SQL语句的时候在某些情况下允许不加where条件就可以执行，结果导致一下子查询出来上百万条数据引发了系统的OOM。

#### 故障发生现场
某一天突然我们收到反馈说线上一个系统崩溃不可用了，此时当然是立即登录到线上机器去查看日志了，在日志中果然发现了OOM的异常：java.lang.OutOfMemoryError，java heap space。

堆内存溢出了，那我们下一步肯定是把自动导出的内存快照拷贝到自己电脑上，用MAT去分析对应的内存快照了

#### 第一步：检查内存中到底是什么对象太多了
我们可以用MAT中的一个Histogram功能，去检查一下占用内存最多的对象有哪些

#### 第二步：深入看看占用内存过多的对象
你可以深入的看看占用内存过多的对象是被谁引用的，哪个线程引用的，他们里面都是什么东西

#### 生产案例的追踪
追踪到这里，发现某个Tomcat的工作线程创建了一大堆的java.lang.HashMap，那么这些java.lang.HashMap中是什么？

我们发现全都是各种从数据库里查出来的字段，你只要展开那个HashMap就能看到你出来放入内存的所有数据。

所以看到这一步基本就很明确了，就是Tomcat的工作线程处理一个请求的时候，发起了一个SQL语句，查出来了大量的数据，每条数据是一个HashMap，就是这大量的数据导致了系统的OOM。

#### 第三步：到底是哪一行代码创建了这么多的对象？

找到占用内存最大的对象之后，最后一步就是要定位一下是哪一行代码，或者是哪个方法创建了那么多的对象？

#### 继续对生产案例进行追踪
当时我们对生产案例进行追踪，立马就定位到了是系统中的一个业务方法，在执行查询操作的时候，因为没有带上WHERE条件，直接查询出来了全部的上百万的数据，导致了内存的溢出。

此时就直接对那个方法对应的SQL语句进行修改即可，要求他必须每次都带上WHERE条件。

### 090、本周思考题
1. 结合自己公司系统的业务来分析，遇到内存溢出该怎么处理？
2. 如果你的线上系统数据量猛增100倍，会出现OOM问题吗？
3. 对自己的线上系统，导出一份内存快照分析一下

### 091、本周答疑问题汇总！
  >
  
  
### 092、案例实战：每天10亿数据的日志分析系统的OOM问题排查实践！
一个每天10亿数据量的日志清洗系统，这个系统做的事情其实非常的简单，他主要就是从Kafka中不停的消费各种日志数据，然后对日志的格式进行很多清洗，比如对一些涉及到用户敏感信息的字段（姓名、手机号、身份证号）进行脱敏处理，然后把清洗后的数据交付给其他的系统去使用。


#### 事故发生现场
日志里
````
java.lang.OutOfMemoryError: java heap space
xx.xx.xx.log.clean.XXClass.process()
xx.xx.xx.log.clean.XXClass.xx()
xx.xx.xx.log.clean.XXClass.xx()
xx.xx.xx.log.clean.XXClass.process()
xx.xx.xx.log.clean.XXClass.xx()
xx.xx.xx.log.clean.XXClass.xx()
xx.xx.xx.log.clean.XXClass.process()
xx.xx.xx.log.clean.XXClass.xx()
xx.xx.xx.log.clean.XXClass.xx()
````

通过日志，有经验的朋友可能已经可以发现一个问题了，那就是在某一处代码出现了大量的递归操作。正是大量的递归操作之后，也就是反复调用一个方法之后，导致了堆内存溢出的问题。

#### 初步分析内存快照
，在分析的时候，我们就发现了一个问题，因为有大量的XXClass.process()方法的递归执行，每个XXClass.process()中都创建了大量的char数组！

#### 功夫在诗外：问题在JVM参数上
递归调用加起来创建的char[]数组对象总和其实也就最多1G而已。

如果是这样的话，其实我们应该先注意一个问题，那就是可能这次OOM的发生不一定是代码就写的有多么的烂，可能就是我们的JVM的内存参数设置的不对，给堆内存分配的空间太小了！

#### 分析一下JVM的GC日志
核心的内容如下所示：
>-Xmx1024m -Xms1024m  -XX:+PrintGCDetails -XX:+PrintGC()  -XX:+HeapDumpOnOutOfMemoryError -Xloggc:/opt/logs/gc.log -XX:HeapDumpPath=/opt/logs/dump

gc.log日志。
````
[Full GC (Allocation Failure)  866M->654M(1024M)]
[Full GC (Allocation Failure)  843M->633M(1024M)]
[Full GC (Allocation Failure)  855M->621M(1024M)]
[Full GC (Allocation Failure)  878M->612M(1024M)]
````

发现每次Full GC都只能回收掉一点点对象，发现堆内存几乎都是占满了。

另外我们这里没有显示时间，当时日志里显示的是每秒钟都会执行一次Full GC，这个就很可怕了。基本上我们可以明确一点，应该是在系统运行的时候，因为XXClass.process()方法不停递归创建了大量的char[]数组，导致堆内存几乎是塞满的。

但是每次full gc只能回收少量对象，直到最后可能某一次full gc回收不掉任何对象了，然后新的对象无法放入堆内存了，此时就会触发OOM内存溢出的异常

#### 分析一下JVM运行时内存使用模型
````
S0 S1 E O YGC FGC

0 100 57 69 36 0
0 100 57 69 36 0
0 100 65 69 37 0
0 100 0 99 37 0
0 100 0 87 37 1
````

部分信息大家就可以看出来问题所在了，刚开始都是年轻代的Eden区在涨，接着YGC从36到37，就是发生了一次YGC，接着Old区直接从占比69%到99%

说明YGC后存活对象太多，Survivor放不下，直接进老年代了！

接着老年代都占了99%了，直接就触发了一次Full GC，但是也仅仅让老年代从占比99%到87%而已，回收了少量的对象。

#### 优化第一步：增加堆内存大小
所以这个OOM的问题，说白了不能直接说是代码问题，从JVM运行情况以及内存大小来看，就是内存分配不足的问题。

#### 优化第二步：改写代码

另外就是改写代码，让他不要占用过多的内存。当时代码之所以递归，就是因为在一条日志中，可能会出现很多用户的信息，一条日志也许会合并包含了十几个到几十个用户的信息。

这个时候代码中就是会递归十几次到几十次去处理这个日志，每次递归都会产生大量的char[]数组，是切割了日志用来处理的。

其实这个代码写的完全没有必要，因为对每一条日志，如果发现包含了多个用户的信息，其实就对这一条日志切割出来进行处理就可以了，完全没有必要递归调用，每次调用都切割一次日志，生成大量的char[]数组。

所以把这一步代码优化了之后，一下子发现线上系统的内存使用情况降低了10倍以上

### 093、案例实战：一次服务类加载器过多引发的OOM问题排查实践！
一个非常正常的线上的服务，采用的是Web系统部署在Tomcat中的方式来进行启动的。

但是有一段时间，我们突然收到一些反馈，说是这个服务非常的不稳定，经常会出现访问这个服务的接口的时候出现服务的假死问题。

#### 使用top命令检查机器资源使用
首先要考虑的是两种问题。

+ 第一种问题：这个服务可能使用了大量的内存，内存始终无法释放，因此导致了频繁GC问题。

    也许每秒都执行一次Full GC，结果每次都回收不了多少，最终导致系统因为频繁GC，频繁Stop the World，接口调用出现频繁假死的问题。

+ 第二种问题：可能是这台机器的CPU负载太高了，也许是某个进程耗尽了CPU资源，导致你这个服务的线程始终无法得到CPU资源去执行，也就无法响应接口调用的请求。这也是一种情况。

此时JVM进程其实耗费的总内存就接近6G了，另外你还得给操作系统内核以及其他的进程留出一部分的内存空间去使用。

因此最终让你的JVM可以使用的堆内存大概也就是机器上一半的内存而已。

#### 在内存使用这么高的情况下会发生什么？
既然这个服务的进程对内存使用率这么高，可能发生的问题也就三种。

+ 第一种是内存使用率居高不下，导致频繁的进行full gc，gc带来的stop the world问题影响了服务。
+ 第二种是内存使用率过多，导致JVM自己发生OOM。
+ 第三种是内存使用率过高，也许有的时候会导致这个进程因为申请内存不足，直接被操作系统把这个进程给杀掉了！

#### 到底是谁占用了过多的内存？

导出了一份内存快照进行分析。

此时用MAT进行内存快照分析的时候，我们发现，居然是一大堆的ClassLoader也就是类加载器，有几千个，而且这些类加载器加载了的东西，都是大量的byte[]数组，所有这些一共占用了超过50%的内存。

当时写这个系统代码的工程师做了自定义类加载器，而且在代码里没有限制的创建了大量的自定义类加载器，去重复加载了大量的数据，结果经常一下子就把内存耗尽了，进程就被杀掉了！

因此解决这个问题非常的简单，直接就是修改代码，避免重复创建几千个自定义类加载器，避免重复加载大量的数据到内存里来，就可以了

### 094、案例实战：一个数据同步系统频繁OOM内存溢出的排查实践
线上有一个数据同步系统，是专门负责从另外一个系统去同步数据的，简单来说，另外一个系统会不停的发布自己的数据到Kafka中去，然后我们有一个数据同步系统就专门从Kafka里消费数据，接着保存到自己的数据库中去，大概就是这样的一个流程。

结果就这么一个非常简单的系统，居然时不时就报一个内存溢出的错误，然后就得重启系统，过了一段时间又会再次内存溢出一下。

#### 经验丰富的工程师：从现象看到本质
很可能就是随着时间推移，有某种对象越来越多，赖在内存里了。然后不断的触发gc，结果每次gc都回收不掉这些对象。

一直到最后，内存实在不足了，就会内存溢出

#### 通过jstat来确认我们的推断
老年代的对象一直在增长，不停的在增长。每次Young GC过后，老年代的对象就会增长不少。

而且当老年代的使用率达到100%之后，我们发现会正常触发Full GC，但是Full GC根本回收不掉任何对象，导致老年代使用率还是100%！

然后老年代使用率维持100%一段时间过后，就会报内存溢出的问题，因为再有新的对象进入老年代，实在没有空间放他了！

#### 通过MAT找到占用内存最大的对象！
有一个队列数据结构，直接引用了大量的数据，就是这个队列数据结构占满了内存！

从Kafka消费出来的数据会先写入这个队列，接着从这个队列再慢慢写入数据库中，主要是要额外做一些中间的数据处理和转换，所以自己在中间又加了一个队列。

一个典型的对生产和消费的速率没控制好的例子。

从Kafka里消费出来数据放入队列的速度很快，但是从队列里消费数据进行处理，然后写入存储的速度较慢，最终会导致内存队列快速积压数据，导致内存溢出。

而且这种队列每个元素都是一个List的做法，会导致内存队列能容纳的数据量大幅度膨胀。

最终解决这个问题也很简单，把上述内存队列的使用修改了一下，做成了定长的阻塞队列。

比如最多1024个元素，然后每次从Kafka消费出来数据，一条一条数据写入队列，而不是做成一个List放入队列作为一个元素。

因此这样内存中最多就是1024个数据，一旦内存队列满了，此时Kafka消费线程就会停止工作，因为被队列给阻塞住了。不会让内存队列中的数据过多。


### 095、总复习：线上系统的JVM参数优化、GC问题定位排查、OOM分析解决
主要就是三个部分：

第一个是JVM运行我们写好的系统最根本的工作原理，包括：

+ 内存各个部分的划分
+ 代码在执行的过程中，各个内存区域是如何配合协调工作的
+ 对象是如何分配的
+ GC如何触发
+ GC执行的原理是什么
+ 常见的用于控制JVM工作行为的一些核心参数都有哪些

第二个是对于一个写好的系统，我们应该如何通过预估的方法给他设置一些相对合理的JVM参数，然后在测试的时候如何合理的优化调整JVM的参数

第三个是对于一个生产运行的系统，如果出现了OOM内存溢出问题，我们应该采用一种什么样的方式来进行分析、定位和解决？

### 096、专栏彩蛋：面试中如何展现自己的JVM实战经验？
第一个是你们生产环境的系统的JVM参数怎么设置的？为什么要这么设置？

还有一个是你在生产环境中的JVM优化经验可以聊聊？

另外一个是说说你在生产环境解决过的JVM OOM问题？


