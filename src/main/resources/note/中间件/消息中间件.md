####  内容是极客消息队列的笔记


### 01 | 为什么需要消息队列？
<p> 三种场景：异步处理、流量控制和服务解耦  (后端 常用技巧 缓存,削峰 ,填谷)
<p>还有：

<li>作为发布 / 订阅系统实现一个微服务级系统间的观察者模式；
<li>连接流计算任务和数据；
<li>用于将消息广播给大量接收者。
<p>简单的说，我们在单体应用里面需要用队列解决的问题，在分布式系统中大多都可以用消息队列来解决。
<p>同时我们也要认识到，消息队列也有它自身的一些问题和局限性，包括：
<li>引入消息队列带来的延迟问题；
<li>增加了系统的复杂度；
<li>可能产生数据不一致的问题。

###   02 | 该如何选择消息队列？
<p> 1. RabbitMQ
<p> RabbitMQ 一个比较有特色的功能是支持非常灵活的路由配置，和其他消息队列不同的是，它在生产者（Producer）和队列（Queue）之间增加了一个 Exchange 模块，你可以理解为交换机。
<p>问题。
   
<li>   第一个问题是，RabbitMQ 对消息堆积的支持并不好，在它的设计理念里面，消息队列是一个管道，大量的消息积压是一种不正常的情况，应当尽量去避免。当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。
   
<li>    第二个问题是，RabbitMQ 的性能是我们介绍的这几个消息队列中最差的，根据官方给出的测试数据综合我们日常使用的经验，依据硬件配置的不同，它大概每秒钟可以处理几万到十几万条消息。其实，这个性能也足够支撑绝大多数的应用场景了，不过，如果你的应用对消息队列的性能要求非常高，那不要选择 RabbitMQ。
   
<li>    最后一个问题是 RabbitMQ 使用的编程语言 Erlang，这个编程语言不仅是非常小众的语言，更麻烦的是，这个语言的学习曲线非常陡峭。大多数流行的编程语言，比如 Java、C/C++、Python 和 JavaScript，虽然语法、特性有很多的不同，但它们基本的体系结构都是一样的，你只精通一种语言，也很容易学习其他的语言，短时间内即使做不到精通，但至少能达到“会用”的水平。/


<p>2  RocketMQ
<p> RocketMQ 就像一个品学兼优的好学生，有着不错的性能，稳定性和可靠性，具备一个现代的消息队列应该有的几乎全部功能和特性，并且它还在持续的成长中。
    
 <p> RocketMQ 有非常活跃的中文社区，大多数问题你都可以找到中文的答案
 
 <p> 3. Kafka
 <p> Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。
 <p> KafKa 是异步处理消息的 而且是批量处理 当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。
 
 #### 第二梯队的消息队列
 <p> ActiveMQ 是最老牌的开源消息队列，是十年前唯一可供选择的开源消息队列，目前已进入老年期，社区不活跃。无论是功能还是性能方面，ActiveMQ 都与现代的消息队列存在明显的差距，它存在的意义仅限于兼容那些还在用的爷爷辈儿的系统
 <p> ZeroMQ，严格来说 ZeroMQ 并不能称之为一个消息队列，而是一个基于消息队列的多线程网络库，如果你的需求是将消息队列的功能集成到你的系统进程中，可以考虑使用 ZeroMQ。
 
 
 ### 03 | 消息模型：主题和队列有什么区别？
 <p> 队列严格来说是一种 数据结构 早期消息队列就是按着队列来做de
 <p> 队列模式的问题 : 如果有多个消费者 都会去消费一份数据  这时候就需要多个队列 生产者为每一个属于消费者的队列发送一份数据 这就起不到解耦的效果了
 
 
 #### 发布 - 订阅模型（Publish-Subscribe Pattern）
 <img src="https://static001.geekbang.org/resource/image/d5/54/d5c0742113b2a6f5a419e1ffc3327354.jpg">
 <p>它们最大的区别其实就是，一份消息数据能不能被消费多次的问题。
    
 <p>  实际上，在这种发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。也就是说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。
    
 <p>    现代的消息队列产品使用的消息模型大多是这种发布 - 订阅模型   当然也有例外。
 
 #### RabbitMQ 的消息模型
 <img src="https://static001.geekbang.org/resource/image/2d/a5/2df04ce80ff54702240df8598f277ca5.jpg" >
 
 
 #### RocketMQ 的消息模型
 <p> RocketMQ 使用的消息模型是标准的发布 - 订阅模型，在 RocketMQ 的术语表中，生产者、消费者和主题与我在上面讲的发布 - 订阅模型中的概念是完全一样的
 <p> 每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的
 <p> RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。
     
 <p>     消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。
 
 <img src="https://static001.geekbang.org/resource/image/46/17/465142ab5b5096f283118c307e8cc117.jpg" >
 
 #### Kafka 的消息模型
 <p> Kafka 的消息模型和 RocketMQ 是完全一样的，我刚刚讲的所有 RocketMQ 中对应的概念，和生产消费过程中的确认机制，都完全适用于 Kafka。唯一的区别是，在 Kafka 中，队列这个概念的名称不一样，Kafka 中对应的名称是“分区（Partition）”，含义和功能是没有任何区别的。


### 04 | 如何利用事务消息实现分布式事务？
<p> 消息队列中的“事务”，主要解决的是消息生产者和消息消费者的数据一致性问题。
<p> 在实际应用中，比较常见的分布式事务实现有 2PC（Two-phase Commit，也叫二阶段提交）、TCC(Try-Confirm-Cancel) 和事务消息。每一种实现都有其特定的使用场景，也有各自的问题，都不是完美的解决方案。

#### 消息队列是如何实现分布式事务的？
<p> Kafka 和 RocketMQ 都提供了事务相关功能。
<img  src="https://static001.geekbang.org/resource/image/27/e6/27ebf12e0dc79e00e1e42c8ff0f4e2e6.jpg" >

<p>    这个模式有一个问题 就是在第四步 本地事物完成之后 提交消息队列的时候失败了怎么办
<p> Kafka 的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。RocketMQ 则给出了另外一种解决方案

#### RocketMQ 中的分布式事务实现
<p> 在 RocketMQ 中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。
    
<p>    为了支撑这个事务反查机制，我们的业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。

<img src="https://static001.geekbang.org/resource/image/11/7a/11ea249b164b893fb9c36e86ae32577a.jpg" >