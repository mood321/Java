####  内容是极客消息队列的笔记


### 01 | 为什么需要消息队列？
<p> 三种场景：异步处理、流量控制和服务解耦  (后端 常用技巧 缓存,削峰 ,填谷)
<p>还有：

<li>作为发布 / 订阅系统实现一个微服务级系统间的观察者模式；
<li>连接流计算任务和数据；
<li>用于将消息广播给大量接收者。
<p>简单的说，我们在单体应用里面需要用队列解决的问题，在分布式系统中大多都可以用消息队列来解决。
<p>同时我们也要认识到，消息队列也有它自身的一些问题和局限性，包括：
<li>引入消息队列带来的延迟问题；
<li>增加了系统的复杂度；
<li>可能产生数据不一致的问题。

###   02 | 该如何选择消息队列？
<p> 1. RabbitMQ
<p> RabbitMQ 一个比较有特色的功能是支持非常灵活的路由配置，和其他消息队列不同的是，它在生产者（Producer）和队列（Queue）之间增加了一个 Exchange 模块，你可以理解为交换机。
<p>问题。
   
<li>   第一个问题是，RabbitMQ 对消息堆积的支持并不好，在它的设计理念里面，消息队列是一个管道，大量的消息积压是一种不正常的情况，应当尽量去避免。当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。
   
<li>    第二个问题是，RabbitMQ 的性能是我们介绍的这几个消息队列中最差的，根据官方给出的测试数据综合我们日常使用的经验，依据硬件配置的不同，它大概每秒钟可以处理几万到十几万条消息。其实，这个性能也足够支撑绝大多数的应用场景了，不过，如果你的应用对消息队列的性能要求非常高，那不要选择 RabbitMQ。
   
<li>    最后一个问题是 RabbitMQ 使用的编程语言 Erlang，这个编程语言不仅是非常小众的语言，更麻烦的是，这个语言的学习曲线非常陡峭。大多数流行的编程语言，比如 Java、C/C++、Python 和 JavaScript，虽然语法、特性有很多的不同，但它们基本的体系结构都是一样的，你只精通一种语言，也很容易学习其他的语言，短时间内即使做不到精通，但至少能达到“会用”的水平。/


<p>2  RocketMQ
<p> RocketMQ 就像一个品学兼优的好学生，有着不错的性能，稳定性和可靠性，具备一个现代的消息队列应该有的几乎全部功能和特性，并且它还在持续的成长中。
    
 <p> RocketMQ 有非常活跃的中文社区，大多数问题你都可以找到中文的答案
 
 <p> 3. Kafka
 <p> Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。
 <p> KafKa 是异步处理消息的 而且是批量处理 当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。
 
 #### 第二梯队的消息队列
 <p> ActiveMQ 是最老牌的开源消息队列，是十年前唯一可供选择的开源消息队列，目前已进入老年期，社区不活跃。无论是功能还是性能方面，ActiveMQ 都与现代的消息队列存在明显的差距，它存在的意义仅限于兼容那些还在用的爷爷辈儿的系统
 <p> ZeroMQ，严格来说 ZeroMQ 并不能称之为一个消息队列，而是一个基于消息队列的多线程网络库，如果你的需求是将消息队列的功能集成到你的系统进程中，可以考虑使用 ZeroMQ。
 
 
 ### 03 | 消息模型：主题和队列有什么区别？
 <p> 队列严格来说是一种 数据结构 早期消息队列就是按着队列来做de
 <p> 队列模式的问题 : 如果有多个消费者 都会去消费一份数据  这时候就需要多个队列 生产者为每一个属于消费者的队列发送一份数据 这就起不到解耦的效果了
 
 
 #### 发布 - 订阅模型（Publish-Subscribe Pattern）
 <img src="https://static001.geekbang.org/resource/image/d5/54/d5c0742113b2a6f5a419e1ffc3327354.jpg">
 <p>它们最大的区别其实就是，一份消息数据能不能被消费多次的问题。
    
 <p>  实际上，在这种发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。也就是说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。
    
 <p>    现代的消息队列产品使用的消息模型大多是这种发布 - 订阅模型   当然也有例外。
 
 #### RabbitMQ 的消息模型
 <img src="https://static001.geekbang.org/resource/image/2d/a5/2df04ce80ff54702240df8598f277ca5.jpg" >
 
 
 #### RocketMQ 的消息模型
 <p> RocketMQ 使用的消息模型是标准的发布 - 订阅模型，在 RocketMQ 的术语表中，生产者、消费者和主题与我在上面讲的发布 - 订阅模型中的概念是完全一样的
 <p> 每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的
 <p> RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。
     
 <p>     消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。
 
 <img src="https://static001.geekbang.org/resource/image/46/17/465142ab5b5096f283118c307e8cc117.jpg" >
 
 #### Kafka 的消息模型
 <p> Kafka 的消息模型和 RocketMQ 是完全一样的，我刚刚讲的所有 RocketMQ 中对应的概念，和生产消费过程中的确认机制，都完全适用于 Kafka。唯一的区别是，在 Kafka 中，队列这个概念的名称不一样，Kafka 中对应的名称是“分区（Partition）”，含义和功能是没有任何区别的。


### 04 | 如何利用事务消息实现分布式事务？
<p> 消息队列中的“事务”，主要解决的是消息生产者和消息消费者的数据一致性问题。
<p> 在实际应用中，比较常见的分布式事务实现有 2PC（Two-phase Commit，也叫二阶段提交）、TCC(Try-Confirm-Cancel) 和事务消息。每一种实现都有其特定的使用场景，也有各自的问题，都不是完美的解决方案。

#### 消息队列是如何实现分布式事务的？
<p> Kafka 和 RocketMQ 都提供了事务相关功能。
<img  src="https://static001.geekbang.org/resource/image/27/e6/27ebf12e0dc79e00e1e42c8ff0f4e2e6.jpg" >

<p>    这个模式有一个问题 就是在第四步 本地事物完成之后 提交消息队列的时候失败了怎么办
<p> Kafka 的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。RocketMQ 则给出了另外一种解决方案

#### RocketMQ 中的分布式事务实现
<p> 在 RocketMQ 中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。
    
<p>    为了支撑这个事务反查机制，我们的业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。

<img src="https://static001.geekbang.org/resource/image/11/7a/11ea249b164b893fb9c36e86ae32577a.jpg" >


#### 05 | 如何确保消息不会丢失?

#### 检测消息丢失的方法
<p> 我们可以利用消息队列的有序性来验证是否有消息丢失。原理非常简单，在 Producer 端，我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的连续性
<p> 大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在 Producer 发送消息之前的拦截器中将序号注入到消息中，在 Consumer 收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到你的业务代码中，待你的系统稳定后，也方便将这部分检测的逻辑关闭或者删除
<p>像 Kafka 和 RocketMQ 这样的消息队列，它是不保证在 Topic 上的严格顺序的，只能保证分区上的消息是有序的，所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。
   
 <p>如果你的系统中 Producer 是多实例的，由于并不好协调多个 Producer 之间的发送顺序，所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续
 
 #### 确保消息可靠传递
 <p> 生产阶段: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。
<p>    存储阶段: 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。
<p>     消费阶段: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。

<p> 1. 生产阶段
<p> 你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。
<p> 2. 存储阶段
<p> 如果对消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢消息。
<p>对于单个节点的 Broker，需要配置 Broker 参数，在收到消息后，将消息写入磁盘后再给 Producer 返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配置为 SYNC_FLUSH 同步刷盘

<p> 3. 消费阶段
<p> 不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。


### 06 | 如何处理消费过程中的重复消息？
<p>消息重复的情况必然存在

<p>在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：

<li>At most once: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。
<li>At least once: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。
<li>Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级


<p>用幂等性解决重复消息问题
<p>一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性。

>幂等（Idempotence） 本来是一个数学上的概念，它是这样定义的：

<p>如果一个函数 f(x) 满足：f(f(x)) = f(x)，则函数 f(x) 满足幂等性。

<p>从对系统的影响结果来说：At least once + 幂等消费 = Exactly once。

<p>那么如何实现幂等操作呢？最好的方式就是，从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作


<p>几种常用的设计幂等操作的方法：
<p> 1. 利用数据库的唯一约束实现幂等
<p>我们在数据库中建一张转账流水表，这个表有三个字段：转账单 ID、账户 ID 和变更金额，然后给转账单 ID 和账户 ID 这两个字段联合起来创建一个唯一约束，这样对于相同的转账单 ID 和账户 ID，表里至多只能存在一条记录。
   
<p>   这样，我们消费消息的逻辑可以变为：“在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可
   
<p> 2. 为更新的数据设置前置条件
<p> “将账户 X 的余额增加 100 元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户 X 当前的余额为 500 元，将余额加 100 元”，这个操作就具备了幂等性
<p> 3. 记录并检查操作
<p> 具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。


### 07 | 消息积压了该如何处理？
<p> 绝大多数使用消息队列的业务来说，消息队列本身的处理能力要远大于业务系统的处理能力。主流消息队列的单个节点，消息收发的性能可以达到每秒钟处理几万至几十万条消息的水平
<p> 而一般的业务系统需要处理的业务逻辑远比消息队列要复杂，单个节点每秒钟可以处理几百到几千次请求，已经可以算是性能非常好的了。所以，对于消息队列的性能优化，我们更关注的是，在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能

<p> 1. 发送端性能优化
<p> 发送端业务代码的处理性能，实际上和消息队列的关系不大，因为一般发送端都是先执行自己的业务逻辑，最后再发送消息。如果说，你的代码发送消息的性能上不去，你需要优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的
<p> 对于发送消息的业务逻辑，只需要注意设置合适的并发和批量大小，就可以达到很好的发送性能

<p> 2. 消费端性能优化
<p> 使用消息队列的时候，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压。如果这种性能倒挂的问题只是暂时的，那问题不大，只要消费端的性能恢复之后，超过发送端的性能，那积压的消息是可以逐渐被消化掉的。
    
<p>    要是消费速度一直比生产速度慢，时间长了，整个系统就会出现问题，要么，消息队列的存储被填满无法提供服务，要么消息丢失，这对于整个系统来说都是严重故障
<p> 在设计系统的时候，一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行
<p> 在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。

<p> 还有一种错误的消费方式 
<p> 在收到消息的 OnMessage 方法中，不处理任何业务逻辑，把这个消息放到一个内存队列里面就返回了。然后它可以启动很多的业务线程，这些业务线程里面是真正处理消息的业务逻辑，这些线程从内存队列里取消息处理，这样它就解决了单个 Consumer 不能并行消费的问题
<p> 因为会丢消息。如果收消息的节点发生宕机，在内存队列中还没来及处理的这些消息就会丢失

<p> 消息积压了该如何处理？
<p> 能导致积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了。
    
<p>    大部分消息队列都内置了监控的功能，只要通过监控数据，很容易确定是哪种原因。如果是单位时间发送的消息增多，比如说是赶上大促或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，唯一的方法是通过扩容消费端的实例数来提升总体的消费能力。

<p> 如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。
    
<p>    还有一种不太常见的情况，你通过监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，这时候你需要检查一下你的消费端，是不是消费失败导致的一条消息反复消费这种情况比较多，这种情况也会拖慢整个系统的消费速度。


<h3> <a href="https://time.geekbang.org/column/article/110459">08 | 答疑解惑（一） : 网关如何接收服务端的秒杀结果？ </a>

### 09 | 学习开源代码该如何入手？
<p> 看官方文档 ,理解基本原理 ,了解基本概念 ,带着问题看代码

### 10 | 如何使用异步设计提升系统性能？
<p> 异步设计如何提升系统性能？

<p> 1. 同步实现的性能瓶颈
<p> 采用同步实现的方式，整个服务器的所有线程大部分时间都没有在工作，而是都在等待。

 <p> 2. 采用异步实现解决等待问题
 <p>异步的实现过程相对于同步来说，稍微有些复杂。我们先定义 2 个回调方法：
 
 <li>OnDebit()：扣减账户 accountFrom 完成后调用的回调方法；
 <li>OnAllDone()：转入账户 accountTo 完成后调用的回调方法。
 <p>整个异步实现的语义相当于：
 
 <li>异步从 accountFrom 的账户中减去相应的钱数，然后调用 OnDebit 方法；
 <li>在 OnDebit 方法中，异步把减去的钱数加到 accountTo 的账户中，然后执行 OnAllDone 方法；
<li> 在 OnAllDone 方法中，调用 OnComplete 方法。

<p> 区别只是在线程模型上由同步顺序调用改为了异步调用和回调的机制。 不需要在同步等待结果 


#### 简单实用的异步框架: CompletableFuture
<p> Java 中比较常用的异步框架有 Java8 内置的CompletableFuture和 ReactiveX 的RxJava，
<p> Java 8 中新增了一个非常强大的用于异步编程的类：CompletableFuture，几乎囊获了我们在开发异步程序的大部分功能，使用 CompletableFuture 很容易编写出优雅且易于维护的异步代码
<p>  我们用 CompletableFuture 定义 2 个微服务的接口：
<pre> 
 /**
  * 账户服务
  */
 public interface AccountService {
     /**
      * 变更账户金额
      * @param account 账户 ID
      * @param amount 增加的金额，负值为减少
      */
     CompletableFuture<Void> add(int account, int amount);
 }
 /**
  * 转账服务
  */
 public interface TransferService {
     /**
      * 异步转账服务
      * @param fromAccount 转出账户
      * @param toAccount 转入账户
      * @param amount 转账金额，单位分
      */
     CompletableFuture<Void> transfer(int fromAccount, int toAccount, int amount);
 }
</pre>
<p> 可以看到这两个接口中定义的方法的返回类型都是一个带泛型的 CompletableFeture，尖括号中的泛型类型就是真正方法需要返回数据的类型，我们这两个服务不需要返回数据，所以直接用 Void 类型就可以。
 
<p> 然后我们来实现转账服务：
 <pre>
 /**
  * 转账服务的实现
  */
 public class TransferServiceImpl implements TransferService {
     @Inject
     private  AccountService accountService; // 使用依赖注入获取账户服务的实例
     @Override
     public CompletableFuture<Void> transfer(int fromAccount, int toAccount, int amount) {
       // 异步调用 add 方法从 fromAccount 扣减相应金额
       return accountService.add(fromAccount, -1 * amount)
       // 然后调用 add 方法给 toAccount 增加相应金额
       .thenCompose(v -> accountService.add(toAccount, amount));    
     }
 }
 </pre>
<p> 在转账服务的实现类 TransferServiceImpl 里面，先定义一个 AccountService 实例，这个实例从外部注入进来，至于怎么注入不是我们关心的问题，就假设这个实例是可用的就好了。
 
<p> 然后我们看实现 transfer() 方法的实现，我们先调用一次账户服务 accountService.add() 方法从 fromAccount 扣减响应的金额，因为 add() 方法返回的就是一个 CompletableFeture 对象，可以用 CompletableFeture 的 thenCompose() 方法将下一次调用 accountService.add() 串联起来，实现异步依次调用两次账户服务完整转账。
 
<p> 客户端使用 CompletableFuture 也非常灵活，既可以同步调用，也可以异步调用。
 <pre> 
 public class Client {
     @Inject
     private TransferService transferService; // 使用依赖注入获取转账服务的实例
     private final static int A = 1000;
     private final static int B = 1001;
     public void syncInvoke() throws ExecutionException, InterruptedException {
         // 同步调用
         transferService.transfer(A, B, 100).get();
         System.out.println(" 转账完成！");
     }
     public void asyncInvoke() {
         // 异步调用
         transferService.transfer(A, B, 100)
                 .thenRun(() -> System.out.println(" 转账完成！"));
     }
 }
</ pre>
<p> 在调用异步方法获得返回值 CompletableFuture 对象后，既可以调用 CompletableFuture 的 get 方法，像调用同步方法那样等待调用的方法执行结束并获得返回值，也可以像异步回调的方式一样，调用 CompletableFuture 那些以 then 开头的一系列方法，为 CompletableFuture 定义异步方法结束之后的后续操作。比如像上面这个例子中，我们调用 thenRun() 方法，参数就是将转账完成打印在控台上这个操作，这样就可以实现在转账完成后，在控制台打印“转账完成！”了


<p>异步思想就是，当我们要执行一项比较耗时的操作时，不去等待操作结束，而是给这个操作一个命令：“当操作完成后，接下来去执行什么。”
<p> 使用异步编程模型，虽然并不能加快程序本身的速度，但可以减少或者避免线程等待，只用很少的线程就可以达到超高的吞吐能力。
    
<p>    同时我们也需要注意到异步模型的问题：相比于同步实现，异步实现的复杂度要大很多，代码的可读性和可维护性都会显著的下降。虽然使用一些异步编程框架会在一定程度上简化异步开发，但是并不能解决异步模型高复杂度的问题。
    
<p>    异步性能虽好，但一定不要滥用，只有类似在像消息队列这种业务逻辑简单并且需要超高吞吐量的场景下，或者必须长时间等待资源的地方，才考虑使用异步模型。如果系统的业务逻辑比较复杂，在性能足够满足业务需求的情况下，采用符合人类自然的思路且易于开发和维护的同步模型是更加明智的选择
    
 
    
        
   