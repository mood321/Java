###   Mysql  学习记录
#### Server层和存储引擎层

<img src="https://s2.ax1x.com/2019/12/05/QGhBNV.png" alt="QGhBNV.png" border="0" />
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、
<p>数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是
<p>InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。
<p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来
<p>选择别的引擎，比如在create table语句中使用engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，
<p>支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。
<p>不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分
<p> 1 连接器 第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接
<p> ps:客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时
<p>解决这个问题呢？你可以考虑以下两种方案。
<p> 1 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
<p> 2 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

<p> 2 查询缓存 
<p> MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端
<p> ps： 每次操作后 整个表缓存会失效  (不推荐用本身的缓存) and 数据会在8之后 取消了缓存   

<p> 3 分析器
<p>     如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析
<p> ps: 这一步会检查语法错误 “You have an error in your SQL syntax”的错误提醒

<p> 4 优化器
<p> MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。
<p>   优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序
<p> 1、选择最合适的索引；
 <p>2、选择表扫还是走索引；
<p> 3、选择表关联顺序；
<p> 4、优化 where 子句；
<p> 5、排除管理中无用表；
<p> 6、决定 order by 和 group by 是否走索引；
<p> 7、尝试使用 inner join 替换 outer join；
<p> 8、简化子查询，决定结果缓存；
<p> 9、合并试图；

<p> 5  执行器
<p> 进入了执行器阶段，开始执行语句 会判断是否有执行的权限 
<pre><code>
select * from T where ID=10;
</code></pre>
<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：
<p>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
<p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
<p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
<p>至此，这个语句就执行完成了  

<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，
<p>之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。
<p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。
<p>这个值就是在执行器每次调用引擎获取数据行的时候累加的。


### redo log（重做日志）和 binlog（归档日志）
#### 重要的日志模块：redo log
<p>1 就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘
<p>2 具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。
<p>同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做
<p> 如果日志满了  会把一部分记录写到磁盘 腾出空间 让后面日志可以继续写
<p> InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，总共就可以记录4GB的操作
<p>3  crash-safe
 <p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。  
<p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe

#### 重要的日志模块：binlog
<p>MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。
<p>上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）
<p>这两种日志有以下三点不同。

<p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。

<p>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。

<p>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。

<p>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

<p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

<p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。

<p>执行器生成这个操作的binlog，并把binlog写入磁盘。

<p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

#### 两阶段提交
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。

<p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？

<p>先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。
<p>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。
<p>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。

<p>先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。

<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。


### 事物
#### 隔离性与隔离级别
<p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），
今天我们就来说说其中I，也就是“隔离性”。

<p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，
<p>为了解决这些问题，就有了“隔离级别”的概念。

<p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：
<p>读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：
    <li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
    <li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
    <li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
    <li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
 <p> 现在有两个事物同时启动   
<table>
 <tr> <td>事物1</td><td>事物2</td>    </tr>
 <tr> <td>启动事物1 得到值1</td><td>启动事物2</td>    </tr>
 <tr> <td></td><td>得到值1</td>    </tr>
 <tr> <td></td><td>将1改成2</td>    </tr>
 <tr> <td>查询值V1</td><td></td>    </tr>
 <tr> <td></td><td>提交事物2</td>    </tr>
 <tr> <td>查询得到值V2</td><td></td>    </tr>
 <tr> <td>提交事物1</td><td></td>    </tr>
 <tr> <td>查询得到值V3</td><td></td>    </tr>
 </table>
 
<p> 我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。
 
 <li>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
<li> 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
<li 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
<li> 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。
<p> 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，
<p>整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，
<p>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。
 
<p> 我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，
<p>为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。
 
 <p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。
 
####  事务隔离的实现
<p>假设一个值从1被按顺序改成了2、3、4，当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。
<p>如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。
<p>对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。
<p> 同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。
<p> 你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，
<p>回滚日志会被删除。
<p> 什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。
 <p> ps： 少用长事物

#### MVCC 
<a href="https://www.cnblogs.com/AnXinliang/p/9955331.html">MVCC并发控制</a>
<p> 他本质就是处理数据的版本号和自己事物的版本号  来判断状态
<p>版本号
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
<li>事务版本号：事务开始时的系统版本号。
<p>隐藏的列
<li>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：

<li>创建版本号：指示创建一个数据行的快照时的系统版本号；
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。
<p>Undo 日志
<li>VCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。
<p>实现过程
<p>以下实现过程针对可重复读隔离级别。

<p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。

<p>1. SELECT

<p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，
<p>那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，
<p>那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，
<p>因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。

<p>2. INSERT
<p>将当前系统版本号作为数据行快照的创建版本号。

<p>3. DELETE
<p>将当前系统版本号作为数据行快照的删除版本号。

<p>4. UPDATE
<p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。

<p>Next-Key Locks
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

<p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

<p>Record Locks  (记录锁)
<p>锁定一个记录上的索引，而不是记录本身。

<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

<p>Gap Locks (间隙锁)
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
<pre><code>
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;     </code></pre>
<p>Next-Key Locks (区间锁)
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：
 <pre><code>
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)   </code></pre>

### 事务的启动方式
<p>1 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。

<p>2 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。
<p>这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。

<p> ps: 推荐手动去开启 提交