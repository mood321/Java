###   Mysql  学习记录
#### Server层和存储引擎层

<img src="https://s2.ax1x.com/2019/12/05/QGhBNV.png" alt="QGhBNV.png" border="0" />
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、
<p>数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是
<p>InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。
<p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来
<p>选择别的引擎，比如在create table语句中使用engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，
<p>支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。
<p>不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分
<p> 1 连接器 第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接
<p> ps:客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时
<p>解决这个问题呢？你可以考虑以下两种方案。
<p> 1 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
<p> 2 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

<p> 2 查询缓存 
<p> MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端
<p> ps： 每次操作后 整个表缓存会失效  (不推荐用本身的缓存) and 数据会在8之后 取消了缓存   

<p> 3 分析器
<p>     如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析
<p> ps: 这一步会检查语法错误 “You have an error in your SQL syntax”的错误提醒

<p> 4 优化器
<p> MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。
<p>   优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序
<p> 1、选择最合适的索引；
 <p>2、选择表扫还是走索引；
<p> 3、选择表关联顺序；
<p> 4、优化 where 子句；
<p> 5、排除管理中无用表；
<p> 6、决定 order by 和 group by 是否走索引；
<p> 7、尝试使用 inner join 替换 outer join；
<p> 8、简化子查询，决定结果缓存；
<p> 9、合并试图；

<p> 5  执行器
<p> 进入了执行器阶段，开始执行语句 会判断是否有执行的权限 
<pre><code>
select * from T where ID=10;
</code></pre>
<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：
<p>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
<p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
<p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
<p>至此，这个语句就执行完成了  

<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，
<p>之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。
<p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。
<p>这个值就是在执行器每次调用引擎获取数据行的时候累加的。


### redo log（重做日志）和 binlog（归档日志）
#### 重要的日志模块：redo log
<p>1 就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘
<p>2 具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。
<p>同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做
<p> 如果日志满了  会把一部分记录写到磁盘 腾出空间 让后面日志可以继续写
<p> InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，总共就可以记录4GB的操作
<p>3  crash-safe
 <p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。  
<p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe

#### 重要的日志模块：binlog
<p>MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。
<p>上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）
<p>这两种日志有以下三点不同。

<p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。

<p>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。

<p>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。

<p>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

<p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

<p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。

<p>执行器生成这个操作的binlog，并把binlog写入磁盘。

<p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

#### 两阶段提交
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。

<p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？

<p>先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。
<p>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。
<p>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。

<p>先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。

<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。


### 事物
#### 隔离性与隔离级别
<p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），
今天我们就来说说其中I，也就是“隔离性”。

<p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，
<p>为了解决这些问题，就有了“隔离级别”的概念。

<p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：
<p>读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：
    <li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
    <li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
    <li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
    <li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
 <p> 现在有两个事物同时启动   
<table>
 <tr> <td>事物1</td><td>事物2</td>    </tr>
 <tr> <td>启动事物1 得到值1</td><td>启动事物2</td>    </tr>
 <tr> <td></td><td>得到值1</td>    </tr>
 <tr> <td></td><td>将1改成2</td>    </tr>
 <tr> <td>查询值V1</td><td></td>    </tr>
 <tr> <td></td><td>提交事物2</td>    </tr>
 <tr> <td>查询得到值V2</td><td></td>    </tr>
 <tr> <td>提交事物1</td><td></td>    </tr>
 <tr> <td>查询得到值V3</td><td></td>    </tr>
 </table>
 
<p> 我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。
 
 <li>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
<li> 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
<li 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
<li> 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。
<p> 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，
<p>整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，
<p>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。
 
<p> 我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，
<p>为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。
 
 <p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。
 
####  事务隔离的实现
<p>假设一个值从1被按顺序改成了2、3、4，当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。
<p>如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。
<p>对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。
<p> 同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。
<p> 你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，
<p>回滚日志会被删除。
<p> 什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。
 <p> ps： 少用长事物

#### MVCC 
<a href="https://www.cnblogs.com/AnXinliang/p/9955331.html">MVCC并发控制</a>
<p> 他本质就是处理数据的版本号和自己事物的版本号  来判断状态
<p>版本号
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
<li>事务版本号：事务开始时的系统版本号。
<p>隐藏的列
<li>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：

<li>创建版本号：指示创建一个数据行的快照时的系统版本号；
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。
<p>Undo 日志
<li>VCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。
<p>实现过程
<p>以下实现过程针对可重复读隔离级别。

<p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。

<p>1. SELECT

<p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，
<p>那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，
<p>那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，
<p>因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。

<p>2. INSERT
<p>将当前系统版本号作为数据行快照的创建版本号。

<p>3. DELETE
<p>将当前系统版本号作为数据行快照的删除版本号。

<p>4. UPDATE
<p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。

<p>Next-Key Locks
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

<p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

<p>Record Locks  (记录锁)
<p>锁定一个记录上的索引，而不是记录本身。

<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

<p>Gap Locks (间隙锁)
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
<pre><code>
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;     </code></pre>
<p>Next-Key Locks (区间锁)
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：
 <pre><code>
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)   </code></pre>

### 事务的启动方式
<p>1 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。

<p>2 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。
<p>这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。

<p> ps: 推荐手动去开启 提交

### 索引
<p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样

####索引的常见模型
<p> 1 哈希表
<p>一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，
<p>把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。
 <p> 不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
 <p> ps : 解决hash冲突: 1 开放定址（没看懂） 2 再hash  3 hashmap 所用的链表 4 公共溢出区
 <p> 哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。
 <p> 2 有序数组
 <p> 有序数组在等值查询和范围查询场景中的性能就都非常优秀 
 <p> 仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高
 <p> 有序数组索引只适用于静态存储引擎，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据
 
 <p> 3 二叉搜索树(或者多叉)
 <p> 查询复杂度是O(log(N))，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))
 <p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，
 <p>但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上 , 二叉树从磁盘加载到内存效率太低
 
 #### InnoDB 的索引模型
 <p> 索引类型分为主键索引和非主键索引。
 <p>     主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。
 <p>     非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。
  <p>    根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？
  <li>    如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
  <li>   如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。
<p>   也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

#### 索引维护
<p> B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。
<p>如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。
 
 <p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。
 <p>这个过程称为页分裂。在这种情况下，性能自然会受影响
<p> 分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程
<p> 1 用自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂
<p> 2 用业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

### 
<img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png"/>
<p>  如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？
<p> 这条SQL查询语句的执行流程：
<p>    在k索引树上找到k=3的记录，取得 ID = 300；
<p>    再到ID索引树查到ID=300对应的R3；
<p>    在k索引树取下一个值k=5，取得ID=500；
<p>    再回到ID索引树查到ID=500对应的R4；
<p>    在k索引树取下一个值k=6，不满足条件，循环结束。
<p>    在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。
<p>    在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？


#### 覆盖索引
<p> 如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，
不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。

<p> 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。
  
#### 最左前缀原则
<img src="https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg"/>
<p>如果有一个 2 列的索引 (col1, col2)，则已经对 (col1)、(col1, col2) 上建立了索引；
<p>如果有一个 3 列索引 (col1, col2, col3)，则已经对 (col1)、(col1, col2)、(col1, col2, col3) 上建立了索引；

<p>mysql 查询优化器
<p>如果建的索引是 (name, cid)。而查询的语句是 cid=1 AND name=’小红’。为什么还能利用到索引？
<p>当按照索引中所有列进行精确匹配（“=” 或 “IN”）时，索引可以被用到，并且 type 为 const。理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，所以 MySQL 不存在 where 子句的顺序问题而造成索引失效
  
<p>  注意事项
  
<li>  范围查询
<p>  mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。范围列可以用到索引，但是范围列后面的列无法用到索引。即，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引
 <li> like 语句的索引问题
<p>  如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀
<p>  在 like “value%” 可以使用索引，但是 like “%value%” 不会使用索引，走的是全表扫描
<li>  不要在列上进行运算
<p>  如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描
 <p> 例如 select * from user where YEAR(birthday) < 1990
 <p> 可以改造成 select * from users where birthday <’1990-01-01′
<li>  索引不会包含有 NULL 值的列
<p>  只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值为 NULL
<p>  尽量选择区分度高的列作为索引，区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，
<p>比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。一般需要 join 的字段都要求区分度 0.1 以上，即平均 1 条扫描 10 条记录
<li>  覆盖索引的好处
<p>  如果一个索引包含所有需要的查询的字段的值，我们称之为覆盖索引。覆盖索引是非常有用的工具，能够极大的提高性能。因为，只需要读取索引，而无需读表，极大减少数据访问量

#### 索引下推
<p>如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：
<pre><code>
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
</code></pre>

<p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。

<p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
 <img src="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg"/>
 <p>无下推流程
 <img src="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg"/>
 <p>有下推流程
 
 
 ### 锁
 <p> 数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。
<p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类 

####  全局锁
<p>MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，
<p>可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

<p>全局锁的典型使用场景是，做全库逻辑备份

<p> 对主从库备份的问题
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟
<p> 不加锁备份的问题
<p> 如果有写操作 操作多个表 备份数据表的数据可能不一致
<p>时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表(u_course) 
<p> 其他方案
<p> 1   事物 
<p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的
<p> 缺点: 一致性读是好，但前提是引擎要支持这个隔离级别  MyISAM就不支持
<p> 2 set global readonly=true 方案
<li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。
<li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。

#### 表级锁
<p> MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
<p> 表锁的语法是 lock tables … read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
 
<p> 举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。
 
<p> 在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大

<p> 另一类表级的锁是MDL（metadata lock)。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

<p> 因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。

<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行

<img src="https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg"/>