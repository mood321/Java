### Java多线程学习笔记-重写版本
#### 线程的基本概念
   + CPU核心数和线程数的关系
     ````
     核心数:线程数=1:1  ;使用了多线程技术后---> 1:2
      
   + CPU时间片轮转机制
     ````   
     又称RR调度，会导致上下文切换 
   + 什么是进程和线程
        ````
       进程：程序运行资源分配的最小单位，进程内部有多个线程，会共享这个进程的资源
       线程：CPU调度的最小单位，必须依赖进程而存在。
   + 并行和并发
        ````
     并行：同一时刻，可以同时处理事情的能力
     并发：与单位时间相关，在单位时间内可以处理事情的能力
   + 意义、好处和注意事项
        ````
        好处：充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化
        问题：
        线程共享资源，存在冲突；
        容易导致死锁；
        启用太多的线程，就有搞垮机器的可能
        
#### java线程 基础
   + JAVA  线程实现/创建 创建方式
        ````
         继承 Thread 
         实现 Runnable 接口
         ExecutorService 、Callable<Class> 、Future 有返回值 有返回值线程 线程
         基于线程池的方式
     
   + 线程的停止
       - 方法体执行完毕或抛出未处理异常  (设置while 条件)
       - stop()，resume(),suspend()已不建议使用，stop()会导致线程不会正确释放资源，suspend()容易导致死锁。
       
       - 调用一个线程的interrupt() 方法中断一个线程
            ````
            并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。
            isInterrupted() 判定当前线程是否处于中断状态。
            static方法interrupted() 判定当前线程是否处于中断状态，同时中断标志位改为false。
            方法里如果抛出InterruptedException，线程的中断标志位会被复位成false，如果确实是需要中断线程，
                --要求我们自己在catch语句块里再次调用interrupt()。 如果有while 记得要break 退出
         
   +  线程生命周期 
   
       - 线程只有5种状态。整个生命周期就是这几种状态的切换。<br>
         --新建状态（New）、就绪状态（Runnable）、运行状态（Running）、阻塞状态（Blocked）、死亡状态（Dead）
   ![](https://img-blog.csdn.net/20180430180530963?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbmd4dWV4aWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
       - 常用方法
           ````
           run()和start() ：run方法就是普通对象的普通方法，只有调用了start()后，Java才会将线程
            对象和操作系统中实际的线程进行映射，再来执行run方法。
           yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行。
           wait   ：会释放当前锁  notify后 和其他线程 一起抢占
           jon    ： 等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，
                若无此句，main则会执行完毕，导致结果不可预测。
           sleep()：在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。
       - 线程的优先级
          取值为1~10，缺省为5，但线程的优先级不可靠，不建议作为线程开发时候的手段
       - 守护线程
          和主线程共死，finally不能保证一定执行
####  Java 锁
   + 乐观锁
        ````
        乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为
        别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数
        据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），
        如果失败则要重复读-比较-写的操作。
        java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入
        值是否一样，一样则更新，否则失败
   + 悲观锁
        ````
        乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为
        别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数
        据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），
        如果失败则要重复读-比较-写的操作。
        java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入
        值是否一样，一样则更新，否则失败
   + 自旋锁 
     
      - 自旋锁原理
        ````
        如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁
        的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），
        等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。
        线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程
        也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。
        如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁
        的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。
      - 自旋锁的优缺点
        ````
        自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来
        说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会
        导致线程发生两次上下文切换！
        但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合
        使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量
        线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，
        其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；
      - 自旋锁时间阈值 （ 1.6 引入了适应性自旋锁 ）
        ````
        自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择
        自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而
        会影响整体系统的性能。因此自旋的周期选的额外重要
        JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应
        性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥
        有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当
        前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)
        个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋
        时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU
        的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放
        弃线程优先级之间的差异。
        自旋锁的开启
        JDK1.6 中-XX:+UseSpinning 开启；
        -XX:PreBlockSpin=10 为自旋次数；
        JDK1.7 后，去掉此参数，由 jvm 控制；
   + Synchronized Java原生锁
       ````
       synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重
       入锁。
       ````
     - Synchronized 作用范围
          ````
           1.  作用于方法时，锁住的是对象的实例(this)；
           2.  当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen
           （jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，
           会锁所有调用该方法的线程；
           3.  synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，
           当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。
           ````
     - Synchronized 核心 组件
        ````
           1) Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；
           2) Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；
           3) Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；
           4) OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；
           5) Owner：当前已经获取到所资源的线程被称为 Owner；
           6) !Owner：当前释放锁的线程。
     - Synchronized 实现
        ![](https://s2.ax1x.com/2019/08/27/mhIrxx.jpg)
        
        1.  JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，
        ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将
        一部分线程移动到 EntryList 中作为候选竞争线程。
        2. Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定
        EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。
        3.  Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，
        OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在
        JVM 中，也把这种选择行为称之为“竞争切换”。
        4.  OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList
        中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify
        或者 notifyAll 唤醒，会重新进去 EntryList 中。
        5.  处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统
        来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。
        6.  Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先
        尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是
        不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁
        资源。
        参考：https://blog.csdn.net/zqz_zqz/article/details/70233767
        7.  每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加
        上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的
        8.  synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线
        程加锁消耗的时间比有用操作消耗的时间更多。
        9.  Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向
        锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做
        了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。
        10. 锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；
        11. JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁