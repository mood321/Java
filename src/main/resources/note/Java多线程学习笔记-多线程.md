### Java多线程学习笔记-重写版本
#### 线程的基本概念
   + CPU核心数和线程数的关系
     ````
     核心数:线程数=1:1  ;使用了多线程技术后---> 1:2
      
   + CPU时间片轮转机制
     ````   
     又称RR调度，会导致上下文切换 
   + 线程上下文
        ````
        某一时间点 CPU 寄存器和程序计数器的内容 
   + 线程上下文切换
        ````
        巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存
        下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做
        上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能
   + 寄存器
        ````
        是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内
        存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速
        度。 
   + 程序计数器
        ````
        是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令
        的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统 
   + 引起线程上下文切换的原因 的原因
        ````
        1.  当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；
        2.  当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；
        3.  多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；
        4.  用户代码挂起当前任务，让出 CPU 时间；
        5.  硬件中断；
   + 什么是进程和线程
        ````
       进程：程序运行资源分配的最小单位，进程内部有多个线程，会共享这个进程的资源
       线程：CPU调度的最小单位，必须依赖进程而存在。
   + 并行和并发
        ````
     并行：同一时刻，可以同时处理事情的能力
     并发：与单位时间相关，在单位时间内可以处理事情的能力
   + 意义、好处和注意事项
        ````
        好处：充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化
        问题：
        线程共享资源，存在冲突；
        容易导致死锁；
        启用太多的线程，就有搞垮机器的可能
        
#### java线程 基础
   + JAVA  线程实现/创建 创建方式
        ````
         继承 Thread 
         实现 Runnable 接口
         ExecutorService 、Callable<Class> 、Future 有返回值 有返回值线程 线程
         基于线程池的方式
     
   + 线程的停止
       - 方法体执行完毕或抛出未处理异常  (设置while 条件)
       - stop()，resume(),suspend()已不建议使用，stop()会导致线程不会正确释放资源，suspend()容易导致死锁。
       
       - 调用一个线程的interrupt() 方法中断一个线程
            ````
            并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。
            isInterrupted() 判定当前线程是否处于中断状态。
            static方法interrupted() 判定当前线程是否处于中断状态，同时中断标志位改为false。
            方法里如果抛出InterruptedException，线程的中断标志位会被复位成false，如果确实是需要中断线程，
                --要求我们自己在catch语句块里再次调用interrupt()。 如果有while 记得要break 退出
         
   +  线程生命周期 
   
       - 线程只有5种状态。整个生命周期就是这几种状态的切换。<br>
         --新建状态（New）、就绪状态（Runnable）、运行状态（Running）、阻塞状态（Blocked）、死亡状态（Dead）
   ![](https://img-blog.csdn.net/20180430180530963?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbmd4dWV4aWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
       - 常用方法
           ````
           线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等
            ````
            1. 线程等待（wait ）
                >  调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的
                   是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中
            2. 线程睡眠（sleep
                >  sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致
                   线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态
            3. 线程让步（yield ） 
                > yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，
                  优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对
                  线程优先级并不敏感
            4. 线程中断（interrupt
                > 中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这
                  个线程本身并不会因此而改变状态(如阻塞，终止等)。
                  1.  调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线
                  程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。
                  2.  若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出
                  InterruptedException,从而使线程提前结束 TIMED-WATING 状态。
                  3.  许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异
                  常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。
                  4.  中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止
                  一个线程thread的时候，可以调用thread.interrupt()方法，在线程的run方法内部可以
                  根据 thread.isInterrupted()的值来优雅的终止线程。    
            5. Join  等待其他线程终止
                > join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞
                  状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸
           6.   线程唤醒（notify ）
                > Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象
                  上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调
                  用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继
                  续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞
                  争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程
           7. sleep 与 与 wait  区别
                ````
                1.  对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于
                Object 类中的。
                2.  sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然
                保持者，当指定的时间到了又会自动恢复运行状态。
                3.  在调用 sleep()方法的过程中，线程不会释放对象锁。
                4.  而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此
                对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。
           8. 其他方法
               ````  
                  1.  sleep()：强迫一个线程睡眠Ｎ毫秒。
                  2.  isAlive()： 判断一个线程是否存活。
                  3.  join()： 等待线程终止。
                  4.  activeCount()： 程序中活跃的线程数。
                  5.  enumerate()： 枚举程序中的线程。
                  6.  currentThread()： 得到当前线程。
                  7.  isDaemon()： 一个线程是否为守护线程。
                  8.  setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线
                  程依赖于主线程结束而结束)
                  9.  setName()： 为线程设置一个名称。
                  10. wait()： 强迫一个线程等待。
                  11. notify()： 通知一个线程继续运行。
                  12. setPriority()： 设置一个线程的优先级。
                  13. getPriority():：获得一个线程的优先级。      
                    
              
       - 线程的优先级
          取值为1~10，缺省为5，但线程的优先级不可靠，不建议作为线程开发时候的手段
       - 守护线程
          和主线程共死，finally不能保证一定执行
####  Java 锁
   + 乐观锁
        ````
        乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为
        别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数
        据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），
        如果失败则要重复读-比较-写的操作。
        java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入
        值是否一样，一样则更新，否则失败
   + 悲观锁
        ````
        乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为
        别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数
        据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），
        如果失败则要重复读-比较-写的操作。
        java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入
        值是否一样，一样则更新，否则失败
   + 自旋锁 
     
      - 自旋锁原理
        ````
        如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁
        的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），
        等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。
        线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程
        也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。
        如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁
        的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。
      - 自旋锁的优缺点
        ````
        自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来
        说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会
        导致线程发生两次上下文切换！
        但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合
        使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量
        线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，
        其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；
      - 自旋锁时间阈值 （ 1.6 引入了适应性自旋锁 ）
        ````
        自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择
        自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而
        会影响整体系统的性能。因此自旋的周期选的额外重要
        JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应
        性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥
        有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当
        前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)
        个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋
        时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU
        的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放
        弃线程优先级之间的差异。
        自旋锁的开启
        JDK1.6 中-XX:+UseSpinning 开启；
        -XX:PreBlockSpin=10 为自旋次数；
        JDK1.7 后，去掉此参数，由 jvm 控制；
   + Synchronized Java原生锁
       ````
       synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重
       入锁。
       ````
     - Synchronized 作用范围
          ````
           1.  作用于方法时，锁住的是对象的实例(this)；
           2.  当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen
           （jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，
           会锁所有调用该方法的线程；
           3.  synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，
           当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。
           ````
     - Synchronized 核心 组件
        ````
           1) Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；
           2) Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；
           3) Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；
           4) OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；
           5) Owner：当前已经获取到所资源的线程被称为 Owner；
           6) !Owner：当前释放锁的线程。
     - Synchronized 实现
        ![](https://s2.ax1x.com/2019/08/27/mhIrxx.jpg)
        
        1.  JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，
        ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将
        一部分线程移动到 EntryList 中作为候选竞争线程。
        2. Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定
        EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。
        3.  Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，
        OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在
        JVM 中，也把这种选择行为称之为“竞争切换”。
        4.  OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList
        中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify
        或者 notifyAll 唤醒，会重新进去 EntryList 中。
        5.  处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统
        来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。
        6.  Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先
        尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是
        不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁
        资源。
        参考：https://blog.csdn.net/zqz_zqz/article/details/70233767
        7.  每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加
        上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的
        8.  synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线
        程加锁消耗的时间比有用操作消耗的时间更多。
        9.  Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向
        锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做
        了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。
        10. 锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；
        11. JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁
     - ReentrantLock 
        ````
        ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完
        成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等
        避免多线程死锁的方法
        ````
        + Lock 接口的主要方法
            
            1.  void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经
            被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.
            2.  boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和
            lock()的区别在于, tryLock()只是"试图"获取锁, 如果锁不可用, 不会导致当前线程被禁用,
            当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一
            直等待, 在未获得锁之前,当前线程并不继续向下执行.
            3.  void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程
            并不持有锁, 却执行该方法, 可能导致异常的发生.
            4.  Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，
            当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。
            5.  getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次
            数。
            6.  getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个
            线程获得锁，此时返回的是 9
            7.  getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线
            程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了
            condition 对象的 await 方法，那么此时执行此方法返回 10
            8.  hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件
            (condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法
            9.  hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁
            10. hasQueuedThreads()：是否有线程等待此锁
            11. isFair()：该锁是否公平锁
            12. isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分
            别是 false 和 true
            13. isLock()：此锁是否有任意线程占用
            14. lockInterruptibly（）：如果当前线程未被中断，获取锁
            15. tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁
            16. tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，
            则获取该锁。
        + 非公平锁
            ````
            JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了
            是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非
            程序有特殊需要，否则最常用非公平锁的分配机制
     
        +  公平锁
            ````
            公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，
            ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。
           ````
        +  ReentrantLock  与 synchronized
            1.  ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会
            被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出
            现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操
            作。
            2.  ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要
            使用 ReentrantLock。
            
            + ReentrantLock 实现
                ````
                    private Lock lock = new ReentrantLock();
                    //Lock lock=new ReentrantLock(true);//公平锁
                    //Lock lock=new ReentrantLock(false);//非公平锁
                    private Condition condition=lock.newCondition();//创建 Condition
                    public void testMethod() {
                    try {
                    lock.lock();//lock 加锁
                    //1：wait 方法等待：
                    //System.out.println("开始 wait");
                    condition.await();
                    //通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁
                    //:2：signal 方法唤醒
                    condition.signal();//condition 对象的 signal 方法可以唤醒 wait 线程
                    for (int i = 0; i < 5; i++) {
                    System.out.println("ThreadName=" + Thread.currentThread().getName()+ (" " + (i + 1)));
                    }
                    } catch (InterruptedException e) {
                    e.printStackTrace();
                    }
                    finally{
                           lock.unlock();
                           }
                ````
            + Condition 类和 Object 类锁方法区别区别
              1.  Condition 类的 awiat 方法和 Object 类的 wait 方法等效
              2.  Condition 类的 signal 方法和 Object 类的 notify 方法等效
              3.  Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效
              4.  ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的
            
            + tryLock 和 lock 和 lockInterruptibly 的区别
              1.  tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit
              unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false
              2.  lock 能获得锁就返回 true，不能的话一直等待获得锁
              3.  lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，
              lock 不会抛出异常，而 lockInterruptibly 会抛出异常。
     - Semaphore 信号量
        ````
        Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信
        号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来
        构建一些对象池，资源池之类的，比如数据库连接池
        ````
        + 实现互斥锁（计数器为 1 ）
          ````
          我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，
          表示两种互斥状态
            
        + 代码实现
            ````
                // 创建一个计数阈值为 5 的信号量对象
                // 只能 5 个线程同时访问
                Semaphore semp = new Semaphore(5);
                try {  // 申请许可
                semp.acquire();
                try {
                // 业务逻辑
                } catch (Exception e) {
                } finally {
                // 释放许可
                semp.release();
                }
                } catch (InterruptedException e) {
                }
            ````
     + AtomicInteger
        ````
        首先说明，此处 AtomicInteger，一个提供原子操作的 Integer 的类，常见的还有
        AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，
        区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<V>将一个对象的所
        有操作转化成原子操作
        我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。
        通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些
        同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger
        的性能是 ReentantLock 的好几倍
        ````
       - CAS的原理(Unsafe方法里面提供了allocateMemory，freeMemory等开辟空间和释放空间的本地方法)
            ````
             CAS(Compare And Swap)，指令级别保证这是一个原子操作
             三个运算符：  一个内存地址V，一个期望的值A，一个新值B
             基本思路：如果地址V上的值和期望的值A相等，就给地址V赋给新值B，如果不是，不做任何操作。
             循环（死循环，自旋）里不断的进行CAS操作
       - CAS的问题
           ````
            A---》B----》A，加版本号
            CAS操作长期不成功，cpu不断的循环
       -  Jdk中相关原子操作类的使用
             ````
          更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference
          更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray
          更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference
          原子更新字段类： AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater
            ````
       - LongAdder 
            ````
            java8 新增的原子类 
            试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！
            解决了Atomic CAS失败不断自旋 消耗性能的问题  
            并发的Adder类和AtomicInteger相比有60~100%的性能提升（https://my.oschina.net/u/1185936/blog/678466） 能用Adder就用Adder吧
            
            
     + 可重入锁（递归锁）
        ````
         这里讲的是广义上的可重入锁，而不是单指JAVA 下的 ReentrantLock。可重入锁，也叫
         做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受
         影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁   
        ````
     + 公平锁与非公平锁
        - 公 平锁（ Fair ）
          加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得
        - 非公平锁（ Nonfair ）
          加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待
          1.  非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列
          2.  Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁
     
     + ReadWriteLock  读写锁
        ````
        为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如
        果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写
        锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可
        ````
        - 读锁
          > 如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁
        - 写锁
          > 如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上
            读锁，写的时候上写锁！
            
            Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock
     + 共享锁和独占锁
        > java 并发包提供的加锁模式分为独占锁和共享锁
        
        - 独占锁
          >独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。
          独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线
          程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。
        - 共享锁
          >共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种
          乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。
          1.  AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等
          待线程的锁获取模式。
          2.  java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，
          或者被一个 写操作访问，但两者不能同时进行。
     +  重量级锁 （ Mutex Lock ） ）
        > Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又
          是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用
          户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么
          Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为
          “重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。
          JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和
          “偏向锁”
     + 轻量级锁
        > 锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。
        - 锁升级
             > 随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，
              也就是说只能从低到高升级，不会出现锁的降级）。
              “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，
              轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量
              级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场
              景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀
              为重量级锁。
     + 偏向锁
        > Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线
          程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起
          来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级
          锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换
          ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所
          以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻
          量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进
          一步提高性能
     + 分段锁
        > 分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践
     + 锁 优化
        - 减少锁持有时间
          > 只用在有线程安全要求的程序上加锁
        - 减小锁粒度
          >  将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。
          降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是
          ConcurrentHashMap。
        - 锁分离
          > 最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互
          斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]
          JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如
          LinkedBlockingQueue 从头部取出，从尾部放数据
        - 锁粗化
          > 通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完
          公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步
          和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。
        - 锁消除
          > 锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这
          些对象的锁操作，多数是因为程序员编码不规范引起。
          
          参考： https://www.jianshu.com/p/39628e1180a9