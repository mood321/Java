## JVM  学习笔记 重写版本
   ### JVM 基本结构
   #### PC寄存器/程序计数器  []()
   ```` 
   负责记录当前执行线程内存地址执行位置 类似JAVA中ThreadLocal 线程私有 
   ````
   #### JAVA栈 []()
   ````
     每一个线程私有 记录当先线程栈帧 每个方法对应一个栈帧 栈帧内局部变量表,操作数栈,动态连接,返回地址等信息
   ````
   #### 本地方法栈 
   ````
    类似java栈 记录本地方法 用于本地方法调用 为Java虚拟机的重要扩展 Java虚拟机允许Java直接调用本地方法（通常使用C编写）
   ````
   #### 方法区/元数据 
   ````
    线程共享 存储了类信息 静态变量 常量池等信息
   ````
   - 常用参数
    ````
    -XX:PermSize 和 -XX:MaxPermSize  //永久代(方法区)大小 
    ````
    - -XX:PermSize 和 -XX:MaxPermSize：指定JVM中的永久代(方法区)的大小。可以看到：永久代不属于堆内存，堆内存只包含新生代和老年代
         
   - 不同:在JDK8中正式移除方法区 元数据区直接使用堆外内存元空间 由本地内存控制
   #### Java堆 []()
   ````
    线程共享 Java对象实例都存放在Java堆  
   ````
   - Java堆 的常见配置参数
      ````
      -Xmx10240m -Xms10240m  //堆初始大小和最大
      -Xmn5120m              //新生代最大内存
      -XXSurvivorRatio=3     // 新生代中Eden和Survivor 的占比 Survior默认为2
      -XX:NewRatio=4         // 堆中新生代和老年代占比 新生代默认为1
      -XX:OldSize            // 老年代初始大小。。。 
      
      ````  
      + -Xms 和 -Xmx (-XX:InitialHeapSize 和 -XX:MaxHeapSize)：指定JVM初始占用的堆内存和最大堆内存。JVM也是一个软件，也必须要获取本机的物理内
           存，然后JVM会负责管理向操作系统申请到的内存资源。JVM启动的时候会向操作系统申请 -Xms 设置的内存，JVM启动后运行一段时间，如果发现内存空间
           不足，会再次向操作系统申请内存。JVM能够获取到的最大堆内存是-Xmx设置的值。
      +  -XX:NewSize 和 -Xmn(-XX:MaxNewSize)：指定JVM启动时分配的新生代内存和新生代最大内存。
      
      + -XX:SurvivorRatio：设置新生代中1个Eden区与1个Survivor区的大小比值。在hotspot虚拟机中，新生代 = 1个Eden + 2个Survivor。如果新生代内存是10M，SurvivorRatio=8，那么Eden区占8M，2个Survivor区各占1M。
      
      + -XX:NewRatio：指定老年代/新生代的堆内存比例。在hotspot虚拟机中，堆内存 = 新生代 + 老年代。如果-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代
        占整个堆内存的1/5。在设置了-XX:MaxNewSize的情况下，-XX:NewRatio的值会被忽略，老年代的内存=堆内存 - 新生代内存。老年代的最大内存 = 堆内存 - 新生代 最大内存。
      
      + -XX:OldSize：设置JVM启动分配的老年代内存大小，类似于新生代内存的初始大小-XX:NewSize
      
   ps: 堆内存、新生代内存、老年代内存、永久代内存，都有一个初始内存，还有一个最大内存
      
   - VM 采用分代收集算法,  Java 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年代。
   - 新生代(MinorGC)
       ```` 
       是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发
        MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区 
        -XXSurvivorRatio：Eden区和Survior区的占用比例 
        ````
     - Eden 区 
        ````
        Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老
        年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行
        一次垃圾回收。
        ````
     - ServivorFrom 区 
        ````
        上一次 GC 的幸存者，作为这一次 GC 的被扫描者
        ````
     - ServivorTo 区 
        ````
        上一次 GC 的幸存者，作为这一次 GC 的被扫描者
        ````
   - 老年代(MajorGC)
       ```` 
           1   在新生代 Survivor被回收次数默认为15，会进入老年代
           2  大对象会直接进入老年代
           3  当Survivor区相当年龄的对象 大小超过Survivor的一般  年龄大于或等于该年龄的对象进去老年代
           4  当老年代内存不够 进入FULL GC（新生代，老年代都回收 jvm会停止）
        ````

#### 垃圾回收系统 []()
   ````
    Java虚拟机的重要组成部分，垃圾回收器可以对方法区、Java堆和直接内存进行回收。其中Java堆是垃圾收集器的工作重点
    GC需要做的三件事:
                    1 那些内存需要回收
                    2 什么时候回收
                    3 怎么回收
   ````
   + 判断对象是否可以回收
        - 引用计数器
            ````
            引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收
            引用计数法的循环引用问题: 
                在相互引用的两个对象上 他们引用数永远不会是0 进入一种死循环的状态
            ````
        - 可达性算法
        ````
        为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”
            对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。
        注意:不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记
            过程。两次标记后仍然是可回收对象，则将面临回收
        ````
   + GC算法
        - 标记清除算法(Mark-Sweep )[]()
          ````  
          最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，
            清除阶段回收被标记的对象所占用的空间
          注意:标记清除因为算法原因会产生碎片 
          ````
        ![tu](https://images.cnblogs.com/cnblogs_com/wupeixuan/1186116/o_a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg)
   
        - 复制算法(copying)
          ````  
          为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小
          的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用
          的内存清掉
          注意:这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原
             本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。
          ````
        ![tu](https://images.cnblogs.com/cnblogs_com/wupeixuan/1186116/o_e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg)
   
        -   标记整理算法(Mark-Compact)
             ````  
              结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清
              理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象
              注意:
             ````
        ![tu](https://images.cnblogs.com/cnblogs_com/wupeixuan/1186116/o_902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg)
   
        -   分代收集算法
              ````  
              分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存
              划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young
              Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃
              圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法
              ````
             jvm收集器演示图 ![jvm](https://img-blog.csdnimg.cn/20190726231626587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzNDI0,size_16,color_FFFFFF,t_70)
   + 垃圾回收器 
        ````
        Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收 算法 ；
        年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不
        同的垃圾收集器
            1 Serial 垃圾收集器  （单线程、 复制算法）
            2 ParNew 垃圾收集器 （ （Serial+多线程 多线程）
            3 Parallel Scavenge  收集器（多线程复制算法、高效）
            4 Serial Old  收集器（单线程标记整理算法 
            5 Parallel Old  收集器（多线程标记整理算法）
            6 CMS 收集器 （多线程标记清除算法）
            7 G1  收集器
        ````   
       - Serial  垃圾收集器
        ````
        Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1之前新生代唯一的垃圾
        收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工
        作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。
        Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限
        定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial
        垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器
        ````
      - ParNew 垃圾收集器
        ````
          Serial 的多线程版本 也使用复制算法，除了使用多线程进行垃
          圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也
          要暂停所有其他的工作线程。
          ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限
          制垃圾收集器的线程数。【Parallel：平行的】
          ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多java
          虚拟机运行在 Server 模式下新生代的默认垃圾收集器。
        ````
      - Parallel Scavenge 收集器 收集器（多线程复制算法、高效） （多线程复制算法、高效）
        ````
        Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃
        圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码
        的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），
        高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而
        不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个
        重要区别
        ````
      - Serial Old 收集器 （单线程标记整理算法 
        ````
        Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，
        这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。
        在 Server 模式下，主要有两个用途：
        1. 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。
        2. 作为年老代中使用 CMS 收集器的后备垃圾收集方案。
        ````
      - Parallel Old  收集器（多线程标记整理算法）
        ````
        Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6
        才开始提供。
        在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只
        能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞
        吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge
        和年老代 Parallel Old 收集器的搭配策略
        ````
      - CMS 收集器 收集器（多线程标记清除算法）
        ````
        Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾
        回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。
        最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验
            1.  初始标记
            只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
            2.  并发标记
            进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
            3.  重新标记
            为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记
            记录，仍然需要暂停所有的工作线程。
            4.  并发清除
            清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并
            发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看
            CMS 收集器的内存回收和用户线程是一起并发地执行
        ````
      - G1  收集器
        ````
        Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收
        集器两个最突出的改进是：
        1. 基于标记-整理算法，不产生内存碎片。
        2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
        G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域
        的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾
        最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收
        集效率。
        ````
   #### 类加载子系统 []()
       ````
        负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间
        JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化， 验证，准备，解析算连接
       `````
   + 加载 
       ````
           这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对
           象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既
           可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），
           也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）
       ````
   + 验证
       ````
           主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并
           且不会危害虚拟机自身的安全
       ````
   + 准备
       ````
           准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使
           用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：
       ````
           private static int prot=8080;
       ```
           实际上变量 prot 在准备阶段过后的初始值为 0 而不是 8080，将 prot 赋值为 8080 的 put static 指令是
           程序被编译后，存放于类构造器<clinit>方法之中。
           但是注意如果声明为在编译阶段会为 prot 生成 ConstantValue 属性，
           在准备阶段虚拟机会根据 ConstantValue 属性将 prot 赋值为 8080
       ````
   + 解析 ---[引用方式](https://blog.csdn.net/maihilton/article/details/81531878)
       ````
           解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中
           的：
           1.  CONSTANT_Class_info
           2.  CONSTANT_Field_info
           3.  CONSTANT_Method_info
           等类型的常量
       ````
       ps: 字节码具体属性未记
        -  引用方式--符号引用
            ````
            符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟
            机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引
            用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中
            ````
        -  引用方式--直接引用
            ````
            直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有
            了直接引用，那引用的目标必定已经在内存中存在
            ````
           ps:符号引用就是一个类中（当然不仅是类，还包括类的其他部分，比如方法，字段等），
             引入了其他的类，可是JVM并不知道引入的其他类在哪里，所以就用唯一符号来代替，
             等到类加载器去解析的时候，就把符号引用找到那个引用类的地址，这个地址也就是直接引用
   + 初始化
       ````
           类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载
           器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码
       ````
   + 类构造器<clinit>
       ````
          初始化阶段是执行类构造器<clinit>方法的过程。<client>方法是由编译器自动收集类中的类变
          量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<clinit>方法执行之前，父类
          的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译
          器可以不为这个类生成<clinit>()方法。
          注意以下几种情况不会执行类初始化：
          1.  通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
          2.  定义对象数组，不会触发该类的初始化。
          3.  常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触
          发定义常量所在的类。
          4.  通过类名获取 Class 对象，不会触发类的初始化。
          5.  通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初
          始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
          6.  通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。
       ````
   + 类加载器
       ````
       虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提
       供了 3 种类加载器
       ````
       - 启动类加载器(Bootstrap ClassLoader)
            ````
            负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被
            虚拟机认可（按文件名识别，如 rt.jar）的类。
            ````
       - 扩展类加载器(Extension ClassLoader)
            ````
           负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类
           库
            ````
       - 应用程序类加载器(Application ClassLoader)
            ````
           负责加载用户路径（classpath）上的类库。
           JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader
           实现自定义的类加载器
            ```` 
       ![演示图](https://s2.ax1x.com/2019/07/28/elbJ0A.jpg)
   +  双亲委派
        ````
        当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
        类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
        只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的
        Class），子类加载器才会尝试自己去加载。
        采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载
        器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载
        器最终得到的都是同样一个 Object 对象
        ````
   +  OSGI（ 动态模型系统 ）---[OSGI讲解](https://blog.csdn.net/jiaxuan7765/article/details/79408110)
        ````
        OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系
        统的一系列规范
        ````
        - 动态改变构造
            ````
              OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使
              这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方
            ````
        - 模块化编程与热插拔
            ````
              OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级
              的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企
              业级程序开发来说是非常具有诱惑力的特性。
              OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时
              也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大
              功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型
            ````
   #### 执行引擎 [Java的即时编译（Just In Time, JIT）及其优化](https://blog.csdn.net/shengzhu1/article/details/73281722)
   ````
    负责执行字节码  把方法编译成机器码 执行
   ````
### 关于对象存储
<p> 整理了下网上大佬的笔记 太多就不列出来了</p>

[一个对象的内存大小](https://www.cnblogs.com/magialmoon/p/3757767.html)
   + 2.1原生类型(primitive type)的内存占用如下：	
        ````
        boolean                      	        1  byte                          1
        short                           	2  char                          2
        int                               	4  float                         4
        long                            	8  double    	                 8
        reference类型在32位系统上每个占用4bytes, 在64位系统上每个占用8bytes。
        ````

   + 2.2 Java对象的内存布局：对象头（Header），实例数据（Instance Data）和对齐填充（Padding）
    <p>ps:对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）
     ````
     HotSpot的对齐方式为8字节对齐：
     （对象头 + 实例数据 + padding） % 8等于0且0 <= padding < 8
      对象头在32位系统上占用8bytes，64位系统上占用16bytes(  开启指针压缩12 )
     ````
   + 2.3 64位机器上reference类型占用8个字节，开启指针压缩后占用4个字节
        ````
         static class B2 {
                 int b2a;
                 Integer b2b;
            }
        ````
        <p>应该是  16+4+8=28不是8的倍数，所以+padding/4=32
   + 2.4 数组对象
        <p>64位机器上，数组对象的对象头占用24个字节（32位上面12  压缩之后应该是8bit ），启用压缩之后占用16个字节。之所以比普通对象占用内存多是因为需要额外的空间存储数组的长度
        <p>   一个new Integer[3] 的数组
        <p>   未开启压缩：24（对象头）+8*3=48，不需要padding；
        <p>  开启压缩：16（对象头）+3*4=28，+padding/4=32，其他依次类推。
   + 2.5 对象头
       <p>  1 存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”
       <p>  2 指向类的指针  该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit
       <p>  3  数组长度  只有数组对象保存了这部分数据。  该数据在32位和64位JVM中长度都是32bit。

####学习笔记  
   