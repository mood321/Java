### 收集本人常见的面试题 

#### 合集
 + Q: HashMap 
    <pre><code>
     A:（1）HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；
       （2）HashMap的默认初始容量为16（1&lt;&lt;4），默认装载因子为0.75f，容量总是2的n次方；
       （3）HashMap扩容时每次容量变为原来的两倍；
       （4）当桶的数量小于64时不会进行树化，只会扩容；
       （5）当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；
       （6）当单个桶中元素数量小于6时，进行反树化；
       （7）HashMap是非线程安全的容器；
       （8）HashMap查找添加元素的时间复杂度都为O(1)；
    </code></pre>
 + hashtable和concurrenthashmap如何实现线程安全？
 [concurrenthashmap 部分代码](https://github.com/mood321/JavaDemo/blob/master/src/main/resources/note/conllection/ConcurrentHashMap.md)
    ````
    A: 1 hashtable 线程安全是在主要方法上加的 synchronized  所以执行效率并不高
       2 concurrenthashmap 
       （1）ConcurrentHashMap是HashMap的线程安全版本；</p>
         （2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；</p>
         （3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；</p>
         （4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；</p>
         （5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；</p>
         （6）sizeCtl = -1，表示正在进行初始化；</p>
         （7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；</p>
         （8）sizeCtl > 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛； </p>
         （9）sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；</p>
         （10）更新操作时如果正在进行扩容，当前线程协助扩容；</p>
         （11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；</p>
         （12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；</p>
         （13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；</p>
         （14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；</p>
         （15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；</p>
         （16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；</p>
         （17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；</p>
         （18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；</p>
         （19）ConcurrentHashMap中不能存储key或value为null的元素；</p>
         （20）ConcurrentHashMap 扩容大小是原大小两倍 sizeCtl是新的扩容门槛 原来数据会hash&n 分成两部分 低位在原处 高位在原位置+n 处
 
            
    ````
    
    
    
#### JVM
  + jvm的内存布局和垃圾回收机制
  [jvm 部分笔记](https://github.com/mood321/JavaDemo/blob/master/src/main/resources/note/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md)
    ````
       1 内存模型
            1.线程私有
                A.程序计数器
                B.本地方法栈
                C.虚拟机栈 （-Xss 128k 默认1M）
                    a 栈帧 （方法执行时创建）
                    1 局部变量表
                    2 操作数栈
                    3 动态链接
                    4 返回地址
            。。。
            2.线程共有
            A.堆区（ 所有java对象和数组）
               a 新生代（1/3）-XXSurvivorRatio：Eden区和Survior区的占用比例 
                    1.Eden空间 
                    |  没有空间时 会执行 MIinor  GC----复制回收算法
                    2.From Survivor空间-----------------------
                    3.To Survivor空间----------------------------Survivor 用做交换 只有一个区有数据
               b 老年代（2/3）
                    1 在新生代 Survivor被回收次数默认为15，会进入老年代
                    2  大对象会直接进入老年代
                    3  当Survivor区相当年龄的对象 大小超过Survivor的一般  年龄大于或等于该年龄的对象进去老年代
                    
                    4 当老年代内存不够 进入FULL GC（新生代，老年代都回收 jvm会停止）
            B.方法区(元数据区)
                 类信息，常量，编译的代码信息
            C 直接内存
       2 回收算法
            标记清除算法(Mark-Sweep )
            复制算法(copying)
            标记整理算法(Mark-Compact)
            分代收集算法
       3  垃圾回收器
        Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收 算法 ；
        年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不
        同的垃圾收集器
            1 Serial 垃圾收集器  （单线程、 复制算法）
            2 ParNew 垃圾收集器 （ （Serial+多线程 多线程）
            3 Parallel Scavenge  收集器（多线程复制算法、高效）
            4 Serial Old  收集器（单线程标记整理算法 
            5 Parallel Old  收集器（多线程标记整理算法）
            6 CMS 收集器 （多线程标记清除算法）
            7 G1  收集器
    ````
  + 类加载机制和双亲委派模型
    ````
        1 类加载子系统
          负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间
          JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化， 验证，准备，解析算连接
          
        2 类加载器
          1 启动类加载器(Bootstrap ClassLoader)
          2 扩展类加载器(Extension ClassLoader)
          3 应用程序类加载器(Application ClassLoader)
          4 自定义加载器
        3  双亲委派
          1 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
           类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
           只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的
           Class），子类加载器才会尝试自己去加载。
          2  采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载
           器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载
           器最终得到的都是同样一个 Object 对象
          3 据深入理解jvm所讲 加载器有类名称空间 在同一加载器内 才能判断加载类是否一致   不同加载器加载同一个类 他们并不相等
          
    ````  
   
   
#### Spring
   + 阐述事务的隔离级别和传播属性
     ````
     1 spring 传播属性
        PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
        
        PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。
        
        PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
        
        PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
        
        PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。
        
        PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常
        
        PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行
     
     2 事物 存在的问题
        脏读：事务A读到了事务B未提交的数据。
        不可重复读：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到row1，但列内容发生了变化。
        幻读：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到两行记录row1和row2。
        脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
        
            也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。
        
        不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。
        
            也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。
        
        幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。
        
            也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。
        不可重复读和幻读比较：
             两者有些相似，但是前者针对的是update或delete，后者针对的insert。
      3 spring的隔离级别
        DEFAULT 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 .
        READ_UNCOMMITTED (读未提交)会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 )
        READ_COMMITTED  (读已提交或者叫不可重复读)会出现不可重复读、幻读问题（锁定正在读取的行）
        REPEATABLE_READ (可重复读 mysql默认)会出幻读（锁定所读取的所有行） 
        SERIALIZABLE 保证所有的情况不会发生（锁表）
        隔离级别等级越高 影响数据越多 性能越差
     ````   