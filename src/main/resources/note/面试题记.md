### 收集本人常见的面试题 

#### 合集
 + Q: HashMap 
    <pre><code>
     A:（1）HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；
       （2）HashMap的默认初始容量为16（1&lt;&lt;4），默认装载因子为0.75f，容量总是2的n次方；
       （3）HashMap扩容时每次容量变为原来的两倍；
       （4）当桶的数量小于64时不会进行树化，只会扩容；
       （5）当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；
       （6）当单个桶中元素数量小于6时，进行反树化；
       （7）HashMap是非线程安全的容器；
       （8）HashMap查找添加元素的时间复杂度都为O(1)；
    </code></pre>
 + hashtable和concurrenthashmap如何实现线程安全？
 [concurrenthashmap 部分代码](https://github.com/mood321/JavaDemo/blob/master/src/main/resources/note/conllection/ConcurrentHashMap.md)
    ````
    A: 1 hashtable 线程安全是在主要方法上加的 synchronized  所以执行效率并不高
       2 concurrenthashmap 
       （1）ConcurrentHashMap是HashMap的线程安全版本；</p>
         （2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；</p>
         （3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；</p>
         （4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；</p>
         （5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；</p>
         （6）sizeCtl = -1，表示正在进行初始化；</p>
         （7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；</p>
         （8）sizeCtl > 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛； </p>
         （9）sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；</p>
         （10）更新操作时如果正在进行扩容，当前线程协助扩容；</p>
         （11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；</p>
         （12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；</p>
         （13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；</p>
         （14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；</p>
         （15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；</p>
         （16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；</p>
         （17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；</p>
         （18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；</p>
         （19）ConcurrentHashMap中不能存储key或value为null的元素；</p>
         （20）ConcurrentHashMap 扩容大小是原大小两倍 sizeCtl是新的扩容门槛 原来数据会hash&n 分成两部分 低位在原处 高位在原位置+n 处
 
            
    ````
    
    
    
#### JVM
  + jvm的内存布局和垃圾回收机制
  [jvm 部分笔记](https://github.com/mood321/JavaDemo/blob/master/src/main/resources/note/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md)
    ````
       1 内存模型
            1.线程私有
                A.程序计数器
                B.本地方法栈
                C.虚拟机栈 （-Xss 128k 默认1M）
                    a 栈帧 （方法执行时创建）
                    1 局部变量表
                    2 操作数栈
                    3 动态链接
                    4 返回地址
            。。。
            2.线程共有
            A.堆区（ 所有java对象和数组）
               a 新生代（1/3）-XXSurvivorRatio：Eden区和Survior区的占用比例 
                    1.Eden空间 
                    |  没有空间时 会执行 MIinor  GC----复制回收算法
                    2.From Survivor空间-----------------------
                    3.To Survivor空间----------------------------Survivor 用做交换 只有一个区有数据
               b 老年代（2/3）
                    1 在新生代 Survivor被回收次数默认为15，会进入老年代
                    2  大对象会直接进入老年代
                    3  当Survivor区相当年龄的对象 大小超过Survivor的一般  年龄大于或等于该年龄的对象进去老年代
                    
                    4 当老年代内存不够 进入FULL GC（新生代，老年代都回收 jvm会停止）
            B.方法区(元数据区)
                 类信息，常量，编译的代码信息
            C 直接内存
       2 回收算法
            标记清除算法(Mark-Sweep )
            复制算法(copying)
            标记整理算法(Mark-Compact)
            分代收集算法
       3  垃圾回收器
        Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收 算法 ；
        年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不
        同的垃圾收集器
            1 Serial 垃圾收集器  （单线程、 复制算法）
            2 ParNew 垃圾收集器 （ （Serial+多线程 多线程）
            3 Parallel Scavenge  收集器（多线程复制算法、高效）
            4 Serial Old  收集器（单线程标记整理算法 
            5 Parallel Old  收集器（多线程标记整理算法）
            6 CMS 收集器 （多线程标记清除算法）
            7 G1  收集器
    ````
  + 类加载机制和双亲委派模型
    ````
        1 类加载子系统
          负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间
          JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化， 验证，准备，解析算连接
          
        2 类加载器
          1 启动类加载器(Bootstrap ClassLoader)
          2 扩展类加载器(Extension ClassLoader)
          3 应用程序类加载器(Application ClassLoader)
          4 自定义加载器
        3  双亲委派
          1 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
           类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
           只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的
           Class），子类加载器才会尝试自己去加载。
          2  采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载
           器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载
           器最终得到的都是同样一个 Object 对象
          3 据深入理解jvm所讲 加载器有类名称空间 在同一加载器内 才能判断加载类是否一致   不同加载器加载同一个类 他们并不相等
          
    ````  
   
   
#### Spring
   + 阐述事务的隔离级别和传播属性
     ````
     1 spring 传播属性
        PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
        
        PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。
        
        PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
        
        PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
        
        PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。
        
        PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常
        
        PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行
     
     2 事物 存在的问题
        脏读：事务A读到了事务B未提交的数据。
        不可重复读：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到row1，但列内容发生了变化。
        幻读：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到两行记录row1和row2。
        脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
        
            也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。
        
        不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。
        
            也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。
        
        幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。
        
            也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。
        不可重复读和幻读比较：
             两者有些相似，但是前者针对的是update或delete，后者针对的insert。
      3 spring的隔离级别
        DEFAULT 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 .
        READ_UNCOMMITTED (读未提交)会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 )
        READ_COMMITTED  (读已提交或者叫不可重复读)会出现不可重复读、幻读问题（锁定正在读取的行）
        REPEATABLE_READ (可重复读 mysql默认)会出幻读（锁定所读取的所有行） 
        SERIALIZABLE 保证所有的情况不会发生（锁表）
        隔离级别等级越高 影响数据越多 性能越差
     ````   

### 设计
  + 高并发下，如何做到安全的修改同一行数据
    [网上博客大概讲解](https://www.jianshu.com/p/83224c0f3bb9)
    <p>1. 在单体架构中 即数据修改下都在同意jvm下 可以给方法加锁 lock和synchronized 都可以
    <p>2. 在不同jvm中 即分布式下 分布式锁的特性是排他、避免死锁、高可用
    <p>2.1 数据库的乐观锁(通过版本号)或者悲观锁(通过for update)
    <p>2.2.1  Redis的setnx()命令
    <p>2.2.2  Redisson 实现了JDK中的Lock接口，所以使用方式一样，只是Redssion的锁是分布式的 可重入 重入加1  
   [笔记](https://github.com/mood321/springboot-demo/blob/master/springboot-redisson/%E7%AC%94%E8%AE%B0.md)
    <p>。获取锁流程</p>
    <pre><code>  
    1、判断有没有一个叫“abc”的key
    2、如果没有，则在其下设置一个字段为“6f0829ed-bfd3-4e6f-bba3-6f3d66cd176c:Thread-1”，值为“1”的键值对 ，并设置它的过期时间
    3、如果存在，则进一步判断“6f0829ed-bfd3-4e6f-bba3-6f3d66cd176c:Thread-1”是否存在，若存在，则其值加1，并重新设置过期时间
    4、返回“abc”的生存时间（毫秒）
     </code> </pre>
     <p>。释放锁流程
     <pre><code>
     1、判断是否存在一个叫“abc”的key
     2、如果不存在，向Channel中广播一条消息，广播的内容是0，并返回1
     3、如果存在，进一步判断字段6f0829ed-bfd3-4e6f-bba3-6f3d66cd176c:Thread-1是否存在
     4、若字段不存在，返回空，若字段存在，则字段值减1
     5、若减完以后，字段值仍大于0，则返回0
     6、减完后，若字段值小于或等于0，则广播一条消息，广播内容是0，并返回1；
    </code> </pre>
    <p>2.3 Zookeeper一共四种节点类型
    <p>   1 持久型 2 持久带序号 3 临时节点 4 临时带序号节点
    <p>2.3.1 Zookeeper(在某个持久节点添加临时有序节点，判断当前节点是否是序列中最小的节点，如果不是则监听比当前节点还要小的节点。如果是，获取锁成功。当被监听的节点释放了锁(也就是被删除)，会通知当前节点。然后当前节点再尝试获取锁，如此反复)
    <p>2.3.2 Zookeeper 可以同不带序号节点 如果存在 添加会报异常 完成分布式锁的功能

  + a服务调用b服务多接口，响应时间最短方案    
       ````
       用多线程或者线程池跑  拿到返回future（线程池是FutureTask）   
       还有service内多线程执行任务 也可以拿到FutureTask 统一提交或者回滚
      ````
  +  a系统给b系统转100块钱，如何实现
    <p>  产生的问题： 数据一致性,性能问题,重复提交的问题
    <p> 1 事物解决数据一致性问题 2 编程式事物一定程度优化了性能 3 cas 加版本号 完成幂等性
  +  多线程下读概率远远大于写概率，如何解决并发问题？
    <p> 1 volatile 多用于一写多读
    <p> 2 自己加读写锁 ReentrantReadWriteLock 多写多读
    <p> 3 CopyOnWrite系列容器  (读多写少  有脏读问题和性能内存问题  他会创建新数组添加 然后添加 把新赋值给原来引用)
   